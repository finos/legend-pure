// Copyright 2021 Goldman Sachs
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

###Pure
import meta::pure::mapping::aggregationAware::*;
import meta::json::*;
import meta::pure::router::extension::*;
import meta::protocols::*;
import meta::pure::mapping::modelToModel::*;
import meta::protocols::pure::vX_X_X::transformation::fromPureGraph::context::*;
import meta::pure::router::routing::*;
import meta::protocols::pure::vX_X_X::invocation::execution::execute::*;
import meta::protocols::pure::vX_X_X::transformation::fromPureGraph::*;
import meta::protocols::pure::vX_X_X::transformation::fromPureGraph::runtime::*;
import meta::pure::functions::io::http::*;
import meta::pure::runtime::*;
import meta::pure::mapping::*;
import meta::pure::milestoning::*;
import meta::alloy::metadataServer::*;
import meta::relational::milestoning::*;
import meta::relational::mapping::*;

function meta::protocols::pure::vX_X_X::invocation::execution::execute::processTDSResult(r:meta::protocols::pure::vX_X_X::metamodel::invocation::execution::execute::RelationalTDSResult[1], extensions:meta::pure::router::extension::RouterExtension[*]) : Pair<List<Any>,List<Activity>>[1]
{
   let res = ^TabularDataSet
             (
                columns = $r.builder->cast(@meta::protocols::pure::vX_X_X::metamodel::invocation::execution::execute::TDSBuilder).columns
                            ->map({c |
                                    ^TDSColumn
                                    (
                                       name = $c.name,
                                       documentation = $c.doc,
                                       type = $c.type->toOne()->stringToDataType(),
                                       offset = $r.result.columns->indexOf($c.name)
                                    )})
             );

   let trans = $r.builder->cast(@meta::protocols::pure::vX_X_X::metamodel::invocation::execution::execute::TDSBuilder).columns.type->map(c|meta::protocols::pure::vX_X_X::invocation::execution::execute::dataTypeTransformer($c));

   let ra = range($r.result.columns->size());

   let newRows = $r.result.rows
                  ->map({r |
                            let vals = $r.values;
                            ^TDSRow
                            (
                               parent = $res,
                               values = $ra->map(i | let v = $vals->at($i);
                                                    if($v->instanceOf(TDSNull),
                                                       | $v,
                                                       | $trans->at($i)->eval($v);
                                                    );
                                               )
                            );
                        });
   $res->mutateAdd('rows', $newRows);
   ^Pair<List<Any>, List<Activity>>(first=^List<Any>(values=$res), second=^List<Activity>(values=$r.activities->transformActivities($extensions)));
}



function meta::protocols::pure::vX_X_X::invocation::execution::execute::processDataTypeResult(r:meta::protocols::pure::vX_X_X::metamodel::invocation::execution::execute::RelationalDataTypeResult[1], extensions:meta::pure::router::extension::RouterExtension[*]) : Pair<List<Any>,List<Activity>>[1]
{
   let type = $r.builder->cast(@meta::protocols::pure::vX_X_X::metamodel::invocation::execution::execute::DataTypeBuilder).type;
   let trans = meta::protocols::pure::vX_X_X::invocation::execution::execute::dataTypeTransformer($type);
   ^Pair<List<Any>, List<Activity>>(first=^List<Any>(values=$r.result.rows.values->map(v|$trans->eval($v))), second=^List<Activity>(values=$r.activities->transformActivities($extensions)));

}

function meta::protocols::pure::vX_X_X::invocation::execution::execute::processRelationalClassResult(r:meta::protocols::pure::vX_X_X::metamodel::invocation::execution::execute::RelationalClassResult[1], m:Mapping[1], pureRuntime:Runtime[1], context:ExecutionContext[0..1], extensions:meta::pure::router::extension::RouterExtension[*]) : Pair<List<Any>,List<Activity>>[1]
{
   let builder = $r.builder->cast(@ meta::protocols::pure::vX_X_X::metamodel::invocation::execution::execute::ClassBuilder);

   let retClass = $builder.class->pathToElement()->cast(@Class<Any>);

   let setImplementations = $r.builder->cast(@meta::protocols::pure::vX_X_X::metamodel::invocation::execution::execute::ClassBuilder).classMappings.setImplementationId->map(
                                             s:String[1]|$m.classMappingById($s)
                                          )->cast(@RootRelationalInstanceSetImplementation);

   let setImplMap = $setImplementations->map(set | pair($set.id, pair($set, meta::pure::milestoning::getTemporalMilestoningStrategy($set.class)->isNotEmpty() && meta::pure::milestoning::getTemporalMilestoningStrategy($set.class)->toOne()->meta::pure::milestoning::expandToSingleTemporalStrategies()->forAll(s| $s->meta::relational::milestoning::relationalElementCanSupportStrategy($set.mainTable())))))->newMap();

   let exeCtx = if($context->isEmpty(), | ^ExecutionContext(), | $context->toOne());
   let precas =  $setImplementations->map(set | pair($set.id, precaForRelationalSetImpl($set, $m, $pureRuntime, $exeCtx, $extensions)))->newMap();
   let objects = $r.objects->map({obj |
   let reference = $obj->get('alloyStoreObjectReference$')->toOne()->cast(@String)->decodeAndParseAlloyObjectReference()->cast(@meta::protocols::pure::vX_X_X::metamodel::objectReference::AlloyRelationalStoreObjectReference);
   let setId = $reference.setId;
   let preca = $precas->get($setId)->toOne();

   let pkMap = $reference.pkMap;
   let pks = $preca.pks->size()->range()->map({pkId |
      let key = $preca.pks->at($pkId);
      let jsonKey = 'pk$_' + $pkId->toString() + if($reference.operationResolvedSetsId->size() == 1, | '', | '_' + $reference.operationResolvedSetsId->indexOf($setId)->toString());
      if($key.type->isNotEmpty() && ($key.type->toOne()->instanceOf(meta::relational::metamodel::datatype::Timestamp) || $key.type->toOne()->instanceOf(meta::relational::metamodel::datatype::Date)),
         | parseDate($pkMap->get($jsonKey)->toOne()->cast(@String)),
         | $pkMap->get($jsonKey)->toOne()
      );
   });
   let keyInformation = ^KeyInformation (
                           static = $preca.staticMappingInstanceData,
                           pk = $pks,
                           sourceConnection = $preca.sourceConnection,
                           deepFetchCache = [],
                           buildMethod = BuildMethod.TypeQuery
                        );

   $preca.type->dynamicNew(
                   $preca.propMap->map({precav|
                      let v = $obj->get($precav.property.name->toOne());
                      ^KeyValue(
                         key = $precav.property.name->toOne(),
                         value = if($v->isEmpty() || $v == 'NULL' || $v->toOne()->instanceOf(TDSNull),
                                    | [],
                                    | if($precav.property->functionReturnType().rawType == Date,
                                         | parseDate($v->toOne()->toString()),
                                         | $precav.transform->eval($v->toOne())
                                      )
                                 )->match([
                                    l : List<Any>[*] | $l.values,
                                    a : Any[*] | $a
                                    ])
                      );
                      })->concatenate($preca.addMilestoningProperties->if(|$preca.type.rawType->toOne()->cast(@Class<Any>).properties->filter(p| $p->genericType().typeArguments->at(1).rawType->toOne()->instanceOf(meta::pure::metamodel::type::DataType) && $p->meta::pure::milestoning::hasGeneratedMilestoningPropertyStereotype())->map({prop |
                            let v = $obj->get($prop.name->toOne());
                            ^KeyValue(
                               key = $prop.name->toOne(),
                               value = if($v->isEmpty() || $v == 'NULL' || $v->toOne()->instanceOf(TDSNull),
                                          | [],
                                          | if($prop->functionReturnType().rawType == Date,
                                               | parseDate($v->toOne()->toString()),
                                               | $v->toOne()
                                            )
                                       )
                            );
                         }), |[])),
                         meta::pure::mapping::xStore::crossGetterOverrideToOne_Any_1__Property_1__Any_$0_1$_,
                         meta::pure::mapping::xStore::crossGetterOverrideToMany_Any_1__Property_1__Any_MANY_,
                         $keyInformation,
                         $exeCtx->getConstraintsManager()
                     );
                   });
   ^Pair<List<Any>, List<Activity>>(first=^List<Any>(values=$objects), second=^List<Activity>(values=$r.activities->transformActivities($extensions)));
}




function meta::protocols::pure::vX_X_X::invocation::execution::execute::generateAlloyObjectReference(mapping:Mapping[1], rootSetId:String[1], setId:String[1], runtime:Runtime[1], pkMap:Map<String, Any>[1], extensions:meta::pure::router::extension::RouterExtension[*]):meta::protocols::pure::vX_X_X::metamodel::objectReference::AlloyObjectReference[1]
{
   let sets                 = $mapping.classMappingById($rootSetId)->resolveOperation($mapping);
   assert($sets->size() >= 1, | 'No Set Implementation found for setId : ' + $rootSetId + ', in mapping : ' + $mapping->elementToPath());

   let set                  = $sets->filter(s | $s.id == $setId)->toOne();

   $set->match([
      r: RelationalInstanceSetImplementation[1] | meta::protocols::pure::vX_X_X::invocation::execution::execute::generateAlloyRelationalStoreObjectReference($mapping, $r, $sets, $runtime, $pkMap, $extensions);,
      s: SetImplementation[1]                   | fail('Not Supported Yet!!'); ^meta::protocols::pure::vX_X_X::metamodel::objectReference::AlloyObjectReference(type = meta::protocols::pure::vX_X_X::metamodel::objectReference::AlloyObjectReferenceType.Relational, pathToMapping='', setId='');
   ]);
}

function meta::protocols::pure::vX_X_X::invocation::execution::execute::generateAlloyRelationalStoreObjectReference(mapping:Mapping[1], set:RelationalInstanceSetImplementation[1], sets:SetImplementation[*], runtime:Runtime[1], pkMap:Map<String, Any>[1], extensions:meta::pure::router::extension::RouterExtension[*]):meta::protocols::pure::vX_X_X::metamodel::objectReference::AlloyRelationalStoreObjectReference[1]
{
   let store                = $set.stores->toOne();
   let databaseConnection   = $runtime->connectionByElement($store->toOne())->meta::protocols::pure::vX_X_X::transformation::fromPureGraph::runtime::transformConnection($extensions)->cast(@meta::protocols::pure::vX_X_X::metamodel::store::relational::connection::DatabaseConnection);

   let setIdx               = if($sets->size() == 1, | '', | '_' + $sets->indexOf($set)->toString());
   let transformedPkMap     = meta::relational::mapping::resolvePrimaryKeysNames($set->cast(@RelationalInstanceSetImplementation), $pkMap, $setIdx, true, $extensions);

   ^meta::protocols::pure::vX_X_X::metamodel::objectReference::AlloyRelationalStoreObjectReference(
      type = meta::protocols::pure::vX_X_X::metamodel::objectReference::AlloyObjectReferenceType.Relational,
      pathToMapping = $mapping->elementToPath(),
      setId = $set.id,
      operationResolvedSetsId = $sets.id,
      databaseConnection = $databaseConnection,
      pkMap = $transformedPkMap);
}

function meta::protocols::pure::vX_X_X::invocation::execution::execute::decodeAndParseAlloyObjectReference(ref : String[1]):meta::protocols::pure::vX_X_X::metamodel::objectReference::AlloyObjectReference[1]
{
   assert($ref->substring(0, 4) == 'ASOR', | 'Reference should start with "ASOR"');
   let decodedRef = $ref->substring(5)->decodeBase64();
   let version = $decodedRef->substring(0, 3)->parseInteger();

   if($version == 1,
      | parseAlloyObjectReferenceV1($decodedRef->substring(4)),
      | fail('Version v1 only supported!'); parseAlloyObjectReferenceV1($ref);
   );
}


function meta::protocols::pure::vX_X_X::invocation::execution::execute::parseAlloyObjectReferenceV1(ref : String[1]):meta::protocols::pure::vX_X_X::metamodel::objectReference::AlloyObjectReference[1]
{
   let lengthStringSize = $ref->substring(0, 3)->parseInteger();

   let typeStart = 4 + $lengthStringSize + 1;
   let typeStringLength = $ref->substring(4, 4 + $lengthStringSize)->parseInteger();
   let typeEnd = $typeStart + $typeStringLength;
   let type = $ref->substring($typeStart, $typeEnd);

   if($type->toLower() == 'relational',
      |parseAlloyRelationalStoreObjectReferenceV1($ref->substring($typeEnd+1), $lengthStringSize),
      |fail('Not Supported Yet!!'); parseAlloyRelationalStoreObjectReferenceV1('', 0););
}

function meta::protocols::pure::vX_X_X::invocation::execution::execute::parseAlloyRelationalStoreObjectReferenceV1(ref : String[1], lengthStringSize:Integer[1]):meta::protocols::pure::vX_X_X::metamodel::objectReference::AlloyRelationalStoreObjectReference[1]
{
   let mappingStart = $lengthStringSize + 1;
   let mappingStringLength = $ref->substring(0, $mappingStart - 1)->parseInteger();
   let mappingEnd = $mappingStart + $mappingStringLength;
   let mapping = $ref->substring($mappingStart, $mappingEnd);

   let allSetsStart = $mappingEnd + 1 + $lengthStringSize + 1;
   let allSetsStringLength = $ref->substring($mappingEnd + 1, $allSetsStart - 1)->parseInteger();
   let allSetsEnd = $allSetsStart + $allSetsStringLength;
   let allSets = $ref->substring($allSetsStart, $allSetsEnd);

   let setStart = $allSetsEnd + 1 + $lengthStringSize + 1;
   let setStringLength = $ref->substring($allSetsEnd + 1, $setStart - 1)->parseInteger();
   let setEnd = $setStart + $setStringLength;
   let set = $ref->substring($setStart, $setEnd);

   let dbConnStart = $setEnd + 1 + $lengthStringSize + 1;
   let dbConnStringLength = $ref->substring($setEnd + 1, $dbConnStart - 1)->parseInteger();
   let dbConnEnd = $dbConnStart + $dbConnStringLength;
   let dbConn = $ref->substring($dbConnStart, $dbConnEnd);

   let pkMapStart = $dbConnEnd + 1 + $lengthStringSize + 1;
   let pkMapStringLength = $ref->substring($dbConnEnd + 1, $pkMapStart - 1)->parseInteger();
   let pkMapEnd = $pkMapStart + $pkMapStringLength;
   let pkMap = $ref->substring($pkMapStart, $pkMapEnd);

   let databaseConnection = $dbConn->parseJSON()->cast(@JSONObject)->map(o | ^meta::protocols::pure::vX_X_X::metamodel::store::relational::connection::DatabaseConnection(_type = $o->getValue('_type')->cast(@JSONString).value->toOne(),
                                                                                                                                                                          element = $o->getValue('element')->cast(@JSONString).value->toOne(),
                                                                                                                                                                          type = $o->getValue('type')->cast(@JSONString).value->toOne()
                                                                                                                                                                        ));
   ^meta::protocols::pure::vX_X_X::metamodel::objectReference::AlloyRelationalStoreObjectReference
    (
       type = meta::protocols::pure::vX_X_X::metamodel::objectReference::AlloyObjectReferenceType.Relational,
       pathToMapping = $mapping,
       operationResolvedSetsId = $allSets->split(';'),
       setId = $set,
       databaseConnection = $databaseConnection,
       pkMap = $pkMap->fromJSON(Map)->cast(@Map<String, Any>)
    );
}

function meta::protocols::pure::vX_X_X::invocation::execution::execute::getAlloyObjectReferenceAsMap(ref : String[1]):Map<String, Any>[1]
{
   let objReference = meta::protocols::pure::vX_X_X::invocation::execution::execute::decodeAndParseAlloyObjectReference($ref);

   $objReference->match([
      r:meta::protocols::pure::vX_X_X::metamodel::objectReference::AlloyRelationalStoreObjectReference[1] |
                                                                                                            [
                                                                                                               pair('type', $r.type->toString()),
                                                                                                               pair('pathToMapping', $r.pathToMapping),
                                                                                                               pair('operationResolvedSetsId', $r.operationResolvedSetsId->list()),
                                                                                                               pair('setId', $r.setId),
                                                                                                               pair('databaseConnection', $r.databaseConnection),
                                                                                                               pair('pkMap', $r.pkMap)
                                                                                                            ]->newMap();,
      o:meta::protocols::pure::vX_X_X::metamodel::objectReference::AlloyObjectReference[1] | fail('Not Supported Yet!!'); ^Map<String, Any>();
   ]);
}

function meta::protocols::pure::vX_X_X::invocation::execution::execute::transformActivities(activities:meta::protocols::pure::vX_X_X::metamodel::invocation::execution::execute::ExecutionActivity[*], extensions:meta::pure::router::extension::RouterExtension[*]):meta::pure::mapping::Activity[*]
{
   $activities->map(activity|$activity->match([
      a:meta::protocols::pure::vX_X_X::metamodel::invocation::execution::execute::AggregationAwareActivity[1]    | ^AggregationAwareActivity(rewrittenQuery = $a.rewrittenQuery),
      r:meta::protocols::pure::vX_X_X::metamodel::invocation::execution::execute::RelationalExecutionActivity[1] | ^RelationalActivity(sql=$r.sql)
   ]->concatenate($extensions.serializerExtension('vX_X_X')->cast(@meta::protocols::pure::vX_X_X::extension::SerializerExtension_vX_X_X).transfers_execute_transformActivity)->toOneMany()))
}

function <<access.private>> meta::protocols::pure::vX_X_X::invocation::execution::execute::precaForRelationalSetImpl(setImplementation:RootRelationalInstanceSetImplementation[1], mapping: Mapping[1], runtime: Runtime[1], exeCtx: ExecutionContext[1], extensions:meta::pure::router::extension::RouterExtension[*]):RelationalSetImplPrecalc[1]
{
   let propertyMappings = $setImplementation.allPropertyMappings()
                                    ->filter(pm|$pm.localMappingProperty==false &&
                                                $pm.property->genericType().typeArguments->at(1).rawType->toOne()->instanceOf(meta::pure::metamodel::type::DataType)
                                    );

   let ps = $propertyMappings->map(p|^meta::protocols::pure::vX_X_X::invocation::execution::execute::PropMapPrecalc(
                                                                                                    property = $p.property,
                                                                                                    transform = if ($p->cast(@RelationalPropertyMapping).transformer->isEmpty(),
                                                                                                                    |let type = $p.property->functionReturnType().rawType->toOne();
                                                                                                                         if ($type == DateTime,
                                                                                                                            |{z:Any[1]|$z->cast(@String)->parseDate()},
                                                                                                                            |if ($type == StrictDate,
                                                                                                                               |{z:Any[1]|$z->cast(@String)->parseDate()->datePart()->cast(@StrictDate)},
                                                                                                                               |{z:Any[1]|$z}
                                                                                                                             )
                                                                                                                        );,
                                                                                                                    |{z:Any[1]|extractEnumValue(
                                                                                                                                   $p.property->functionReturnType().rawType->toOne()->cast(@Enumeration<Any>),
                                                                                                                                   $z->toString()
                                                                                                                               )}
                                                                                                                )
                                                                                            )
                       );
   ^RelationalSetImplPrecalc
   (
      type = ^GenericType(rawType = $setImplementation.class),
      staticMappingInstanceData = ^meta::pure::mapping::StaticMappingInstanceData
                                   (
                                      runtime = $runtime,
                                      mapping = $mapping,
                                      systemMapping = meta::pure::router::systemMapping::relationalSystemMapping(),
                                      setImplementation = $setImplementation,
                                      exeCtx = $exeCtx,
                                      debug = noDebug(),
                                      extensions = $extensions
                                   ),
      pks = if($setImplementation->meta::relational::functions::pureToSqlQuery::getGroupBy()->isEmpty() && ($setImplementation->meta::relational::functions::pureToSqlQuery::getDistinct()->isEmpty() || $setImplementation->meta::relational::functions::pureToSqlQuery::getDistinct()->toOne() == false),
               | $setImplementation.resolvePrimaryKey()->map(pk | ^RelationalSetPrimaryKey(element = $pk, type = $pk->meta::relational::functions::typeInference::inferRelationalType())),
               | []),
      sourceConnection = $runtime->connectionByElement($setImplementation->meta::pure::router::clustering::getResolvedStore($mapping)->toOne())->toOne(),
      propMap = $ps,
      addMilestoningProperties = meta::pure::milestoning::getTemporalMilestoningStrategy($setImplementation.class)->isNotEmpty() && meta::pure::milestoning::getTemporalMilestoningStrategy($setImplementation.class)->toOne()->meta::pure::milestoning::expandToSingleTemporalStrategies()->forAll(s| $s->meta::relational::milestoning::relationalElementCanSupportStrategy($setImplementation.mainTable()))
   );
}

function <<access.private>> meta::protocols::pure::vX_X_X::invocation::execution::execute::dataTypeTransformer(c:String[1]):Function<{Any[1]->Any[1]}>[1]
{
   if($c == 'Float' || $c == 'Number',
      |{a:Any[1]|$a->cast(@Number)*1.0},
      |if ($c == 'Decimal',
           |{a:Any[1]|let e = $a->cast(@Number)*1.0; $e->toDecimal();},
           |if ($c == 'StrictDate',
              |{a:Any[1]|$a->cast(@String)->parseDate()->datePart()->cast(@StrictDate)},
              |if ($c == 'Date' || $c == 'DateTime',
                   |{a:Any[1]|$a->cast(@String)->parseDate()},
                   |if ($c == 'Boolean',
                        |{a:Any[1]|if($a=='false'||$a==false,|false,|true);},
                        |if ($c->contains('::'),
                             |let t = $c->pathToElement()->cast(@Enumeration<Any>);
                              {a:Any[1]|$t->extractEnumValue($a->toString())};,
                             |{a:Any[1]|$a}
                         )
                    )
               )
           )
       )
   );
}

Class <<access.private>> meta::protocols::pure::vX_X_X::invocation::execution::execute::RelationalSetImplPrecalc
{
   type : GenericType[1];
   staticMappingInstanceData: meta::pure::mapping::StaticMappingInstanceData[1];
   propMap : PropMapPrecalc[*];
   sourceConnection : Connection[1];
   pks: meta::protocols::pure::vX_X_X::invocation::execution::execute::RelationalSetPrimaryKey[*];
   addMilestoningProperties : Boolean[1];
}

Class meta::protocols::pure::vX_X_X::invocation::execution::execute::RelationalSetPrimaryKey
{
   element : meta::relational::metamodel::RelationalOperationElement[1];
   type : meta::relational::metamodel::datatype::DataType[0..1];
}

Class <<access.private>> meta::protocols::pure::vX_X_X::invocation::execution::execute::PropMapPrecalc
{
   property : Property<Nil,Any|*>[1];
   transform : Function<{Any[1]->Any[1]}>[1];
}

###Pure
import meta::protocols::pure::vX_X_X::transformation::fromPureGraph::context::*;
import meta::protocols::pure::vX_X_X::invocation::execution::execute::*;
import meta::protocols::pure::vX_X_X::transformation::fromPureGraph::*;
import meta::protocols::pure::vX_X_X::transformation::fromPureGraph::runtime::*;
import meta::pure::functions::io::http::*;
import meta::pure::runtime::*;
import meta::pure::mapping::*;
import meta::alloy::metadataServer::*;
import meta::json::*;
import meta::protocols::pure::vX_X_X::invocation::execution::testDataGeneration::*;

Class meta::protocols::pure::vX_X_X::invocation::execution::testDataGeneration::SeedDataGenerationInput
{
   clientVersion : String[1];
   function : meta::protocols::pure::vX_X_X::metamodel::valueSpecification::raw::Lambda[1];
   mapping : String[1];
   runtime : meta::protocols::pure::vX_X_X::metamodel::Runtime[1];
   context : meta::protocols::pure::vX_X_X::metamodel::ExecutionContext[0..1];
   model : meta::protocols::pure::vX_X_X::metamodel::PureModelContext[1];
   parameters : Any[*];
}

Class meta::protocols::pure::vX_X_X::invocation::execution::testDataGeneration::TestDataGenerationWithSeedInput
{
   clientVersion : String[1];
   function : meta::protocols::pure::vX_X_X::metamodel::valueSpecification::raw::Lambda[1];
   mapping : String[1];
   runtime : meta::protocols::pure::vX_X_X::metamodel::Runtime[1];
   context : meta::protocols::pure::vX_X_X::metamodel::ExecutionContext[0..1];
   model : meta::protocols::pure::vX_X_X::metamodel::PureModelContext[1];
   hashStrings : Boolean[0..1];
   tableRowIdentifiers : meta::protocols::pure::vX_X_X::metamodel::testDataGeneration::TableRowIdentfiiers[*];
}

Class meta::protocols::pure::vX_X_X::invocation::execution::testDataGeneration::TestDataGenerationWithDefaultSeedInput
{
   clientVersion : String[1];
   function : meta::protocols::pure::vX_X_X::metamodel::valueSpecification::raw::Lambda[1];
   mapping : String[1];
   runtime : meta::protocols::pure::vX_X_X::metamodel::Runtime[1];
   context : meta::protocols::pure::vX_X_X::metamodel::ExecutionContext[0..1];
   model : meta::protocols::pure::vX_X_X::metamodel::PureModelContext[1];
   parameters : Any[*];
   hashStrings : Boolean[0..1];
}

function meta::protocols::pure::vX_X_X::invocation::execution::testDataGeneration::alloyGenerateSeedDataInteractive(f:FunctionDefinition<Any>[1], m:Mapping[1], pureRuntime:Runtime[1], context:ExecutionContext[0..1], parameters: Any[*], host:String[1], port:Integer[1], version:String[1], extensions:meta::pure::router::extension::RouterExtension[*]):String[1]
{
   alloyGenerateSeedData($f, $m, $pureRuntime, $context, $parameters, '-1', $host, $port, $version, ExecutionMode.INTERACTIVE->toString(), $extensions)
}

function meta::protocols::pure::vX_X_X::invocation::execution::testDataGeneration::alloyGenerateSeedDataSemiInteractive(f:FunctionDefinition<Any>[1], m:Mapping[1], pureRuntime:Runtime[1], context:ExecutionContext[0..1], parameters: Any[*], host:String[1], port:Integer[1], version:String[1], extensions:meta::pure::router::extension::RouterExtension[*]):String[1]
{
   alloyGenerateSeedData($f, $m, $pureRuntime, $context, $parameters, '-1', $host, $port, $version, ExecutionMode.SEMI_INTERACTIVE->toString(), $extensions)
}

function meta::protocols::pure::vX_X_X::invocation::execution::testDataGeneration::alloyGenerateSeedDataInteractive(f:FunctionDefinition<Any>[1], m:Mapping[1], pureRuntime:Runtime[1], context:ExecutionContext[0..1], parameters: Any[*], baseVersion:String[1], host:String[1], port:Integer[1], version:String[1], extensions:meta::pure::router::extension::RouterExtension[*]):String[1]
{
   alloyGenerateSeedData($f, $m, $pureRuntime, $context, $parameters, $baseVersion, $host, $port, $version, ExecutionMode.INTERACTIVE->toString(), $extensions)
}

function meta::protocols::pure::vX_X_X::invocation::execution::testDataGeneration::alloyGenerateSeedDataSemiInteractive(f:FunctionDefinition<Any>[1], m:Mapping[1], pureRuntime:Runtime[1], context:ExecutionContext[0..1], parameters: Any[*], baseVersion:String[1], host:String[1], port:Integer[1], version:String[1], extensions:meta::pure::router::extension::RouterExtension[*]):String[1]
{
   alloyGenerateSeedData($f, $m, $pureRuntime, $context, $parameters, $baseVersion, $host, $port, $version, ExecutionMode.SEMI_INTERACTIVE->toString(), $extensions)
}

function meta::protocols::pure::vX_X_X::invocation::execution::testDataGeneration::alloyGenerateSeedData(f:FunctionDefinition<Any>[1], m:Mapping[1], pureRuntime:Runtime[1], context:ExecutionContext[0..1], parameters: Any[*], baseVersion:String[1], host:String[1], port:Integer[1], version:String[1], executionMode:String[1], extensions:meta::pure::router::extension::RouterExtension[*]):String[1]
{
   let transformedContext = if($context->isNotEmpty(), | $context->toOne()->transformContext($extensions),| []);
   let execMode = ExecutionMode->extractEnumValue($executionMode);

   let toOrigin = {m:Mapping[1], p:meta::protocols::Protocol[1] | buildPureModelContextPointer(^meta::protocols::pure::vX_X_X::metamodel::PackageableElementPointer(type=meta::protocols::pure::vX_X_X::metamodel::PackageableElementType.MAPPING, path=$m->elementToPath()), $baseVersion, $p)};

   let resultJSON = ^meta::protocols::pure::vX_X_X::invocation::execution::testDataGeneration::SeedDataGenerationInput
   (
      clientVersion = 'vX_X_X',
      function = transformLambda($f, $extensions),
      mapping = $m->elementToPath(),
      runtime = transformRuntime($pureRuntime, $extensions),
      context = $transformedContext,
      model = if($execMode == ExecutionMode.SEMI_INTERACTIVE,
                  |let stores =  $pureRuntime.connections.element->cast(@meta::pure::store::Store)
                                    ->map(s|$s->findAllStoreIncludes())
                                    ->removeDuplicates()
                                    ->map(c|^meta::protocols::pure::vX_X_X::metamodel::PackageableElementPointer(type=meta::protocols::pure::vX_X_X::metamodel::PackageableElementType.STORE,path=$c->elementToPath()));
                   let mapping = ^meta::protocols::pure::vX_X_X::metamodel::PackageableElementPointer(type=meta::protocols::pure::vX_X_X::metamodel::PackageableElementType.MAPPING,path=$m->elementToPath());
                   ^meta::protocols::pure::vX_X_X::metamodel::PureModelContextPointer
                   (
                      _type='pointer',
                      serializer = ^meta::protocols::Protocol
                                   (
                                      name='pure',
                                      version = 'vX_X_X'
                                   ),
                      sdlcInfo = ^meta::protocols::pure::vX_X_X::metamodel::PureSDLC
                                 (
                                    _type = 'pure',
                                    baseVersion = $baseVersion,
                                    version = 'none',
                                    packageableElementPointers = $stores->concatenate($mapping)
                                 )
                   );,
                  |$m->buildBasePureModelFromMapping($toOrigin, $extensions).second
               ),
      parameters = $parameters
   )->alloyToJSON();

   let resp = executeHTTPRaw(^URL(host = $host , port=$port, path = '/api/pure/'+$version+'/execution/testDataGeneration/generateSeedData'),
                                 HTTPMethod.POST,
                                 'application/json',
                                 $resultJSON
         );
   assertEq(200, $resp.statusCode, | $resp.statusCode->toString()+' \''+$resp.entity+'\'');
   $resp.entity;
}

function meta::protocols::pure::vX_X_X::invocation::execution::testDataGeneration::alloyGenerateTestDataWithSeedInteractive(f:FunctionDefinition<Any>[1], m:Mapping[1], pureRuntime:Runtime[1], context:ExecutionContext[0..1], tableRowIdentifiers: meta::relational::testDataGeneration::TableRowIdentifiers[*], hashStrings: Boolean[0..1], host:String[1], port:Integer[1], version:String[1], extensions:meta::pure::router::extension::RouterExtension[*]):String[1]
{
   alloyGenerateTestDataWithSeed($f, $m, $pureRuntime, $context, $tableRowIdentifiers, $hashStrings, '-1', $host, $port, $version, ExecutionMode.INTERACTIVE->toString(), $extensions)
}

function meta::protocols::pure::vX_X_X::invocation::execution::testDataGeneration::alloyGenerateTestDataWithSeedSemiInteractive(f:FunctionDefinition<Any>[1], m:Mapping[1], pureRuntime:Runtime[1], context:ExecutionContext[0..1], tableRowIdentifiers: meta::relational::testDataGeneration::TableRowIdentifiers[*],  hashStrings: Boolean[0..1], host:String[1], port:Integer[1], version:String[1], extensions:meta::pure::router::extension::RouterExtension[*]):String[1]
{
   alloyGenerateTestDataWithSeed($f, $m, $pureRuntime, $context, $tableRowIdentifiers, $hashStrings, '-1', $host, $port, $version, ExecutionMode.SEMI_INTERACTIVE->toString(), $extensions)
}

function meta::protocols::pure::vX_X_X::invocation::execution::testDataGeneration::alloyGenerateTestDataWithSeedInteractive(f:FunctionDefinition<Any>[1], m:Mapping[1], pureRuntime:Runtime[1], context:ExecutionContext[0..1], tableRowIdentifiers: meta::relational::testDataGeneration::TableRowIdentifiers[*], hashStrings: Boolean[0..1], baseVersion:String[1], host:String[1], port:Integer[1], version:String[1], extensions:meta::pure::router::extension::RouterExtension[*]):String[1]
{
   alloyGenerateTestDataWithSeed($f, $m, $pureRuntime, $context, $tableRowIdentifiers, $hashStrings, $baseVersion, $host, $port, $version, ExecutionMode.INTERACTIVE->toString(), $extensions)
}

function meta::protocols::pure::vX_X_X::invocation::execution::testDataGeneration::alloyGenerateTestDataWithSeedSemiInteractive(f:FunctionDefinition<Any>[1], m:Mapping[1], pureRuntime:Runtime[1], context:ExecutionContext[0..1], tableRowIdentifiers: meta::relational::testDataGeneration::TableRowIdentifiers[*],  hashStrings: Boolean[0..1], baseVersion:String[1], host:String[1], port:Integer[1], version:String[1], extensions:meta::pure::router::extension::RouterExtension[*]):String[1]
{
   alloyGenerateTestDataWithSeed($f, $m, $pureRuntime, $context, $tableRowIdentifiers, $hashStrings, $baseVersion, $host, $port, $version, ExecutionMode.SEMI_INTERACTIVE->toString(), $extensions)
}

function meta::protocols::pure::vX_X_X::invocation::execution::testDataGeneration::alloyGenerateTestDataWithSeed(f:FunctionDefinition<Any>[1], m:Mapping[1], pureRuntime:Runtime[1], context:ExecutionContext[0..1], tableRowIdentifiers: meta::relational::testDataGeneration::TableRowIdentifiers[*], hashStrings: Boolean[0..1], baseVersion:String[1], host:String[1], port:Integer[1], version:String[1], executionMode:String[1], extensions:meta::pure::router::extension::RouterExtension[*]):String[1]
{
   let transformedContext = if($context->isNotEmpty(), | $context->toOne()->transformContext($extensions),| []);
   let execMode = ExecutionMode->extractEnumValue($executionMode);

   let toOrigin = {m:Mapping[1], p:meta::protocols::Protocol[1] | buildPureModelContextPointer(^meta::protocols::pure::vX_X_X::metamodel::PackageableElementPointer(type=meta::protocols::pure::vX_X_X::metamodel::PackageableElementType.MAPPING, path=$m->elementToPath()), $baseVersion, $p)};

   let resultJSON = ^meta::protocols::pure::vX_X_X::invocation::execution::testDataGeneration::TestDataGenerationWithSeedInput
   (
      clientVersion = 'vX_X_X',
      function = transformLambda($f, $extensions),
      mapping = $m->elementToPath(),
      runtime = transformRuntime($pureRuntime, $extensions),
      context = $transformedContext,
      model = if($execMode == ExecutionMode.SEMI_INTERACTIVE,
                  |let stores =  $pureRuntime.connections.element->cast(@meta::pure::store::Store)
                                    ->map(s|$s->findAllStoreIncludes())
                                    ->removeDuplicates()
                                    ->map(c|^meta::protocols::pure::vX_X_X::metamodel::PackageableElementPointer(type=meta::protocols::pure::vX_X_X::metamodel::PackageableElementType.STORE,path=$c->elementToPath()));
                   let mapping = ^meta::protocols::pure::vX_X_X::metamodel::PackageableElementPointer(type=meta::protocols::pure::vX_X_X::metamodel::PackageableElementType.MAPPING,path=$m->elementToPath());
                   ^meta::protocols::pure::vX_X_X::metamodel::PureModelContextPointer
                   (
                      _type='pointer',
                      serializer = ^meta::protocols::Protocol
                                   (
                                      name='pure',
                                      version = 'vX_X_X'
                                   ),
                      sdlcInfo = ^meta::protocols::pure::vX_X_X::metamodel::PureSDLC
                                 (
                                    _type = 'pure',
                                    baseVersion = $baseVersion,
                                    version = 'none',
                                    packageableElementPointers = $stores->concatenate($mapping)
                                 )
                   );,
                  |$m->buildBasePureModelFromMapping($toOrigin, $extensions).second
               ),
      tableRowIdentifiers = $tableRowIdentifiers->map(x | $x->meta::protocols::pure::vX_X_X::transformation::fromPureGraph::testDataGeneration::transformTableRowIdentifiers()),
      hashStrings = $hashStrings
   )->alloyToJSON();

   let resp = executeHTTPRaw(^URL(host = $host , port=$port, path = '/api/pure/'+$version+'/execution/testDataGeneration/generateTestData_WithSeed'),
                                 HTTPMethod.POST,
                                 'application/json',
                                 $resultJSON
         );
   assertEq(200, $resp.statusCode, | $resp.statusCode->toString()+' \''+$resp.entity+'\'');
   $resp.entity;
}

function meta::protocols::pure::vX_X_X::invocation::execution::testDataGeneration::alloyGenerateTestDataWithDefaultSeedInteractive(f:FunctionDefinition<Any>[1], m:Mapping[1], pureRuntime:Runtime[1], context:ExecutionContext[0..1], hashStrings: Boolean[0..1], parameters: Any[*], host:String[1], port:Integer[1], version:String[1], extensions:meta::pure::router::extension::RouterExtension[*]):String[1]
{
   alloyGenerateTestDataWithDefaultSeed($f, $m, $pureRuntime, $context, $hashStrings, $parameters, '-1', $host, $port, $version, ExecutionMode.INTERACTIVE->toString(), $extensions)
}

function meta::protocols::pure::vX_X_X::invocation::execution::testDataGeneration::alloyGenerateTestDataWithDefaultSeedSemiInteractive(f:FunctionDefinition<Any>[1], m:Mapping[1], pureRuntime:Runtime[1], context:ExecutionContext[0..1], hashStrings: Boolean[0..1], parameters: Any[*], host:String[1], port:Integer[1], version:String[1], extensions:meta::pure::router::extension::RouterExtension[*]):String[1]
{
   alloyGenerateTestDataWithDefaultSeed($f, $m, $pureRuntime, $context, $hashStrings, $parameters, '-1', $host, $port, $version, ExecutionMode.SEMI_INTERACTIVE->toString(), $extensions)
}

function meta::protocols::pure::vX_X_X::invocation::execution::testDataGeneration::alloyGenerateTestDataWithDefaultSeedInteractive(f:FunctionDefinition<Any>[1], m:Mapping[1], pureRuntime:Runtime[1], context:ExecutionContext[0..1], hashStrings: Boolean[0..1], parameters: Any[*], baseVersion:String[1], host:String[1], port:Integer[1], version:String[1], extensions:meta::pure::router::extension::RouterExtension[*]):String[1]
{
   alloyGenerateTestDataWithDefaultSeed($f, $m, $pureRuntime, $context, $hashStrings, $parameters, $baseVersion, $host, $port, $version, ExecutionMode.INTERACTIVE->toString(), $extensions)
}

function meta::protocols::pure::vX_X_X::invocation::execution::testDataGeneration::alloyGenerateTestDataWithDefaultSeedSemiInteractive(f:FunctionDefinition<Any>[1], m:Mapping[1], pureRuntime:Runtime[1], context:ExecutionContext[0..1], hashStrings: Boolean[0..1], parameters: Any[*], baseVersion:String[1], host:String[1], port:Integer[1], version:String[1], extensions:meta::pure::router::extension::RouterExtension[*]):String[1]
{
   alloyGenerateTestDataWithDefaultSeed($f, $m, $pureRuntime, $context, $hashStrings, $parameters, $baseVersion, $host, $port, $version, ExecutionMode.SEMI_INTERACTIVE->toString(), $extensions)
}

function meta::protocols::pure::vX_X_X::invocation::execution::testDataGeneration::alloyGenerateTestDataWithDefaultSeed(f:FunctionDefinition<Any>[1], m:Mapping[1], pureRuntime:Runtime[1], context:ExecutionContext[0..1], hashStrings: Boolean[0..1], parameters: Any[*], baseVersion:String[1], host:String[1], port:Integer[1], version:String[1], executionMode:String[1], extensions:meta::pure::router::extension::RouterExtension[*]):String[1]
{
   let transformedContext = if($context->isNotEmpty(), | $context->toOne()->transformContext($extensions),| []);
   let execMode = ExecutionMode->extractEnumValue($executionMode);

   let toOrigin = {m:Mapping[1], p:meta::protocols::Protocol[1] | buildPureModelContextPointer(^meta::protocols::pure::vX_X_X::metamodel::PackageableElementPointer(type=meta::protocols::pure::vX_X_X::metamodel::PackageableElementType.MAPPING, path=$m->elementToPath()), $baseVersion, $p)};

   let resultJSON = ^meta::protocols::pure::vX_X_X::invocation::execution::testDataGeneration::TestDataGenerationWithDefaultSeedInput
   (
      clientVersion = 'vX_X_X',
      function = transformLambda($f, $extensions),
      mapping = $m->elementToPath(),
      runtime = transformRuntime($pureRuntime, $extensions),
      context = $transformedContext,
      model = if($execMode == ExecutionMode.SEMI_INTERACTIVE,
                  |let stores =  $pureRuntime.connections.element->map(element |
                     $element->match([
                        store:meta::pure::store::Store[1] | $store->map(s|$s->findAllStoreIncludes())
                                    ->removeDuplicates()
                                    ->map(c|^meta::protocols::pure::vX_X_X::metamodel::PackageableElementPointer(type=meta::protocols::pure::vX_X_X::metamodel::PackageableElementType.STORE,path=$c->elementToPath()));,
                        a:Any[*] | []
                     ]);
                   );
                   let mapping = ^meta::protocols::pure::vX_X_X::metamodel::PackageableElementPointer(type=meta::protocols::pure::vX_X_X::metamodel::PackageableElementType.MAPPING,path=$m->elementToPath());
                   ^meta::protocols::pure::vX_X_X::metamodel::PureModelContextPointer
                   (
                      _type='pointer',
                      serializer = ^meta::protocols::Protocol
                                   (
                                      name='pure',
                                      version = 'vX_X_X'
                                   ),
                      sdlcInfo = ^meta::protocols::pure::vX_X_X::metamodel::PureSDLC
                                 (
                                    _type = 'pure',
                                    baseVersion = $baseVersion,
                                    version = 'none',
                                    packageableElementPointers = $stores->concatenate($mapping)
                                 )
                   );,
                  |$m->buildBasePureModelFromMapping($toOrigin, $extensions).second
               ),
      parameters = $parameters,
      hashStrings = $hashStrings
   )->alloyToJSON();

   let resp = executeHTTPRaw(^URL(host = $host , port=$port, path = '/api/pure/'+$version+'/execution/testDataGeneration/generateTestData_WithDefaultSeed'),
                                 HTTPMethod.POST,
                                 'application/json',
                                 $resultJSON
         );
   assertEq(200, $resp.statusCode, | $resp.statusCode->toString()+' \''+$resp.entity+'\'');
   $resp.entity;
}

function meta::protocols::pure::vX_X_X::transformation::fromPureGraph::testDataGeneration::transformTableRowIdentifiers(t: meta::relational::testDataGeneration::TableRowIdentifiers[1]):meta::protocols::pure::vX_X_X::metamodel::testDataGeneration::TableRowIdentfiiers[1]
{
   ^meta::protocols::pure::vX_X_X::metamodel::testDataGeneration::TableRowIdentfiiers
   (
      table = ^meta::protocols::pure::vX_X_X::metamodel::store::relational::element::TablePtr
               (
                  _type = 'table',
                  table = $t.table.name,
                  schema = $t.table.schema.name,
                  database = $t.table.schema.database ->elementToPath(),
                  mainTableDb = $t.table.schema.database ->elementToPath()
               ),
      rowIdentifiers = $t.rowIdentifiers->map({ri |
         ^meta::protocols::pure::vX_X_X::metamodel::testDataGeneration::RowIdentifier
          (
             columnValuePairs = $ri.columnValuePairs->map(x | ^meta::protocols::pure::vX_X_X::metamodel::testDataGeneration::ColumnValuePair(name = $x.first, value = $x.second))
          )
      })
   )
}

###Pure
import meta::pure::router::extension::*;
import meta::protocols::pure::vX_X_X::transformation::fromPureGraph::mapping::flatData::*;
import meta::protocols::pure::vX_X_X::transformation::fromPureGraph::*;
import meta::protocols::pure::vX_X_X::transformation::fromPureGraph::store::flatData::*;
import meta::protocols::pure::vX_X_X::transformation::fromPureGraph::mapping::modelToModel::*;
import meta::protocols::pure::vX_X_X::transformation::fromPureGraph::store::*;
import meta::protocols::pure::vX_X_X::transformation::fromPureGraph::modelToModel::*;
import meta::pure::mapping::modelToModel::*;
import meta::protocols::pure::vX_X_X::transformation::fromPureGraph::domain::*;
import meta::protocols::pure::vX_X_X::transformation::fromPureGraph::store::csv::*;
import meta::pure::mapping::*;
import meta::relational::mapping::*;
import meta::protocols::pure::vX_X_X::metamodel::store::relational::mapping::*;
import meta::relational::metamodel::datatype::*;
import meta::relational::functions::pureToSqlQuery::*;
import meta::relational::metamodel::operation::*;
import meta::relational::metamodel::relation::*;
import meta::protocols::pure::vX_X_X::transformation::fromPureGraph::mapping::csv::*;
import meta::protocols::pure::vX_X_X::transformation::fromPureGraph::store::relational::*;
import meta::relational::metamodel::*;


function meta::protocols::pure::vX_X_X::transformation::fromPureGraph::store::relational::transformDatabase(db:meta::relational::metamodel::Database[1], extensions:meta::pure::router::extension::RouterExtension[*]):meta::protocols::pure::vX_X_X::metamodel::store::relational::Database[1]
{
   ^meta::protocols::pure::vX_X_X::metamodel::store::relational::Database
   (
      _type = 'relational',
      name = $db.name->toOne(),
      package = if($db.package->isEmpty(), |[], |$db.package->toOne()->elementToPath()),
      schemas = $db.schemas->map(s|$s->transformSchema($db, $extensions)),
      joins = $db.joins->map(s|$s->transformJoin($db)),
      filters = $db.filters->map(s|$s->transformFilter($db)),
      includedStores = $db.includes->map(i|$i->elementToPath())
   )
}


function meta::protocols::pure::vX_X_X::transformation::fromPureGraph::store::relational::transformRootRelationalInstanceSetImplementation(r:RootRelationalInstanceSetImplementation[1], mapping:Mapping[1], extensions:meta::pure::router::extension::RouterExtension[*]):meta::protocols::pure::vX_X_X::metamodel::store::relational::mapping::RootRelationalClassMapping[1]
{
   let table = $r.mainTableAlias.relationalElement->cast(@NamedRelation);
   let schema = $table->match([t:Table[1]|$t.schema,v:View[1]|$v.schema]);
   let db = $schema.database;
   let storeFromTableAlias = $r.mainTableAlias.database;
  ^meta::protocols::pure::vX_X_X::metamodel::store::relational::mapping::RootRelationalClassMapping
   (
      id = $r.id,
      _type = 'relational',
      class = $r.class->elementToPath(),
      root = $r.root,
      extendsClassMappingId = $r.superSetImplementationId,
      mappingClass = $r.mappingClass->map(mc|$mc->transformMappingClass($mapping, $extensions)),
      mainTable = ^meta::protocols::pure::vX_X_X::metamodel::store::relational::element::TablePtr(
         _type = 'table',
         table = $table.name,
         mainTableDb = if($storeFromTableAlias->isNotEmpty(),|if($db->elementToPath() == $storeFromTableAlias->toOne()->elementToPath(),| $db ,| $storeFromTableAlias->toOne()), | $db)->elementToPath(),
         database = $db->elementToPath(),
         schema = $schema.name),
      distinct = $r.distinct->isTrue(),
      groupBy = $r.groupBy.columns->map(c|$c->meta::protocols::pure::vX_X_X::transformation::fromPureGraph::store::relational::transformRelationalOperationElement($db)),
      filter = if($r.filter->isEmpty(), |[], | ^FilterWithJoins(filter = ^FilterPtr(db=$r.filter.filter.database->toOne()->elementToPath(), name=$r.filter->toOne().filterName), joins = if($r.filter->toOne().joinTreeNode->isEmpty(),|[],|$r.filter->toOne().joinTreeNode->toOne()->meta::protocols::pure::vX_X_X::transformation::fromPureGraph::store::relational::transformJoinTreeNode()))),
      primaryKey = $r.primaryKey->map(c|$c->meta::protocols::pure::vX_X_X::transformation::fromPureGraph::store::relational::transformRelationalOperationElement($db)),
      propertyMappings = $r.propertyMappings->meta::pure::milestoning::excludeRangeMilestoningPropertyMapping()->map(pm|$pm->transformRelationalPropertyMapping($db, $mapping, $extensions))
   );
}


function meta::protocols::pure::vX_X_X::transformation::fromPureGraph::store::relational::transformAggregationAwareSetImplementation(a:	meta::pure::mapping::aggregationAware::AggregationAwareSetImplementation[1], mapping:Mapping[1], extensions:meta::pure::router::extension::RouterExtension[*]):meta::protocols::pure::vX_X_X::metamodel::mapping::AggregationAwareClassMapping[1]
{
   ^meta::protocols::pure::vX_X_X::metamodel::mapping::AggregationAwareClassMapping
   (
      id = $a.id,
      _type = 'aggregationAware',
      class = $a.class->elementToPath(),
      root = $a.root,
      mainSetImplementation = $a.mainSetImplementation->meta::protocols::pure::vX_X_X::transformation::fromPureGraph::mapping::transformSetImplementation($mapping, $extensions),
      propertyMappings = $a.propertyMappings->map(pm|$pm->transformPropertyMapping($mapping, $extensions)),
       aggregateSetImplementations = $a.aggregateSetImplementations->map(s| $s->transformAggSetImplContainer($mapping, $extensions)),
      mappingClass = $a.mappingClass->map(mc|$mc->transformMappingClass($mapping, $extensions))

   );
}

function meta::protocols::pure::vX_X_X::transformation::fromPureGraph::store::relational::transformAggSetImplContainer(a:	meta::pure::mapping::aggregationAware::AggregateSetImplementationContainer[1], mapping:Mapping[1], extensions:meta::pure::router::extension::RouterExtension[*]): meta::protocols::pure::vX_X_X::metamodel::mapping::AggregateSetImplementationContainer[1]
{
   ^meta::protocols::pure::vX_X_X::metamodel::mapping::AggregateSetImplementationContainer
   (
      index = $a.index,
      setImplementation = $a.setImplementation->meta::protocols::pure::vX_X_X::transformation::fromPureGraph::mapping::transformSetImplementation($mapping, $extensions),
      aggregateSpecification = $a.aggregateSpecification->transformAggregateSpecification($extensions)
   )
}

function meta::protocols::pure::vX_X_X::transformation::fromPureGraph::store::relational::transformAggregateSpecification(a:	meta::pure::mapping::aggregationAware::AggregateSpecification[1], extensions:meta::pure::router::extension::RouterExtension[*]): meta::protocols::pure::vX_X_X::metamodel::mapping::AggregateSpecification[1]
{
   ^meta::protocols::pure::vX_X_X::metamodel::mapping::AggregateSpecification
   (
      canAggregate = $a.canAggregate,
      groupByFunctions = $a.groupByFunctions->transformGroupByFunctionSpec($extensions),
      aggregateValues = $a.aggregateValues->transformAggregationFunctionSpecification($extensions)
   )
}

function meta::protocols::pure::vX_X_X::transformation::fromPureGraph::store::relational::transformGroupByFunctionSpec(gb:meta::pure::mapping::aggregationAware::GroupByFunctionSpecification[*], extensions:meta::pure::router::extension::RouterExtension[*]): meta::protocols::pure::vX_X_X::metamodel::mapping::GroupByFunctions[*]
{
  $gb->map(g| ^meta::protocols::pure::vX_X_X::metamodel::mapping::GroupByFunctions(groupByFn = $g.groupByFn->meta::protocols::pure::vX_X_X::transformation::fromPureGraph::transformLambda($extensions)))
}

function meta::protocols::pure::vX_X_X::transformation::fromPureGraph::store::relational::transformAggregationFunctionSpecification(ag:meta::pure::mapping::aggregationAware::AggregationFunctionSpecification[*], extensions:meta::pure::router::extension::RouterExtension[*]): meta::protocols::pure::vX_X_X::metamodel::mapping::AggregateFunctions[*]
{
   $ag->map(a|^meta::protocols::pure::vX_X_X::metamodel::mapping::AggregateFunctions(mapFn = $a.mapFn->meta::protocols::pure::vX_X_X::transformation::fromPureGraph::transformLambda($extensions), aggregateFn = $a.aggregateFn->meta::protocols::pure::vX_X_X::transformation::fromPureGraph::transformLambda($extensions)))
}

function meta::protocols::pure::vX_X_X::transformation::fromPureGraph::store::relational::transformRelationalAssociationImplementation(r:RelationalAssociationImplementation[1], mapping:Mapping[1], extensions:meta::pure::router::extension::RouterExtension[*]):meta::protocols::pure::vX_X_X::metamodel::store::relational::mapping::RelationalAssociationMapping[1]
{
   let db = $r.stores->at(0)->cast(@meta::relational::metamodel::Database);
   ^meta::protocols::pure::vX_X_X::metamodel::store::relational::mapping::RelationalAssociationMapping
   (
      id = $r.id,
      _type = 'relational',
      stores = $db->elementToPath(),
      association = $r.association->elementToPath(),
      propertyMappings = $r.allPropertyMappings()->meta::pure::milestoning::excludeRangeMilestoningPropertyMapping()->map(pm|$pm->transformRelationalPropertyMapping($db, $mapping, $extensions))
   );

}


function <<access.private>> meta::protocols::pure::vX_X_X::transformation::fromPureGraph::store::relational::transformEmbeddedRelationalInstanceSetImplementation(r:EmbeddedRelationalInstanceSetImplementation[1], db: meta::relational::metamodel::Database[1], extensions:meta::pure::router::extension::RouterExtension[*]):meta::protocols::pure::vX_X_X::metamodel::store::relational::mapping::RelationalClassMapping[1]
{
   let mapping = $r.parent;
   ^meta::protocols::pure::vX_X_X::metamodel::store::relational::mapping::RelationalClassMapping
   (
      id = $r.id,
      _type = 'embedded',
      class = $r.class->elementToPath(),
      root = false,
      primaryKey = $r.primaryKey->map(c|$c->meta::protocols::pure::vX_X_X::transformation::fromPureGraph::store::relational::transformRelationalOperationElement($db->toOne())),
      propertyMappings = $r.allPropertyMappings()->meta::pure::milestoning::excludeRangeMilestoningPropertyMapping()->map(pm|$pm->transformRelationalPropertyMapping($db->toOne(), $mapping, $extensions))
   );
}

function <<access.private>> meta::protocols::pure::vX_X_X::transformation::fromPureGraph::store::relational::transformRelationalPropertyMapping(pm:PropertyMapping[1], topDatabase:meta::relational::metamodel::Database[1], mapping : Mapping[1], extensions:meta::pure::router::extension::RouterExtension[*]):meta::protocols::pure::vX_X_X::metamodel::mapping::PropertyMapping[1]
{
   $pm->match([
      r:meta::relational::mapping::RelationalPropertyMapping[1]|
         ^meta::protocols::pure::vX_X_X::metamodel::store::relational::mapping::RelationalPropertyMapping
         (
            _type = 'relationalPropertyMapping',
            property = ^meta::protocols::pure::vX_X_X::metamodel::domain::PropertyPtr(class=$pm.property->genericType().typeArguments->at(0).rawType->toOne()->elementToPath(), property=$pm.property.name->toOne()),
            enumMappingId = $r.transformer->cast(@EnumerationMapping<Any>).name,
            source = if($pm.property.owner->instanceOf(Association),|$pm.sourceSetImplementationId,|[]),
            target = $pm.targetSetImplementationId,
            relationalOperation = $r.relationalOperationElement->meta::protocols::pure::vX_X_X::transformation::fromPureGraph::store::relational::transformRelationalOperationElement($topDatabase),
            localMappingProperty = if ($pm.localMappingProperty->isNotEmpty() && $pm.localMappingProperty->toOne(),
                                       |^meta::protocols::pure::vX_X_X::metamodel::mapping::LocalMappingPropertyInfo
                                        (
                                           type = $r.localMappingPropertyType->toOne()->elementToPath(),
                                           multiplicity = $r.localMappingPropertyMultiplicity->toOne()->meta::protocols::pure::vX_X_X::transformation::fromPureGraph::domain::transformMultiplicity()
                                        ),
                                       |[]
                                   )
         ),
      i:InlineEmbeddedSetImplementation[1]|
         ^meta::protocols::pure::vX_X_X::metamodel::mapping::InlineEmbeddedPropertyMapping
         (
            _type = 'inlineEmbeddedPropertyMapping',
            id = $i.id,
            property = ^meta::protocols::pure::vX_X_X::metamodel::domain::PropertyPtr(class=$pm.property->genericType().typeArguments->at(0).rawType->toOne()->elementToPath(), property=$pm.property.name->toOne()),
            target = $i.id,
            setImplementationId = $i.inlineSetImplementationId
         ),
      o:OtherwiseEmbeddedRelationalInstanceSetImplementation[1]|
         ^meta::protocols::pure::vX_X_X::metamodel::store::relational::mapping::OtherwiseEmbeddedRelationalPropertyMapping
         (
            _type = 'otherwiseEmbeddedPropertyMapping',
            id = $o.id,
            property = ^meta::protocols::pure::vX_X_X::metamodel::domain::PropertyPtr(class=$pm.property->genericType().typeArguments->at(0).rawType->toOne()->elementToPath(), property=$pm.property.name->toOne()),
            target = $o.id,
            classMapping = $o->transformEmbeddedRelationalInstanceSetImplementation($topDatabase, $extensions)->cast(@RelationalClassMapping),
            otherwisePropertyMapping = $o.otherwisePropertyMapping->transformRelationalPropertyMapping($topDatabase, $mapping, $extensions)->cast(@meta::protocols::pure::vX_X_X::metamodel::store::relational::mapping::RelationalPropertyMapping)
         ),
      e:EmbeddedRelationalInstanceSetImplementation[1]|
         ^meta::protocols::pure::vX_X_X::metamodel::store::relational::mapping::EmbeddedRelationalPropertyMapping
         (
            _type = 'embeddedPropertyMapping',
            id = $e.id,
            property = ^meta::protocols::pure::vX_X_X::metamodel::domain::PropertyPtr(class=$pm.property->genericType().typeArguments->at(0).rawType->toOne()->elementToPath(), property=$pm.property.name->toOne()),
            target = $e.id,
            classMapping = $e->transformEmbeddedRelationalInstanceSetImplementation($topDatabase, $extensions)->cast(@RelationalClassMapping)
         ),
      x:meta::pure::mapping::xStore::XStorePropertyMapping[1] |
         $x->meta::protocols::pure::vX_X_X::transformation::fromPureGraph::mapping::xStore::transformXStorePropertyMapping($mapping, $extensions)
   ]);
}

function meta::protocols::pure::vX_X_X::transformation::fromPureGraph::store::relational::transformSchema(schema:meta::relational::metamodel::Schema[1], topDatabase: meta::relational::metamodel::Database[1], extensions:meta::pure::router::extension::RouterExtension[*]):meta::protocols::pure::vX_X_X::metamodel::store::relational::Schema[1]
{
   ^meta::protocols::pure::vX_X_X::metamodel::store::relational::Schema
   (
      name = $schema.name->toOne(),
      tables = $schema.tables->map(t|$t->transformTable($extensions)),
      views = $schema.views->map(t|$t->transformView($topDatabase))
   )
}


function <<access.private>> meta::protocols::pure::vX_X_X::transformation::fromPureGraph::store::relational::transformJoin(j:meta::relational::metamodel::join::Join[1], topDatabase:meta::relational::metamodel::Database[1]):meta::protocols::pure::vX_X_X::metamodel::store::relational::Join[1]
{
   let r = ^meta::protocols::pure::vX_X_X::metamodel::store::relational::Join
   (
      name = $j.name,
      operation = $j.operation->transformRelationalOperationElement($topDatabase)
   );
   if ($j.target->isEmpty(),
    |$r,
    |^$r(target=$j.target.name)
   );
}

function <<access.private>> meta::protocols::pure::vX_X_X::transformation::fromPureGraph::store::relational::transformFilter(j:meta::relational::metamodel::Filter[1], topDatabase:meta::relational::metamodel::Database[1]):meta::protocols::pure::vX_X_X::metamodel::store::relational::Filter[1]
{
   ^meta::protocols::pure::vX_X_X::metamodel::store::relational::Filter
   (
      _type = $j->match([m:MultiGrainFilter[1]|'multigrain', f:Filter[1]|'filter']),
      name = $j.name,
      operation = $j.operation->transformRelationalOperationElement($topDatabase)
   )
}


function meta::protocols::pure::vX_X_X::transformation::fromPureGraph::store::relational::transformRelationalOperationElement(re:meta::relational::metamodel::RelationalOperationElement[1], topDatabase:meta::relational::metamodel::Database[1]):meta::protocols::pure::vX_X_X::metamodel::store::relational::element::RelationalElement[1]
{
   $re->match(
      [
         t:TableAliasColumn[1]|let table = $t.alias.relationalElement->cast(@NamedRelation);
                               let schema = $table->match([t:Table[1]|$t.schema,v:View[1]|$v.schema]);
                               ^meta::protocols::pure::vX_X_X::metamodel::store::relational::element::ColumnPtr
                               (
                                  _type = 'column',
                                  tableAlias = $t.alias.name,
                                  table = ^meta::protocols::pure::vX_X_X::metamodel::store::relational::element::TablePtr(
                                     _type = 'table',
                                     database = $schema.database->elementToPath(),
                                     mainTableDb = $schema.database->elementToPath(),
                                     schema = $schema.name,
                                     table = $table.name),
                                  column = $t.column.name
                               );,
         r:RelationalOperationElementWithJoin[1]| ^meta::protocols::pure::vX_X_X::metamodel::store::relational::element::ElementWithJoins
                                                 (
                                                    _type = 'elemtWithJoins',
                                                    joins = $r.joinTreeNode->toOne()->transformJoinTreeNode(),
                                                    relationalElement = if ($r.relationalOperationElement->isEmpty(),|[],|$r.relationalOperationElement->toOne()->transformRelationalOperationElement(if($topDatabase==$r.joinTreeNode.database->toOne(),|$topDatabase,|$r.joinTreeNode.database->toOne())))
                                                 );,
         d:DynaFunction[1]| ^meta::protocols::pure::vX_X_X::metamodel::store::relational::element::DynamicFunction
                            (
                               _type = 'dynaFunc',
                               funcName = $d.name,
                               parameters = $d.parameters->map(p|$p->transformRelationalOperationElement($topDatabase))
                            ),
         l:Literal[1]|^meta::protocols::pure::vX_X_X::metamodel::store::relational::element::Literal
                      (
                         _type = 'literal',
                         value = $l.value
                      ),
         l:LiteralList[1]|^meta::protocols::pure::vX_X_X::metamodel::store::relational::element::LiteralList
                      (
                        _type = 'literalList',
                        values = if ($l.values->isEmpty(),|[],|$l.values->map(x| ^meta::protocols::pure::vX_X_X::metamodel::store::relational::element::Literal(_type='literal', value=$x.value)))
                      ),
         e:UnaryOperation[1]| ^meta::protocols::pure::vX_X_X::metamodel::store::relational::element::DynamicFunction
                               (
                                  _type = 'dynaFunc',
                                  funcName = $e->genericType().rawType.name->toOne(),
                                  parameters = $e.nested->meta::protocols::pure::vX_X_X::transformation::fromPureGraph::store::relational::transformRelationalOperationElement($topDatabase)
                               ),
         e:BinaryOperation[1]| ^meta::protocols::pure::vX_X_X::metamodel::store::relational::element::DynamicFunction
                               (
                                  _type = 'dynaFunc',
                                  funcName = $e->genericType().rawType.name->toOne(),
                                  parameters = $e.left->concatenate($e.right)->map(p|$p->meta::protocols::pure::vX_X_X::transformation::fromPureGraph::store::relational::transformRelationalOperationElement($topDatabase))
                               )
      ]
   );
}

function <<access.private>> meta::protocols::pure::vX_X_X::transformation::fromPureGraph::store::relational::transformJoinTreeNode(joinTreeNode: meta::relational::metamodel::join::JoinTreeNode[1]):meta::protocols::pure::vX_X_X::metamodel::store::relational::mapping::JoinPtr[*]
{
   $joinTreeNode->extractLine()->map(j|
                                     ^meta::protocols::pure::vX_X_X::metamodel::store::relational::mapping::JoinPtr(
                                              db = $j.join.database->toOne()->elementToPath(),
                                              name = $j.join.name,
                                              joinType = if($j.joinType->isEmpty(),|[],|$j.joinType->toOne()->id())
                                     )
                                  )
}

function <<access.private>> meta::protocols::pure::vX_X_X::transformation::fromPureGraph::store::relational::transformView(view:View[1], topDatabase:Database[1]):meta::protocols::pure::vX_X_X::metamodel::store::relational::View[1]
{
   let table = $view.mainTableAlias.relationalElement->cast(@NamedRelation);
   let schema = $table->match([t:Table[1]|$t.schema,v:View[1]|$v.schema]);
   ^meta::protocols::pure::vX_X_X::metamodel::store::relational::View
   (
      name = $view.name->toOne(),
      mainTable = ^meta::protocols::pure::vX_X_X::metamodel::store::relational::element::TablePtr(
          _type = 'Table',
          table = $table.name,
          database = $schema.database->elementToPath(),
         mainTableDb = $schema.database->elementToPath(),
          schema = $schema.name),
      primaryKey = $view.primaryKey->map(c|$c.name->toOne()),
      distinct = $view.distinct->toOne(),
      groupBy = $view.groupBy.columns->map(c|$c->transformRelationalOperationElement($topDatabase)),
      filter = if($view.filter->isEmpty(), |[], | ^FilterWithJoins(filter = ^FilterPtr(db=$view.filter.filter.database->toOne()->elementToPath(), name=$view.filter->toOne().filterName), joins = if ($view.filter->toOne().joinTreeNode->isEmpty(),|[],|$view.filter->toOne().joinTreeNode->toOne()->transformJoinTreeNode()))),
      columnMappings = $view.columnMappings->map(c|^meta::protocols::pure::vX_X_X::metamodel::store::relational::mapping::ColumnMapping(name=$c.columnName, operation=$c.relationalOperationElement->transformRelationalOperationElement($topDatabase)))
   );
}

function <<access.private>> meta::protocols::pure::vX_X_X::transformation::fromPureGraph::store::relational::transformTable(table:meta::relational::metamodel::relation::Table[1], extensions:meta::pure::router::extension::RouterExtension[*]):meta::protocols::pure::vX_X_X::metamodel::store::relational::Table[1]
{
   ^meta::protocols::pure::vX_X_X::metamodel::store::relational::Table
   (
      name = $table.name->toOne(),
      columns = $table.columns->map(c|$c->transformColumn()),
      primaryKey = $table.primaryKey->map(c|$c.name->toOne()),
      milestoning = $table.milestoning->map(m|$m->transformMilestoning($extensions))
   )
}

function meta::protocols::pure::vX_X_X::transformation::fromPureGraph::store::relational::transformColumn(c:meta::relational::metamodel::RelationalOperationElement[1]):meta::protocols::pure::vX_X_X::metamodel::store::relational::Column[1]
{
   $c->match([
                c:Column[1]|^meta::protocols::pure::vX_X_X::metamodel::store::relational::Column
                            (
                               name = $c.name->toOne(),
                               type = $c.type->pureDataTypeToAlloyDataType(),
                               nullable = if($c.nullable == true,|true,|false)
                            )
             ])
}

function <<access.private>> meta::protocols::pure::vX_X_X::transformation::fromPureGraph::store::relational::pureDataTypeToAlloyDataType(c:meta::relational::metamodel::datatype::DataType[1]):meta::protocols::pure::vX_X_X::metamodel::store::relational::DataType[1]
{
   $c->match(
               [
                  r:Varchar[1]|  ^meta::protocols::pure::vX_X_X::metamodel::store::relational::Varchar(_type='Varchar', size=$r.size),
                  r:Char[1]|  ^meta::protocols::pure::vX_X_X::metamodel::store::relational::Char(_type='Char', size=$r.size),
                  d:meta::relational::metamodel::datatype::Decimal[1]|  ^meta::protocols::pure::vX_X_X::metamodel::store::relational::Decimal(_type='Decimal', precision=$d.precision, scale=$d.scale),
                  r:Numeric[1]|^meta::protocols::pure::vX_X_X::metamodel::store::relational::Numeric(_type='Numeric', precision=$r.precision,scale=$r.scale),
                  r:Double[1]|^meta::protocols::pure::vX_X_X::metamodel::store::relational::Double(_type='Double'),
                  r:Bit[1]|^meta::protocols::pure::vX_X_X::metamodel::store::relational::Bit(_type='Bit' ),
                  t:BigInt[1]|^meta::protocols::pure::vX_X_X::metamodel::store::relational::BigInt(_type='BigInt'),
                  t:TinyInt[1]|^meta::protocols::pure::vX_X_X::metamodel::store::relational::TinyInt(_type='TinyInt'),
                  s:SmallInt[1]|^meta::protocols::pure::vX_X_X::metamodel::store::relational::SmallInt(_type='SmallInt'),
                  v:Varbinary[1]|^meta::protocols::pure::vX_X_X::metamodel::store::relational::Varbinary(_type='Varbinary', size=$v.size),
                  b:meta::relational::metamodel::datatype::Binary[1]|^meta::protocols::pure::vX_X_X::metamodel::store::relational::Binary(_type='Binary', size=$b.size),
                  i:meta::relational::metamodel::datatype::Integer[1]|^meta::protocols::pure::vX_X_X::metamodel::store::relational::Integer(_type='Integer'),
                  d:meta::relational::metamodel::datatype::Date[1]|^meta::protocols::pure::vX_X_X::metamodel::store::relational::Date(_type='Date'),
                  d:meta::relational::metamodel::datatype::Timestamp[1]|^meta::protocols::pure::vX_X_X::metamodel::store::relational::Timestamp(_type='Timestamp'),
                  d:meta::relational::metamodel::datatype::Float[1]|^meta::protocols::pure::vX_X_X::metamodel::store::relational::Float(_type='Float'),
                  r:meta::relational::metamodel::datatype::Real[1]|^meta::protocols::pure::vX_X_X::metamodel::store::relational::Real(_type='Real'),
                  o:meta::relational::metamodel::datatype::Other[1]|^meta::protocols::pure::vX_X_X::metamodel::store::relational::Other(_type='Other'),
                  a:meta::relational::metamodel::datatype::Array[1]|^meta::protocols::pure::vX_X_X::metamodel::store::relational::Array(_type='Array')

                ]
   )
}

function meta::protocols::pure::vX_X_X::transformation::fromPureGraph::store::relational::alloyTypeToString(c:meta::relational::metamodel::datatype::DataType[1]):String[1]
{
   $c->match(
               [
                  r:Varchar[1]|'VARCHAR('+$r.size->toString()+')',
                  r:Char[1]|'CHAR('+$r.size->toString()+')',
                  d:meta::relational::metamodel::datatype::Decimal[1]|'DECIMAL('+$d.precision->toString()+','+$d.scale->toString()+')',
                  r:Numeric[1]|'NUMERIC('+$r.precision->toString()+','+$r.scale->toString()+')',
                  r:Double[1]|'DOUBLE',
                  r:Bit[1]|'BIT',
                  t:BigInt[1]|'BIGINT',
                  t:TinyInt[1]|'TINYINT',
                  s:SmallInt[1]|'SMALLINT',
                  v:Varbinary[1]|'VARBINARY('+$v.size->toString()+')',
                  b:meta::relational::metamodel::datatype::Binary[1]|'BINARY('+$b.size->toString()+')',
                  i:meta::relational::metamodel::datatype::Integer[1]|'INTEGER',
                  d:meta::relational::metamodel::datatype::Date[1]|'DATE',
                  d:meta::relational::metamodel::datatype::Timestamp[1]|'TIMESTAMP',
                  d:meta::relational::metamodel::datatype::Float[1]|'FLOAT',
                  r:meta::relational::metamodel::datatype::Real[1]|'REAL',
                  r:meta::relational::metamodel::datatype::Other[1]|'OTHER',
                  r:meta::relational::metamodel::datatype::Array[1]|'ARRAY',
                  d:meta::relational::metamodel::datatype::DataType[1]|'' //columns mapped to functions do not yet support specific DataTypes
                ]
   );
}

function meta::protocols::pure::vX_X_X::transformation::fromPureGraph::store::relational::tableToTablePtr(table:meta::relational::metamodel::relation::Table[1]):meta::protocols::pure::vX_X_X::metamodel::store::relational::element::TablePtr[1]
{
    ^meta::protocols::pure::vX_X_X::metamodel::store::relational::element::TablePtr(
       _type = 'table',
       table = $table.name,
       schema = $table.schema.name,
       database = $table.schema.database ->elementToPath(),
       mainTableDb = $table.schema.database ->elementToPath()
    )
}

function <<access.private>> meta::protocols::pure::vX_X_X::transformation::fromPureGraph::store::relational::transformMilestoning(m:meta::relational::metamodel::relation::Milestoning[1], extensions:meta::pure::router::extension::RouterExtension[*]):meta::protocols::pure::vX_X_X::metamodel::store::relational::Milestoning[1]
{
   let open = newMap([]->cast(@Pair<String,List<Any>>));
   let transformInfinityDate = {m:TemporalMilestoning[0..1]|if($m.infinityDate->isEmpty(),|[],|$m.infinityDate->meta::protocols::pure::vX_X_X::transformation::fromPureGraph::valueSpecification::transformAny([], $open, PureOne, $extensions)->cast(@meta::protocols::pure::vX_X_X::metamodel::valueSpecification::raw::CDate))};

   $m->match($extensions.serializerExtension('vX_X_X')->cast(@meta::protocols::pure::vX_X_X::extension::SerializerExtension_vX_X_X).transfers_milestoning_transformMilestoning->concatenate([
                b:BusinessMilestoning[1]|^meta::protocols::pure::vX_X_X::metamodel::store::relational::BusinessMilestoning( _type = 'businessMilestoning', from = $b.from.name, thru = $b.thru.name, infinityDate=$transformInfinityDate->eval($b),thruIsInclusive = $b.thruIsInclusive),
                s:BusinessSnapshotMilestoning[1]| ^meta::protocols::pure::vX_X_X::metamodel::store::relational::BusinessSnapshotMilestoning( _type = 'businessSnapshotMilestoning', snapshotDate =  $s.snapshotDate.name),
                p:ProcessingMilestoning[1]|^meta::protocols::pure::vX_X_X::metamodel::store::relational::ProcessingMilestoning( _type = 'processingMilestoning', in = $p.in.name, out = $p.out.name, infinityDate=$transformInfinityDate->eval($p),outIsInclusive = $p.outIsInclusive)
             ])->toOneMany());
}

###Pure
import meta::json::*;
import meta::protocols::pure::vX_X_X::metamodel::store::relational::connection::*;
import meta::protocols::pure::vX_X_X::metamodel::domain::*;
import meta::protocols::pure::vX_X_X::metamodel::store::relational::mapping::*;
import meta::protocols::pure::vX_X_X::metamodel::runtime::*;
import meta::relational::metamodel::*;
import meta::pure::functions::meta::*;
import meta::protocols::pure::vX_X_X::transformation::fromPureGraph::store::relational::*;
import meta::protocols::pure::vX_X_X::transformation::fromPureGraph::connection::*;
import meta::protocols::pure::vX_X_X::metamodel::store::relational::connection::*;
import meta::protocols::pure::vX_X_X::metamodel::store::relational::element::*;
import meta::protocols::pure::vX_X_X::transformation::fromPureGraph::model::*;

function meta::protocols::pure::vX_X_X::transformation::fromPureGraph::connection::transformDatabaseConnection(otherConnection: meta::relational::runtime::DatabaseConnection[1], extensions:meta::pure::router::extension::RouterExtension[*]):meta::protocols::pure::vX_X_X::metamodel::store::relational::connection::DatabaseConnection[1]
{
   let _type = $otherConnection->class()->toString();
   let element = $otherConnection.element->match([d:meta::pure::store::Store[1]|$d->elementToPath(),s:String[1]|$s]);
   let type = $otherConnection.type->toString();
   let postProcessorsWithParams = if ($otherConnection->instanceOf(meta::pure::alloy::connections::RelationalDatabaseConnection), 
                                      | [],
                                      | $otherConnection.queryPostProcessorsWithParameter->transformPostProcessors($extensions));


   let alloyConnection = $otherConnection->match($extensions.serializerExtension('vX_X_X')->cast(@meta::protocols::pure::vX_X_X::extension::SerializerExtension_vX_X_X).transfers_connection_transformDatabaseConnection->map(f | $f->eval($_type, $element, $type, $postProcessorsWithParams))->concatenate([
      test:meta::relational::runtime::TestDatabaseConnection[1]|
         ^TestDatabaseConnection(
             _type = $_type,
             element = $element,
             postProcessorWithParameter = $postProcessorsWithParams,
             timeZone = $test.timeZone,
             testDataSetupCsv = $test.testDataSetupCsv,
             testDataSetupSqls = $test.testDataSetupSqls,
             type = $type),
      relational:meta::pure::alloy::connections::RelationalDatabaseConnection[1] |
         let processors = transformPostProcessors($relational.postProcessors, $extensions);
         relational($type, $element, $relational.timeZone, $processors, $relational.datasourceSpecification, $relational.authenticationStrategy, $extensions);,
      dbCon:meta::relational::runtime::DatabaseConnection[1]|
         ^meta::protocols::pure::vX_X_X::metamodel::store::relational::connection::DatabaseConnection(
                  _type = $_type,
                  timeZone = $dbCon.timeZone,
                  element = $element,
                  postProcessorWithParameter = $postProcessorsWithParams,
                  type = $type)
    ])->toOneMany());
}

function meta::protocols::pure::vX_X_X::transformation::fromPureGraph::connection::transformPostProcessors(processors:meta::pure::alloy::connections::PostProcessor[*], extensions:meta::pure::router::extension::RouterExtension[*]):meta::protocols::pure::vX_X_X::metamodel::store::relational::postProcessor::PostProcessor[*]
{
   $processors->map(processor | 
      $processor->match([
         m:meta::pure::alloy::connections::MapperPostProcessor[1] | ^meta::protocols::pure::vX_X_X::metamodel::store::relational::postProcessor::MapperPostProcessor(
            _type = 'mapper',
            mappers = transformPostProcessorMappers($m.mappers))
      ]->concatenate($extensions.serializerExtension('vX_X_X')->cast(@meta::protocols::pure::vX_X_X::extension::SerializerExtension_vX_X_X).transfers_connection_transformPostProcessors)->toOneMany())              
   );
}
   
function meta::protocols::pure::vX_X_X::transformation::fromPureGraph::connection::transformPostProcessorMappers(mappers:meta::pure::alloy::connections::Mapper[*]):meta::protocols::pure::vX_X_X::metamodel::store::relational::postProcessor::Mapper[*]
{
   $mappers->map(mapper | 
                   $mapper->match([
                      t:meta::pure::alloy::connections::TableNameMapper[1] | ^meta::protocols::pure::vX_X_X::metamodel::store::relational::postProcessor::TableNameMapper(
                         _type = 'table',
                         schema = ^meta::protocols::pure::vX_X_X::metamodel::store::relational::postProcessor::SchemaNameMapper(
                            _type = 'schema',
                            from = $t.schema.from,
                            to = $t.schema.to
                         ),
                         from = $t.from,
                         to = $t.to
                      ),
                      s:meta::pure::alloy::connections::SchemaNameMapper[1] | ^meta::protocols::pure::vX_X_X::metamodel::store::relational::postProcessor::SchemaNameMapper(
                         _type = 'schema',
                         from = $s.from,
                         to = $s.to
                      )
                   ])              
                )
}
   
function meta::protocols::pure::vX_X_X::transformation::fromPureGraph::connection::relational(type:String[1], element:String[1], timeZone:String[0..1], 
                                                                                              processors:meta::protocols::pure::vX_X_X::metamodel::store::relational::postProcessor::PostProcessor[*],
                                                                                              spec:meta::pure::alloy::connections::alloy::specification::DatasourceSpecification[1],
                                                                                              auth:meta::pure::alloy::connections::alloy::authentication::AuthenticationStrategy[1],
                                                                                              extensions:meta::pure::router::extension::RouterExtension[*]):meta::protocols::pure::vX_X_X::metamodel::store::relational::connection::RelationalDatabaseConnection[1]
{
   ^meta::protocols::pure::vX_X_X::metamodel::store::relational::connection::RelationalDatabaseConnection(
      _type = 'RelationalDatabaseConnection',
      timeZone = $timeZone,
      element = $element,
      type = $type,
      datasourceSpecification = $spec->meta::protocols::pure::vX_X_X::transformation::fromPureGraph::connection::transformDatasourceSpecification($extensions),
      authenticationStrategy = $auth->meta::protocols::pure::vX_X_X::transformation::fromPureGraph::connection::transformAuthenticationStrategy($extensions),
      postProcessors = $processors
   );
}


function meta::protocols::pure::vX_X_X::transformation::fromPureGraph::connection::transformAuthenticationStrategy(a:meta::pure::alloy::connections::alloy::authentication::AuthenticationStrategy[1], extensions:meta::pure::router::extension::RouterExtension[*]):meta::protocols::pure::vX_X_X::metamodel::store::relational::connection::alloy::authentication::AuthenticationStrategy[1]
{
   $a->match($extensions.serializerExtension('vX_X_X')->cast(@meta::protocols::pure::vX_X_X::extension::SerializerExtension_vX_X_X).transfers_connection_transformAuthenticationStrategy->concatenate([
      d:meta::pure::alloy::connections::alloy::authentication::DefaultH2AuthenticationStrategy[1] |
         ^meta::protocols::pure::vX_X_X::metamodel::store::relational::connection::alloy::authentication::DefaultH2AuthenticationStrategy(
            _type = 'h2Default'
         ),
      t:meta::pure::alloy::connections::alloy::authentication::TestDatabaseAuthenticationStrategy[1] |
         ^meta::protocols::pure::vX_X_X::metamodel::store::relational::connection::alloy::authentication::TestDatabaseAuthenticationStrategy(
            _type = 'test'
         )
   ])->toOneMany())
}

function meta::protocols::pure::vX_X_X::transformation::fromPureGraph::connection::transformDatasourceSpecification(ds: meta::pure::alloy::connections::alloy::specification::DatasourceSpecification[1], extensions:meta::pure::router::extension::RouterExtension[*]):meta::protocols::pure::vX_X_X::metamodel::store::relational::connection::alloy::specification::DatasourceSpecification[1]
{
   $ds->match($extensions.serializerExtension('vX_X_X')->cast(@meta::protocols::pure::vX_X_X::extension::SerializerExtension_vX_X_X).transfers_connection_transformDatasourceSpecification->concatenate([
      l:meta::pure::alloy::connections::alloy::specification::LocalH2DatasourceSpecification[1] |
         ^meta::protocols::pure::vX_X_X::metamodel::store::relational::connection::alloy::specification::LocalH2DatasourceSpecification(
             _type = 'h2Local',
             testDataSetupCsv = $l.testDataSetupCsv,
             testDataSetupSqls = $l.testDataSetupSqls
         )
   ])->toOneMany())
}

function meta::protocols::pure::vX_X_X::transformation::fromPureGraph::connection::transformPostProcessors(postP: meta::relational::runtime::PostProcessorWithParameter[*], extensions:meta::pure::router::extension::RouterExtension[*]): meta::protocols::pure::vX_X_X::metamodel::store::relational::PostProcessorWithParameter[*]
{
   $postP->map(postprocessor|
            ^meta::protocols::pure::vX_X_X::metamodel::store::relational::PostProcessorWithParameter(pp = $postprocessor.postProcessor->elementToPath(), parameters = $postprocessor.parameters->transformPostProcessorParameters($extensions))
               );
}


function meta::protocols::pure::vX_X_X::transformation::fromPureGraph::connection::transformPostProcessorParameters(params: meta::relational::runtime::PostProcessorParameter[*], extensions:meta::pure::router::extension::RouterExtension[*]): meta::protocols::pure::vX_X_X::metamodel::store::relational::PostProcessorParameter[*]
{
   $params->map(param|
            $param->match([
               t: meta::relational::postProcessor::TableNameMapper[1]| ^meta::protocols::pure::vX_X_X::metamodel::store::relational::TableNameMapper(_type='tableMapper',in =$t.in, out = $t.out, schemaMapperIn = $t.schemaNameMapper.in, schemaMapperOut = $t.schemaNameMapper.out),
               s: meta::relational::postProcessor::SchemaNameMapper[1]| ^meta::protocols::pure::vX_X_X::metamodel::store::relational::SchemaNameMapper(_type='schemaMapper',in =$s.in, out = $s.out )
            ]->concatenate($extensions.serializerExtension('vX_X_X')->cast(@meta::protocols::pure::vX_X_X::extension::SerializerExtension_vX_X_X).transfers_connection_transformPostProcessorParameters)->toOneMany()));
}

function meta::protocols::pure::vX_X_X::transformation::fromPureGraph::connection::transformModelChainConnection(modelChainConnection: meta::pure::mapping::modelToModel::ModelChainConnection[1]):meta::protocols::pure::vX_X_X::metamodel::mapping::modelToModel::ModelChainConnection[1]
{
   ^meta::protocols::pure::vX_X_X::metamodel::mapping::modelToModel::ModelChainConnection(element = 'ModelStore',
                                                                                          _type = 'ModelChainConnection',
                                                                                          mappings = $modelChainConnection.mappings->map(m| $m->elementToPath()))
}

###Pure

import meta::protocols::pure::vX_X_X::metamodel::*;
import meta::alloy::metadataServer::*;
import meta::protocols::pure::vX_X_X::transformation::fromPureGraph::runtime::*;
import meta::protocols::pure::vX_X_X::transformation::fromPureGraph::*;
import meta::pure::mapping::*;
import meta::protocols::pure::vX_X_X::metamodel::refiner::*;
import meta::pure::store::set::*;
import meta::relational::metamodel::*;


function meta::protocols::pure::vX_X_X::metamodel::refiner::matchAndTransformSetRelation(s:SetRelation[1]):meta::protocols::pure::vX_X_X::metamodel::store::relational::element::TablePtr[1]
{
   $s->match([
      t:meta::relational::metamodel::relation::Table[1]|
          ^meta::protocols::pure::vX_X_X::metamodel::store::relational::element::TablePtr(
                                       _type = 'Table',
                                       table = $t.name,
                                       database = $t.schema.database->elementToPath(),
                                       mainTableDb = $t.schema.database->elementToPath(),
                                       schema = $t.schema.name);,
      v:meta::relational::metamodel::relation::View[1]|
          ^meta::protocols::pure::vX_X_X::metamodel::store::relational::element::TablePtr(
                                       _type = 'View',
                                       table = $v.name,
                                       database = $v.schema.database->elementToPath(),
                                       mainTableDb = $v.schema.database->elementToPath(),
                                       schema = $v.schema.name);,
      s:SetRelation[1]| fail('not implemented');
           ^meta::protocols::pure::vX_X_X::metamodel::store::relational::element::TablePtr(_type = 'Table',table = 'table',database = 'db',mainTableDb = 'db',schema = 'schema');
   ])
}