// Copyright 2021 Goldman Sachs
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import meta::pure::mapping::modelToModel::test::createInstances::*;
import meta::relational::postProcessor::*;
import meta::pure::router::extension::*;
import meta::pure::mapping::modelToModel::test::shared::*;
import meta::pure::mapping::modelToModel::test::enumerationMapping::enumToEnum::mapping::*;
import meta::pure::mapping::modelToModel::test::enumerationMapping::enumToEnum::model::*;
import meta::pure::mapping::modelToModel::test::enumeration::*;
import meta::pure::graphFetch::execution::*;
import meta::pure::executionPlan::tests::datetime::*;
import meta::relational::tests::tds::tabletds::*;
import meta::pure::mapping::*;
import meta::relational::mapping::*;
import meta::relational::runtime::*;
import meta::relational::tests::mapping::inheritance::relational::*;
import meta::relational::metamodel::join::*;
import meta::relational::tests::tds::tdsJoin::*;
import meta::pure::executionPlan::toString::*;
import meta::pure::executionPlan::tests::*;
import meta::relational::tests::groupBy::datePeriods::mapping::*;
import meta::relational::tests::groupBy::datePeriods::*;
import meta::relational::tests::groupBy::datePeriods::domain::*;
import meta::pure::executionPlan::*;
import meta::relational::tests::*;
import meta::relational::tests::model::simple::*;
import meta::pure::runtime::*;
import meta::pure::mapping::modelToModel::test::shared::src::*;

function <<test.Test>> meta::pure::executionPlan::tests::datetime::testPlanForDateTimeConstantParameterNoTimeZone():Boolean[1]
{
   let planWithString = executionPlanForQueryWithDateTimeConstantForDatabaseConnectionTimeZone(%2019-4-8T18:00:00, []);
   let planAsString = $planWithString.second;
   let expected = 'Relational (   type = Class[impls=(meta::relational::tests::model::simple::Order | simpleRelationalMapping.meta_relational_tests_model_simple_Order)]   resultSizeRange = *   resultColumns = [("pk_0", INT), ("id", INT), ("quantity", INT), ("date", DATE), ("settlementDateTime", TIMESTAMP), ("pnl", FLOAT), ("zeroPnl", "")]   sql = select "root".ID as "pk_0", "root".ID as "id", "root".quantity as "quantity", "root".orderDate as "date", "root".settlementDateTime as "settlementDateTime", "orderpnlview_0".pnl as "pnl", case when "orderpnlview_0".pnl = 0 then \'true\' else \'false\' end as "zeroPnl" from orderTable as "root" left outer join (select distinct "root".ORDER_ID as ORDER_ID, "root".pnl as pnl, "accounttable_0".ID as accountId, "salespersontable_0".NAME as supportContact, "salespersontable_0".PERSON_ID as supportContactId from orderPnlTable as "root" left outer join orderTable as "ordertable_1" on ("root".ORDER_ID = "ordertable_1".ID) left outer join accountTable as "accounttable_0" on ("ordertable_1".accountID = "accounttable_0".ID) left outer join salesPersonTable as "salespersontable_0" on ("ordertable_1".accountID = "salespersontable_0".ACCOUNT_ID) where "root".pnl > 0) as "orderpnlview_0" on ("orderpnlview_0".ORDER_ID = "root".ID) where "root".settlementDateTime = \'2019-04-08 18:00:00\'   connection = TestDatabaseConnection(type = "H2") ) ';
   assertEquals($expected, $planAsString);
   assert($planAsString->indexOf('settlementDateTime = \'2019-04-08 18:00:00\'') != -1);
   assertSameElements(['<#function renderCollection collection separator><#return collection?join(separator)></#function>', '<#function collectionSize collection> <#return collection?size?c> </#function>'],$planWithString.first.processingTemplateFunctions);
}

function <<test.Test>> meta::pure::executionPlan::tests::datetime::testPlanForDateTimeConstantParameterGMTTimeZone():Boolean[1]
{
   let planWithString = executionPlanForQueryWithDateTimeConstantForDatabaseConnectionTimeZone(%2019-4-8T18:00:00, 'GMT');
   let planAsString = $planWithString.second;
   let expected = 'Relational (   type = Class[impls=(meta::relational::tests::model::simple::Order | simpleRelationalMapping.meta_relational_tests_model_simple_Order)]   resultSizeRange = *   resultColumns = [("pk_0", INT), ("id", INT), ("quantity", INT), ("date", DATE), ("settlementDateTime", TIMESTAMP), ("pnl", FLOAT), ("zeroPnl", "")]   sql = select "root".ID as "pk_0", "root".ID as "id", "root".quantity as "quantity", "root".orderDate as "date", "root".settlementDateTime as "settlementDateTime", "orderpnlview_0".pnl as "pnl", case when "orderpnlview_0".pnl = 0 then \'true\' else \'false\' end as "zeroPnl" from orderTable as "root" left outer join (select distinct "root".ORDER_ID as ORDER_ID, "root".pnl as pnl, "accounttable_0".ID as accountId, "salespersontable_0".NAME as supportContact, "salespersontable_0".PERSON_ID as supportContactId from orderPnlTable as "root" left outer join orderTable as "ordertable_1" on ("root".ORDER_ID = "ordertable_1".ID) left outer join accountTable as "accounttable_0" on ("ordertable_1".accountID = "accounttable_0".ID) left outer join salesPersonTable as "salespersontable_0" on ("ordertable_1".accountID = "salespersontable_0".ACCOUNT_ID) where "root".pnl > 0) as "orderpnlview_0" on ("orderpnlview_0".ORDER_ID = "root".ID) where "root".settlementDateTime = \'2019-04-08 18:00:00\'   connection = TestDatabaseConnection(type = "H2") ) ';
   assertEquals($expected, $planAsString);
   assert($planAsString->indexOf('settlementDateTime = \'2019-04-08 18:00:00\'') != -1);
   assertSameElements(['<#function renderCollection collection separator><#return collection?join(separator)></#function>', '<#function collectionSize collection> <#return collection?size?c> </#function>'],$planWithString.first.processingTemplateFunctions);
}

function <<test.Test>> meta::pure::executionPlan::tests::datetime::testPlanForDateTimeConstantParameterESTTimeZone():Boolean[1]
{
   let planWithString = executionPlanForQueryWithDateTimeConstantForDatabaseConnectionTimeZone(%2019-4-8T18:00:00, 'EST');
   let planAsString = $planWithString.second;
   let expected = 'Relational (   type = Class[impls=(meta::relational::tests::model::simple::Order | simpleRelationalMapping.meta_relational_tests_model_simple_Order)]   resultSizeRange = *   resultColumns = [("pk_0", INT), ("id", INT), ("quantity", INT), ("date", DATE), ("settlementDateTime", TIMESTAMP), ("pnl", FLOAT), ("zeroPnl", "")]   sql = select "root".ID as "pk_0", "root".ID as "id", "root".quantity as "quantity", "root".orderDate as "date", "root".settlementDateTime as "settlementDateTime", "orderpnlview_0".pnl as "pnl", case when "orderpnlview_0".pnl = 0 then \'true\' else \'false\' end as "zeroPnl" from orderTable as "root" left outer join (select distinct "root".ORDER_ID as ORDER_ID, "root".pnl as pnl, "accounttable_0".ID as accountId, "salespersontable_0".NAME as supportContact, "salespersontable_0".PERSON_ID as supportContactId from orderPnlTable as "root" left outer join orderTable as "ordertable_1" on ("root".ORDER_ID = "ordertable_1".ID) left outer join accountTable as "accounttable_0" on ("ordertable_1".accountID = "accounttable_0".ID) left outer join salesPersonTable as "salespersontable_0" on ("ordertable_1".accountID = "salespersontable_0".ACCOUNT_ID) where "root".pnl > 0) as "orderpnlview_0" on ("orderpnlview_0".ORDER_ID = "root".ID) where "root".settlementDateTime = \'2019-04-08 13:00:00\'   connection = TestDatabaseConnection(type = "H2") ) ';
   assertEquals($expected, $planAsString);
   assert($planAsString->indexOf('settlementDateTime = \'2019-04-08 13:00:00\'') != -1);
   assertSameElements(['<#function GMTtoTZ tz paramDate><#return (tz+" "+paramDate)?date.@alloyDate></#function><#function renderCollectionWithTz collection timeZone separator><#assign result = [] /><#list collection as c><#assign result +=[(timeZone+" "+c)?date.@alloyDate]></#list><#return result?join(separator)></#function>', '<#function renderCollection collection separator><#return collection?join(separator)></#function>', '<#function collectionSize collection> <#return collection?size?c> </#function>'],$planWithString.first.processingTemplateFunctions);
}

function <<test.Test>> meta::pure::executionPlan::tests::datetime::testPlanForDateTimeVariableNoTimeZone():Boolean[1]
{
   let planWithString = executionPlanForQueryWithDateTimeVariableForDatabaseConnectionTimeZone([]);
   let planAsString = $planWithString.second;
   let expected = 'Sequence (   type = Class[impls=(meta::relational::tests::model::simple::Order | simpleRelationalMapping.meta_relational_tests_model_simple_Order)]   resultSizeRange = *   (     FunctionParametersValidationNode     (       functionParameters = [dt:DateTime[1]]     )     Relational     (       type = Class[impls=(meta::relational::tests::model::simple::Order | simpleRelationalMapping.meta_relational_tests_model_simple_Order)]       resultSizeRange = *       resultColumns = [("pk_0", INT), ("id", INT), ("quantity", INT), ("date", DATE), ("settlementDateTime", TIMESTAMP), ("pnl", FLOAT), ("zeroPnl", "")]       sql = select "root".ID as "pk_0", "root".ID as "id", "root".quantity as "quantity", "root".orderDate as "date", "root".settlementDateTime as "settlementDateTime", "orderpnlview_0".pnl as "pnl", case when "orderpnlview_0".pnl = 0 then \'true\' else \'false\' end as "zeroPnl" from orderTable as "root" left outer join (select distinct "root".ORDER_ID as ORDER_ID, "root".pnl as pnl, "accounttable_0".ID as accountId, "salespersontable_0".NAME as supportContact, "salespersontable_0".PERSON_ID as supportContactId from orderPnlTable as "root" left outer join orderTable as "ordertable_1" on ("root".ORDER_ID = "ordertable_1".ID) left outer join accountTable as "accounttable_0" on ("ordertable_1".accountID = "accounttable_0".ID) left outer join salesPersonTable as "salespersontable_0" on ("ordertable_1".accountID = "salespersontable_0".ACCOUNT_ID) where "root".pnl > 0) as "orderpnlview_0" on ("orderpnlview_0".ORDER_ID = "root".ID) where "root".settlementDateTime = \'${dt}\'       connection = TestDatabaseConnection(type = "H2")     )   ) ) ';
   assertEquals($expected, $planAsString);
   assert($planAsString->indexOf('settlementDateTime = \'${dt}\'') != -1);
   assertSameElements(['<#function renderCollection collection separator><#return collection?join(separator)></#function>', '<#function collectionSize collection> <#return collection?size?c> </#function>'],$planWithString.first.processingTemplateFunctions);
}

function <<test.Test>> meta::pure::executionPlan::tests::datetime::testPlanForDateTimeVariableESTTimeZone():Boolean[1]
{
   let planWithString = executionPlanForQueryWithDateTimeVariableForDatabaseConnectionTimeZone('US/Arizona');
   let planAsString = $planWithString.second;
   let expected = 'Sequence (   type = Class[impls=(meta::relational::tests::model::simple::Order | simpleRelationalMapping.meta_relational_tests_model_simple_Order)]   resultSizeRange = *   (     FunctionParametersValidationNode     (       functionParameters = [dt:DateTime[1]]     )     Relational     (       type = Class[impls=(meta::relational::tests::model::simple::Order | simpleRelationalMapping.meta_relational_tests_model_simple_Order)]       resultSizeRange = *       resultColumns = [("pk_0", INT), ("id", INT), ("quantity", INT), ("date", DATE), ("settlementDateTime", TIMESTAMP), ("pnl", FLOAT), ("zeroPnl", "")]       sql = select "root".ID as "pk_0", "root".ID as "id", "root".quantity as "quantity", "root".orderDate as "date", "root".settlementDateTime as "settlementDateTime", "orderpnlview_0".pnl as "pnl", case when "orderpnlview_0".pnl = 0 then \'true\' else \'false\' end as "zeroPnl" from orderTable as "root" left outer join (select distinct "root".ORDER_ID as ORDER_ID, "root".pnl as pnl, "accounttable_0".ID as accountId, "salespersontable_0".NAME as supportContact, "salespersontable_0".PERSON_ID as supportContactId from orderPnlTable as "root" left outer join orderTable as "ordertable_1" on ("root".ORDER_ID = "ordertable_1".ID) left outer join accountTable as "accounttable_0" on ("ordertable_1".accountID = "accounttable_0".ID) left outer join salesPersonTable as "salespersontable_0" on ("ordertable_1".accountID = "salespersontable_0".ACCOUNT_ID) where "root".pnl > 0) as "orderpnlview_0" on ("orderpnlview_0".ORDER_ID = "root".ID) where "root".settlementDateTime = \'${GMTtoTZ( "[US/Arizona]" dt)}\'       connection = TestDatabaseConnection(type = "H2")     )   ) ) ';
   assertEquals($expected, $planAsString);
   assert($planAsString->indexOf('settlementDateTime = \'${GMTtoTZ( "[US/Arizona]" dt)}\'') != -1);
   assertSameElements(['<#function GMTtoTZ tz paramDate><#return (tz+" "+paramDate)?date.@alloyDate></#function><#function renderCollectionWithTz collection timeZone separator><#assign result = [] /><#list collection as c><#assign result +=[(timeZone+" "+c)?date.@alloyDate]></#list><#return result?join(separator)></#function>', '<#function renderCollection collection separator><#return collection?join(separator)></#function>', '<#function collectionSize collection> <#return collection?size?c> </#function>'],$planWithString.first.processingTemplateFunctions);
}

function meta::pure::executionPlan::tests::datetime::executionPlanForQueryWithDateTimeVariableForDatabaseConnectionTimeZone(timeZone:String[0..1]):Pair<ExecutionPlan, String>[1]
{
    let connectionWithTimeZone = ^TestDatabaseConnection(element = db, type=DatabaseType.H2, timeZone=$timeZone);
    let runtime = ^Runtime(connections = $connectionWithTimeZone);
    let q = {dt:DateTime[1]|Order.all()->filter(o|$o.settlementDateTime == $dt)};
    let plan = executionPlan($q, simpleRelationalMapping, $runtime, meta::pure::router::extension::defaultRelationalExtensions());
    pair($plan, $plan->planToString(meta::pure::router::extension::defaultRelationalExtensions())->replace('\n',' '));
}

function meta::pure::executionPlan::tests::datetime::executionPlanForQueryWithDateTimeConstantForDatabaseConnectionTimeZone(dt:DateTime[1], timeZone:String[0..1]):Pair<ExecutionPlan, String>[1]
{
    let connectionEST = ^TestDatabaseConnection(element = db, type=DatabaseType.H2, timeZone=$timeZone);
    let runtime = ^Runtime(connections = $connectionEST);
    let q = {|Order.all()->filter(o|$o.settlementDateTime == $dt)};
    let plan = executionPlan($q, simpleRelationalMapping, $runtime, meta::pure::router::extension::defaultRelationalExtensions());
    pair($plan, $plan->planToString(meta::pure::router::extension::defaultRelationalExtensions())->replace('\n',' '));
}

function <<test.Test>> meta::pure::executionPlan::tests::simpleExpression():Boolean[1]
{
   let result = executionPlan({|Person.all()->filter(p|$p.firstName == 'bla')}, simpleRelationalMapping, meta::relational::tests::testRuntime(), meta::pure::router::extension::defaultRelationalExtensions());
   assertEquals('Relational\n'+
                '(\n'+
                '  type = Class[impls=(meta::relational::tests::model::simple::Person | simpleRelationalMappingInc.meta_relational_tests_model_simple_Person)]\n'+
                '  resultSizeRange = *\n'+
                '  resultColumns = [("pk_0", INT), ("firstName", VARCHAR(200)), ("age", INT), ("lastName", VARCHAR(200))]\n'+
                '  sql = select "root".ID as "pk_0", "root".FIRSTNAME as "firstName", "root".AGE as "age", "root".LASTNAME as "lastName" from personTable as "root" where "root".FIRSTNAME = \'bla\'\n'+
                '  connection = TestDatabaseConnection(type = "H2")\n'+
                ')\n', $result->planToString(meta::pure::router::extension::defaultRelationalExtensions()));
}

function <<test.Test>> meta::pure::executionPlan::tests::inheritance():Boolean[1]
{
   let result = executionPlan(|meta::relational::tests::model::inheritance::RoadVehicle.all(), inheritanceMappingDB, meta::relational::tests::testRuntime(), meta::pure::router::extension::defaultRelationalExtensions());
   assertEquals('Relational\n'+
                '(\n'+
                '  type = Class[impls=(meta::relational::tests::model::inheritance::Bicycle | inheritanceMain.map2),(meta::relational::tests::model::inheritance::Car | inheritanceMain.map1)]\n'+
                '  resultSizeRange = *\n'+
                '  resultColumns = [(u_type, INT), ("pk_0_0", INT), ("pk_0_1", INT), ("id", INT), ("wheelCount", INT), ("description", INT), ("engineType", INT)]\n'+
                '  sql = select "unionBase".u_type as u_type, "unionBase"."pk_0_0" as "pk_0_0", "unionBase"."pk_0_1" as "pk_0_1", "unionBase"."id" as "id", "unionBase"."wheelCount" as "wheelCount", "unionBase"."description" as "description", "unionBase"."engineType" as "engineType" from (select \'0\' as u_type, "root".ID as "pk_0_0", null as "pk_0_1", "root".ID as "id", "root".db_bic_wheelCount as "wheelCount", "root".b_Description as "description", null as "engineType" from Bicycle as "root" UNION ALL select \'1\' as u_type, null as "pk_0_0", "root".ID as "pk_0_1", "root".ID as "id", "root".db_car_wheelCount as "wheelCount", "root".c_Description as "description", "root".engineType as "engineType" from Car as "root") as "unionBase"\n'+
                '  connection = TestDatabaseConnection(type = "H2")\n'+
                ')\n', $result->planToString(meta::pure::router::extension::defaultRelationalExtensions()));
}


function <<test.Test>> meta::pure::executionPlan::tests::simpleExpressionWithVariable():Boolean[1]
{
   let result = executionPlan({var:String[1]|Person.all()->filter(p|$p.firstName == $var)}, simpleRelationalMapping, meta::relational::tests::testRuntime(), meta::pure::router::extension::defaultRelationalExtensions());

   assertEquals('Sequence\n' +
                '(\n' +
                '  type = Class[impls=(meta::relational::tests::model::simple::Person | simpleRelationalMappingInc.meta_relational_tests_model_simple_Person)]\n' +
                '  resultSizeRange = *\n' +
                '  (\n' +
                '    FunctionParametersValidationNode\n' +
                '    (\n' +
                '      functionParameters = [var:String[1]]\n' +
                '    )\n' +
                '    Relational\n' +
                '    (\n' +
                '      type = Class[impls=(meta::relational::tests::model::simple::Person | simpleRelationalMappingInc.meta_relational_tests_model_simple_Person)]\n' +
                '      resultSizeRange = *\n' +
                '      resultColumns = [(\"pk_0\", INT), (\"firstName\", VARCHAR(200)), (\"age\", INT), (\"lastName\", VARCHAR(200))]\n' +
                '      sql = select \"root\".ID as \"pk_0\", \"root\".FIRSTNAME as \"firstName\", \"root\".AGE as \"age\", \"root\".LASTNAME as \"lastName\" from personTable as \"root\" where \"root\".FIRSTNAME = \'${var}\'\n' +
                '      connection = TestDatabaseConnection(type = \"H2\")\n' +
                '    )\n' +
                '  )\n' +
                ')\n', $result->planToString(meta::pure::router::extension::defaultRelationalExtensions()));
}

function <<test.Test>> meta::pure::executionPlan::tests::simpleExpressionWithMultipleVariables():Boolean[1]
{
   let result = executionPlan({var:String[1], age:Integer[1]|Person.all()->filter(p| ($p.firstName == $var) && ($p.age > $age))}, simpleRelationalMapping, meta::relational::tests::testRuntime(), meta::pure::router::extension::defaultRelationalExtensions());
   assertEquals('Sequence\n' +
                '(\n' +
                '  type = Class[impls=(meta::relational::tests::model::simple::Person | simpleRelationalMappingInc.meta_relational_tests_model_simple_Person)]\n' +
                '  resultSizeRange = *\n' +
                '  (\n' +
                '    FunctionParametersValidationNode\n' +
                '    (\n' +
                '      functionParameters = [var:String[1], age:Integer[1]]\n' +
                '    )\n' +
                '    Relational\n' +
                '    (\n' +
                '      type = Class[impls=(meta::relational::tests::model::simple::Person | simpleRelationalMappingInc.meta_relational_tests_model_simple_Person)]\n' +
                '      resultSizeRange = *\n' +
                '      resultColumns = [(\"pk_0\", INT), (\"firstName\", VARCHAR(200)), (\"age\", INT), (\"lastName\", VARCHAR(200))]\n' +
                '      sql = select \"root\".ID as \"pk_0\", \"root\".FIRSTNAME as \"firstName\", \"root\".AGE as \"age\", \"root\".LASTNAME as \"lastName\" from personTable as \"root\" where (\"root\".FIRSTNAME = \'${var}\' and (\"root\".AGE is not null and \"root\".AGE > ${age}))\n' +
                '      connection = TestDatabaseConnection(type = \"H2\")\n' +
                '    )\n' +
                '  )\n' +
                ')\n', $result->planToString(meta::pure::router::extension::defaultRelationalExtensions()));
}

function <<test.Test>> meta::pure::executionPlan::tests::testClassPropertyOpenVariable():Boolean[1]
{
    let result = executionPlan({|
                                 let reportEndDate = FiscalCalendarDate.all()->filter(d|$d.date == %2005-10-10)->toOne();
                                 SalesCredit.all()->filter(s|$s.tradeDate.date<$reportEndDate.date);}, myMapping, meta::relational::tests::testRuntime(), meta::pure::router::extension::defaultRelationalExtensions());

   assertEquals(
            'Sequence\n(\n' +
            '  type = Class[impls=(meta::relational::tests::groupBy::datePeriods::domain::SalesCredit | myMapping.meta_relational_tests_groupBy_datePeriods_domain_SalesCredit)]\n' +
            '  resultSizeRange = *\n'+
            '  (\n' +
            '    Allocation\n' +
            '    (\n' +
            '      type = Class[impls=(meta::relational::tests::groupBy::datePeriods::domain::FiscalCalendarDate | myMapping.meta_relational_tests_groupBy_datePeriods_domain_FiscalCalendarDate)]\n' +
            '      resultSizeRange = 1\n'+
            '      name = reportEndDate\n' +
            '      value = \n' +
            '        (\n' +
            '          Relational\n' +
            '          (\n' +
            '            type = Class[impls=(meta::relational::tests::groupBy::datePeriods::domain::FiscalCalendarDate | myMapping.meta_relational_tests_groupBy_datePeriods_domain_FiscalCalendarDate)]\n' +
            '            resultSizeRange = 1\n'+
            '            resultColumns = [("pk_0", DATE), ("pk_1", VARCHAR(15)), ("date", DATE), ("weekStart", DATE), ("weekEnd", DATE), ("day", INT), ("week", INT), ("dayOfWeekNumber", INT), ("yearEnd", DATE), ("yearStart", DATE)]\n'+
            '            sql = select \"root\".\"date\" as \"pk_0\", \"root\".\"calendar name\" as \"pk_1\", \"root\".\"date\" as \"date\", \"root\".\"fiscal week start\" as \"weekStart\", \"root\".\"fiscal week end\" as \"weekEnd\", \"root\".\"fiscal day\" as \"day\", \"root\".\"fiscal week\" as \"week\", \"root\".\"fiscal day of week\" as \"dayOfWeekNumber\", \"root\".\"fiscal year end\" as \"yearEnd\", \"root\".\"fiscal year start\" as \"yearStart\" from calendar as \"root\" where \"root\".\"date\" = \'2005-10-10\'\n' +
            '            connection = TestDatabaseConnection(type = \"H2\")\n' +
            '          )\n' +
            '        )\n' +
            '    )\n' +
            '    Relational\n' +
            '    (\n' +
            '      type = Class[impls=(meta::relational::tests::groupBy::datePeriods::domain::SalesCredit | myMapping.meta_relational_tests_groupBy_datePeriods_domain_SalesCredit)]\n' +
            '      resultSizeRange = *\n'+
            '      resultColumns = [("pk_0", INT), ("grossValue", DOUBLE)]\n'+
            '      sql = select \"root\".key as \"pk_0\", \"root\".credits as \"grossValue\" from SALES_GCS as \"root\" left outer join calendar as \"calendar_0\" on (\"root\".tradeDate = \"calendar_0\".\"date\") where \"calendar_0\".\"date\" < \'${reportEndDate[\"date\"]}\'\n' +
            '      connection = TestDatabaseConnection(type = \"H2\")\n' +
            '    )\n' +
            '  )\n' +
            ')\n', $result->planToString(meta::pure::router::extension::defaultRelationalExtensions()));
}

function <<test.Test>> meta::pure::executionPlan::tests::testGroupByWithOpenVariableInAgg():Boolean[1]
{
   let result = executionPlan({|
                                 let reportEndDate = FiscalCalendarDate.all()->filter(d|$d.date == %2005-10-10)->toOne();
                                 SalesCredit.all()
                                    ->groupBy([
                                       #/SalesCredit/salesDivision/name#
                                     ],
                                     [
                                        agg(s| ytd($s, #/SalesCredit/grossValue#, #/SalesCredit/tradeDate#, $reportEndDate), r|$r->sum())
                                     ]
                                     ,
                                     ['Sales Division', 'Income Function']);
                              }, myMapping, meta::relational::tests::testRuntime(), meta::pure::router::extension::defaultRelationalExtensions());

   assertEquals(
      'Sequence\n'+
      '(\n'+
      '  type = TDS[(Sales Division, String, VARCHAR(30), ""), (Income Function, Number, FLOAT, "")]\n'+
      '  (\n'+
      '    Allocation\n'+
      '    (\n'+
      '      type = Class[impls=(meta::relational::tests::groupBy::datePeriods::domain::FiscalCalendarDate | myMapping.meta_relational_tests_groupBy_datePeriods_domain_FiscalCalendarDate)]\n'+
      '      resultSizeRange = 1\n'+
      '      name = reportEndDate\n'+
      '      value = \n'+
      '        (\n'+
      '          Relational\n'+
      '          (\n'+
      '            type = Class[impls=(meta::relational::tests::groupBy::datePeriods::domain::FiscalCalendarDate | myMapping.meta_relational_tests_groupBy_datePeriods_domain_FiscalCalendarDate)]\n'+
      '            resultSizeRange = 1\n'+
      '            resultColumns = [("pk_0", DATE), ("pk_1", VARCHAR(15)), ("date", DATE), ("weekStart", DATE), ("weekEnd", DATE), ("day", INT), ("week", INT), ("dayOfWeekNumber", INT), ("yearEnd", DATE), ("yearStart", DATE)]\n'+
      '            sql = select "root"."date" as "pk_0", "root"."calendar name" as "pk_1", "root"."date" as "date", "root"."fiscal week start" as "weekStart", "root"."fiscal week end" as "weekEnd", "root"."fiscal day" as "day", "root"."fiscal week" as "week", "root"."fiscal day of week" as "dayOfWeekNumber", "root"."fiscal year end" as "yearEnd", "root"."fiscal year start" as "yearStart" from calendar as "root" where "root"."date" = \'2005-10-10\'\n'+
      '            connection = TestDatabaseConnection(type = "H2")\n'+
      '          )\n'+
      '        )\n'+
      '    )\n'+
      '    Relational\n'+
      '    (\n'+
      '      type = TDS[(Sales Division, String, VARCHAR(30), ""), (Income Function, Number, FLOAT, "")]\n'+
      '      resultColumns = [("Sales Division", VARCHAR(30)), ("Income Function", "")]\n'+
      '      sql = select "org_chart_entity_0".name as "Sales Division", sum(case when "calendar_0"."fiscal day" <= ${reportEndDate["day"]} then "root".credits else 0.0 end) as "Income Function" from SALES_GCS as "root" left outer join ORG_CHART_ENTITY as "org_chart_entity_0" on ("root".division_id = "org_chart_entity_0".oe_id) left outer join calendar as "calendar_0" on ("root".tradeDate = "calendar_0"."date") group by "Sales Division"\n'+
      '      connection = TestDatabaseConnection(type = "H2")\n'+
      '    )\n'+
      '  )\n'+
      ')\n',$result->planToString(meta::pure::router::extension::defaultRelationalExtensions()));}


function <<test.Test>> meta::pure::executionPlan::tests::testGroupByWithTwoOpenVariablesInAggAndFilter():Boolean[1]
{
   let result = executionPlan({|
                                 let startDate = %2015-02-25;
                                 let reportEndDate = FiscalCalendarDate.all()->filter(d|$d.date == %2005-10-10)->toOne();
                                 SalesCredit.all()
                                    ->filter(gc | $gc.tradeDate.date > $startDate && ($gc.tradeDate.date <= $reportEndDate.date))
                                    ->groupBy([
                                       #/SalesCredit/salesDivision/name#
                                     ],
                                     [
                                        agg(s| ytd($s, #/SalesCredit/grossValue#, #/SalesCredit/tradeDate#, $reportEndDate), r|$r->sum())
                                     ]
                                     ,
                                     ['Sales Division', 'Income Function']);
                              }, myMapping, meta::relational::tests::testRuntime(), meta::pure::router::extension::defaultRelationalExtensions());

   assertEquals(
      'Sequence\n'+
      '(\n'+
      '  type = TDS[(Sales Division, String, VARCHAR(30), ""), (Income Function, Number, FLOAT, "")]\n'+
      '  (\n'+
      '    Allocation\n'+
      '    (\n'+
      '      type = StrictDate\n'+
      '      resultSizeRange = 1\n'+
      '      name = startDate\n'+
      '      value = \n'+
      '        (\n'+
      '          Constant\n'+
      '          (\n'+
      '            type = StrictDate\n'+
      '            resultSizeRange = 1\n'+
      '            values=[2015-02-25]\n'+
      '          )\n'+
      '        )\n'+
      '    )\n'+
      '    Allocation\n'+
      '    (\n'+
      '      type = Class[impls=(meta::relational::tests::groupBy::datePeriods::domain::FiscalCalendarDate | myMapping.meta_relational_tests_groupBy_datePeriods_domain_FiscalCalendarDate)]\n'+
      '      resultSizeRange = 1\n'+
      '      name = reportEndDate\n'+
      '      value = \n'+
      '        (\n'+
      '          Relational\n'+
      '          (\n'+
      '            type = Class[impls=(meta::relational::tests::groupBy::datePeriods::domain::FiscalCalendarDate | myMapping.meta_relational_tests_groupBy_datePeriods_domain_FiscalCalendarDate)]\n'+
      '            resultSizeRange = 1\n'+
      '            resultColumns = [("pk_0", DATE), ("pk_1", VARCHAR(15)), ("date", DATE), ("weekStart", DATE), ("weekEnd", DATE), ("day", INT), ("week", INT), ("dayOfWeekNumber", INT), ("yearEnd", DATE), ("yearStart", DATE)]\n'+
      '            sql = select "root"."date" as "pk_0", "root"."calendar name" as "pk_1", "root"."date" as "date", "root"."fiscal week start" as "weekStart", "root"."fiscal week end" as "weekEnd", "root"."fiscal day" as "day", "root"."fiscal week" as "week", "root"."fiscal day of week" as "dayOfWeekNumber", "root"."fiscal year end" as "yearEnd", "root"."fiscal year start" as "yearStart" from calendar as "root" where "root"."date" = \'2005-10-10\'\n'+
      '            connection = TestDatabaseConnection(type = "H2")\n'+
      '          )\n'+
      '        )\n'+
      '    )\n'+
      '    Relational\n'+
      '    (\n'+
      '      type = TDS[(Sales Division, String, VARCHAR(30), ""), (Income Function, Number, FLOAT, "")]\n'+
      '      resultColumns = [("Sales Division", VARCHAR(30)), ("Income Function", "")]\n'+
      '      sql = select "org_chart_entity_0".name as "Sales Division", sum(case when "calendar_0"."fiscal day" <= ${reportEndDate["day"]} then "root".credits else 0.0 end) as "Income Function" from SALES_GCS as "root" left outer join ORG_CHART_ENTITY as "org_chart_entity_0" on ("root".division_id = "org_chart_entity_0".oe_id) left outer join calendar as "calendar_0" on ("root".tradeDate = "calendar_0"."date") where ("calendar_0"."date" > \'${startDate}\' and "calendar_0"."date" <= \'${reportEndDate["date"]}\') group by "Sales Division"\n'+
      '      connection = TestDatabaseConnection(type = "H2")\n'+
      '    )\n'+
      '  )\n'+
      ')\n',$result->planToString(meta::pure::router::extension::defaultRelationalExtensions()));
}

function <<test.Test>> meta::pure::executionPlan::tests::testMapWithOpenVariable():Boolean[1]
{
   let result = executionPlan({|let a = 10;
                                Firm.all()->map(f|$f.employees->count() + $a);}, simpleRelationalMapping, meta::relational::tests::testRuntime(), meta::pure::router::extension::defaultRelationalExtensions());

   assertEquals(
      'Sequence\n'+
      '(\n'+
      '  type = Integer\n'+
      '  resultSizeRange = *\n'+
      '  (\n'+
      '    Allocation\n'+
      '    (\n'+
      '      type = Integer\n'+
      '      resultSizeRange = 1\n'+
      '      name = a\n'+
      '      value = \n'+
      '        (\n'+
      '          Constant\n'+
      '          (\n'+
      '            type = Integer\n'+
      '            resultSizeRange = 1\n'+
      '            values=[10]\n'+
      '          )\n'+
      '        )\n'+
      '    )\n'+
      '    Relational\n'+
      '    (\n'+
      '      type = Integer\n'+
      '      resultSizeRange = *\n'+
      '      resultColumns = [(("firmtable_1".aggCol + ${a}), "")]\n'+
      '      sql = select ("firmtable_1".aggCol + ${a}) from firmTable as "root" left outer join (select "firmtable_1".ID as ID, count(*) as aggCol from firmTable as "firmtable_1" left outer join personTable as "persontable_0" on ("firmtable_1".ID = "persontable_0".FIRMID) group by "firmtable_1".ID) as "firmtable_1" on ("root".ID = "firmtable_1".ID)\n'+
      '      connection = TestDatabaseConnection(type = "H2")\n'+
      '    )\n'+
      '  )\n'+
      ')\n',$result->planToString(meta::pure::router::extension::defaultRelationalExtensions()));
}


function <<test.Test>> meta::pure::executionPlan::tests::testFilterWithOpenVariable():Boolean[1]
{
   let result = executionPlan({|let name = 'ok';
                                Firm.all()->filter(f|$f.legalName == $name);}, simpleRelationalMapping, meta::relational::tests::testRuntime(), meta::pure::router::extension::defaultRelationalExtensions());

   assertEquals(
      'Sequence\n'+
      '(\n'+
      '  type = Class[impls=(meta::relational::tests::model::simple::Firm | simpleRelationalMappingInc.meta_relational_tests_model_simple_Firm)]\n'+
      '  resultSizeRange = *\n'+
      '  (\n'+
      '    Allocation\n'+
      '    (\n'+
      '      type = String\n'+
      '      resultSizeRange = 1\n'+
      '      name = name\n'+
      '      value = \n'+
      '        (\n'+
      '          Constant\n'+
      '          (\n'+
      '            type = String\n'+
      '            resultSizeRange = 1\n'+
      '            values=[ok]\n'+
      '          )\n'+
      '        )\n'+
      '    )\n'+
      '    Relational\n'+
      '    (\n'+
      '      type = Class[impls=(meta::relational::tests::model::simple::Firm | simpleRelationalMappingInc.meta_relational_tests_model_simple_Firm)]\n'+
      '      resultSizeRange = *\n'+
      '      resultColumns = [("pk_0", INT), ("legalName", VARCHAR(200))]\n'+
      '      sql = select "root".ID as "pk_0", "root".LEGALNAME as "legalName" from firmTable as "root" where "root".LEGALNAME = \'${name}\'\n'+
      '      connection = TestDatabaseConnection(type = "H2")\n'+
      '    )\n'+
      '  )\n'+
      ')\n',$result->planToString(meta::pure::router::extension::defaultRelationalExtensions()));
}

Class meta::pure::executionPlan::tests::Struct
{
   val : Integer[1];
}

function <<test.Test>> meta::pure::executionPlan::tests::testMapWithOpenVariableOutsideBlock():Boolean[1]
{
   let a = ^Struct(val = 10);
   let result = executionPlan({|Firm.all()->map(f|$f.employees->count() + $a.val);}, simpleRelationalMapping, meta::relational::tests::testRuntime(), meta::pure::router::extension::defaultRelationalExtensions());
   assertEquals('Relational\n'+
                '(\n'+
                '  type = Integer\n'+
                '  resultSizeRange = *\n'+
                '  resultColumns = [(("firmtable_1".aggCol + 10), "")]\n'+
                '  sql = select ("firmtable_1".aggCol + 10) from firmTable as "root" left outer join (select "firmtable_1".ID as ID, count(*) as aggCol from firmTable as "firmtable_1" left outer join personTable as "persontable_0" on ("firmtable_1".ID = "persontable_0".FIRMID) group by "firmtable_1".ID) as "firmtable_1" on ("root".ID = "firmtable_1".ID)\n'+
                '  connection = TestDatabaseConnection(type = "H2")\n'+
                ')\n',$result->planToString(meta::pure::router::extension::defaultRelationalExtensions()));

}

function <<test.Test>> meta::pure::executionPlan::tests::twoRoutedExpressions():Boolean[1]
{
   let result = executionPlan({| let personName = Person.all()->filter(p|$p.firstName == 'ok')->toOne().lastName;
                                 Person.all()->filter(p|$p.firstName == $personName);
                              }
                              , simpleRelationalMapping, meta::relational::tests::testRuntime(), meta::pure::router::extension::defaultRelationalExtensions());
   assertEquals('Sequence\n'+
                '(\n'+
                '  type = Class[impls=(meta::relational::tests::model::simple::Person | simpleRelationalMappingInc.meta_relational_tests_model_simple_Person)]\n'+
                '  resultSizeRange = *\n'+
                '  (\n'+
                '    Allocation\n'+
                '    (\n'+
                '      type = String\n'+
                '      resultSizeRange = 1\n'+
                '      name = personName\n'+
                '      value = \n'+
                '        (\n'+
                '          Relational\n'+
                '          (\n'+
                '            type = String\n'+
                '            resultSizeRange = 1\n'+
                '            resultColumns = [("root".LASTNAME, VARCHAR(200))]\n'+
                '            sql = select "root".LASTNAME from personTable as "root" where "root".FIRSTNAME = \'ok\'\n'+
                '            connection = TestDatabaseConnection(type = "H2")\n'+
                '          )\n'+
                '        )\n'+
                '    )\n'+
                '    Relational\n'+
                '    (\n'+
                '      type = Class[impls=(meta::relational::tests::model::simple::Person | simpleRelationalMappingInc.meta_relational_tests_model_simple_Person)]\n'+
                '      resultSizeRange = *\n'+
                '      resultColumns = [("pk_0", INT), ("firstName", VARCHAR(200)), ("age", INT), ("lastName", VARCHAR(200))]\n'+
                '      sql = select \"root\".ID as \"pk_0\", \"root\".FIRSTNAME as \"firstName\", \"root\".AGE as \"age\", \"root\".LASTNAME as \"lastName\" from personTable as \"root\" where \"root\".FIRSTNAME = \'${personName}\'\n'+
                '      connection = TestDatabaseConnection(type = "H2")\n'+
                '    )\n'+
                '  )\n'+
                ')\n',$result->planToString(meta::pure::router::extension::defaultRelationalExtensions()));
}

function <<test.Test>> meta::pure::executionPlan::tests::twoExpressionWithConstant():Boolean[1]
{
   let result = executionPlan({|let personName = 'test';
                                Person.all()->filter(p|$p.firstName == $personName);
                              }
                              , simpleRelationalMapping, meta::relational::tests::testRuntime(), meta::pure::router::extension::defaultRelationalExtensions());
   assertEquals('Sequence\n'+
                '(\n'+
                '  type = Class[impls=(meta::relational::tests::model::simple::Person | simpleRelationalMappingInc.meta_relational_tests_model_simple_Person)]\n'+
                '  resultSizeRange = *\n'+
                '  (\n'+
                '    Allocation\n'+
                '    (\n'+
                '      type = String\n'+
                '      resultSizeRange = 1\n'+
                '      name = personName\n'+
                '      value = \n'+
                '        (\n'+
                '          Constant\n'+
                '          (\n'+
                '            type = String\n'+
                '            resultSizeRange = 1\n'+
                '            values=[test]\n'+
                '          )\n'+
                '        )\n'+
                '    )\n'+
                '    Relational\n'+
                '    (\n'+
                '      type = Class[impls=(meta::relational::tests::model::simple::Person | simpleRelationalMappingInc.meta_relational_tests_model_simple_Person)]\n'+
                '      resultSizeRange = *\n'+
                '      resultColumns = [("pk_0", INT), ("firstName", VARCHAR(200)), ("age", INT), ("lastName", VARCHAR(200))]\n'+
                '      sql = select \"root\".ID as \"pk_0\", \"root\".FIRSTNAME as \"firstName\", \"root\".AGE as \"age\", \"root\".LASTNAME as \"lastName\" from personTable as \"root\" where \"root\".FIRSTNAME = \'${personName}\'\n'+
                '      connection = TestDatabaseConnection(type = "H2")\n'+
                '    )\n'+
                '  )\n'+
                ')\n',$result->planToString(meta::pure::router::extension::defaultRelationalExtensions()));
}

function <<test.Test>> meta::pure::executionPlan::tests::tdsReturn():Boolean[1]
{
   let result = executionPlan({|Person.all()->project([col(p|$p.firstName, '"firstName"', 'doc1'), col(p|$p.lastName, 'lastName')]);}
                              , simpleRelationalMapping, meta::relational::tests::testRuntime(), meta::pure::router::extension::defaultRelationalExtensions());
   assertEquals('Relational\n'+
                '(\n'+
                '  type = TDS[("firstName", String, VARCHAR(200), "doc1"), (lastName, String, VARCHAR(200), "")]\n'+
                '  resultColumns = [("firstName", VARCHAR(200)), ("lastName", VARCHAR(200))]\n'+
                '  sql = select \"root\".FIRSTNAME as \"firstName\", \"root\".LASTNAME as \"lastName\" from personTable as \"root\"\n'+
                '  connection = TestDatabaseConnection(type = "H2")\n'+
                ')\n',$result->planToString(meta::pure::router::extension::defaultRelationalExtensions()));
}

function <<test.Test>> meta::pure::executionPlan::tests::tdsWithEnumReturn():Boolean[1]
{
   let result = executionPlan({|meta::relational::tests::mapping::enumeration::model::domain::Product.all()->project([p|$p.description, p|if($p.description == 'My Product 2',|$p.synonyms.type,|$p.synonyms.type)], ['description','type'])}, meta::relational::tests::mapping::enumeration::model::mapping::productMapping, meta::relational::tests::testRuntime(), meta::pure::router::extension::defaultRelationalExtensions());
   assertEquals('Relational\n'+
                '(\n'+
                '  type = TDS[(description, String, VARCHAR(200), ""), (type, meta::relational::tests::mapping::enumeration::model::domain::ProductSynonymType, VARCHAR(10), "", synonym)]\n'+
                '  resultColumns = [("description", VARCHAR(200)), ("type", "")]\n'+
                '  sql = select "root".prod_desc as "description", case when "root".prod_desc = \'My Product 2\' then "product_synonym_0".type else "product_synonym_0".type end as "type" from Product as "root" left outer join Product_Synonym as "product_synonym_0" on ("root".id = "product_synonym_0".product_id)\n'+
                '  connection = TestDatabaseConnection(type = "H2")\n'+
                ')\n',$result->planToString(meta::pure::router::extension::defaultRelationalExtensions()));
}

function <<test.Test>> meta::pure::executionPlan::tests::withPlatform():Boolean[1]
{
   let result = executionPlan({|Person.all()->filter(p|($p.firstName == 'John' && $p.lastName == 'Johnson') || $p.lastName == 'Allen').lastName->makeString(', ')}
                              , simpleRelationalMapping, meta::relational::tests::testRuntime(), meta::pure::router::extension::defaultRelationalExtensions());
   assertEquals('PureExp\n' +
                '(\n' +
                '  type = String\n' +
                '  expression = [Node Index:0] -> makeString(\', \')\n' +
                '  (\n' +
                '    Relational\n' +
                '    (\n' +
                '      type = String\n' +
                '      resultSizeRange = *\n'+
                '      resultColumns = [("root".LASTNAME, VARCHAR(200))]\n'+
                '      sql = select \"root\".LASTNAME from personTable as \"root\" where ((\"root\".FIRSTNAME = \'John\' and \"root\".LASTNAME = \'Johnson\') or \"root\".LASTNAME = \'Allen\')\n' +
                '      connection = TestDatabaseConnection(type = "H2")\n'+
                '    )\n' +
                '  )\n' +
                ')\n',$result->planToString(meta::pure::router::extension::defaultRelationalExtensions()));
}

function <<test.Test>> meta::pure::executionPlan::tests::testDatabaseConnectionSQLPopulationLegacy():Boolean[1]
{
   let runtime = ^Runtime(
      connections = ^TestDatabaseConnection(type = DatabaseType.H2, element = meta::relational::tests::db, testDataSetupCsv = '')
   );
   let result = executionPlan({|Person.all()->project(c | $c.firstName, 'firstName')}, simpleRelationalMapping, $runtime, meta::pure::router::extension::defaultRelationalExtensions());

   let resultConnection = $result.rootExecutionNode->cast(@RelationalInstantiationExecutionNode).executionNodes->at(0)->cast(@SQLExecutionNode).connection->cast(@TestDatabaseConnection);

   assertSize($resultConnection.testDataSetupSqls, 44);
}

function <<test.Test>> meta::pure::executionPlan::tests::testDatabaseConnectionSQLPopulation():Boolean[1]
{
   let runtime = ^Runtime(
      connections = ^meta::pure::alloy::connections::RelationalDatabaseConnection(
         type = DatabaseType.H2,
         element = meta::relational::tests::db,
         datasourceSpecification = ^meta::pure::alloy::connections::alloy::specification::LocalH2DatasourceSpecification(testDataSetupCsv = ''),
         authenticationStrategy = ^meta::pure::alloy::connections::alloy::authentication::TestDatabaseAuthenticationStrategy()
      ));

   let result = executionPlan({|Person.all()->project(c | $c.firstName, 'firstName')}, simpleRelationalMapping, $runtime, meta::pure::router::extension::defaultRelationalExtensions());

   let resultConnection = $result.rootExecutionNode->cast(@RelationalInstantiationExecutionNode).executionNodes->at(0)->cast(@SQLExecutionNode)
      .connection->cast(@meta::pure::alloy::connections::RelationalDatabaseConnection).datasourceSpecification
                 ->cast(@meta::pure::alloy::connections::alloy::specification::LocalH2DatasourceSpecification);

   assertSize($resultConnection.testDataSetupSqls, 44);
}

function <<test.Test>> meta::pure::executionPlan::tests::tdsJoinOneDBOneExpression():Boolean[1]
{
    let result = executionPlan({|
    testJoinTDS_Person.all()->meta::pure::tds::project([col(p|$p.firstName, 'firstName'), col(p|$p.employerID, 'eID')])
    ->join(testJoinTDS_Firm.all()->project([col(p|$p.firmID, 'fID'), col(p|$p.legalName, 'legalName')]), JoinType.INNER, {a,b|$a.getInteger('eID') == $b.getInteger('fID');});},testJoinTDSMapping, meta::relational::tests::testRuntime(), meta::pure::router::extension::defaultRelationalExtensions());

    assertEquals('Relational\n'+
    '(\n'+
    '  type = TDS[(firstName, String, VARCHAR(200), ""), (eID, Integer, INT, ""), (fID, Integer, INT, ""), (legalName, String, VARCHAR(200), "")]\n'+
    '  resultColumns = [("firstName", VARCHAR(200)), ("eID", INT), ("fID", INT), ("legalName", VARCHAR(200))]\n'+
    '  sql = select \"persontable_0\".\"firstName\" as \"firstName\", \"persontable_0\".\"eID\" as \"eID\", \"persontable_0\".\"fID\" as \"fID\", \"persontable_0\".\"legalName\" as \"legalName\" from (select \"persontable_1\".\"firstName\" as \"firstName\", \"persontable_1\".\"eID\" as \"eID\", \"firmtable_0\".\"fID\" as \"fID\", \"firmtable_0\".\"legalName\" as \"legalName\" from (select \"root\".FIRSTNAME as \"firstName\", \"root\".FIRMID as \"eID\" from personTable as \"root\") as \"persontable_1\" inner join (select \"root\".ID as \"fID\", \"root\".LEGALNAME as \"legalName\" from firmTable as \"root\") as \"firmtable_0\" on (\"persontable_1\".\"eID\" = \"firmtable_0\".\"fID\")) as \"persontable_0\"\n'+
    '  connection = TestDatabaseConnection(type = "H2")\n'+
    ')\n', $result->planToString(meta::pure::router::extension::defaultRelationalExtensions()));
}

function <<test.Test>> meta::pure::executionPlan::tests::tdsJoinTwoDBWithColumnMappedViaJoins():Boolean[1]
{
    let result = executionPlan({|testJoinTDS_Person.all()->meta::pure::tds::project([col(p|$p.firstName, 'firstName'), col(p|$p.employerID, 'eID'), col(p|$p.managerID, 'managerID')])
                                     ->join(testJoinTDS_Firm.all()->project([col(p|$p.firmID, 'fID'), col(p|$p.legalName, 'legalName')]), JoinType.INNER, {a,b|$a.getInteger('eID') == $b.getInteger('fID');});},
                               meta::relational::tests::tds::tdsJoin::testJoinTDSMappingTwoDatabaseWithColumnsMappedViaJoinsAndDynaFunction, meta::relational::tests::tds::tdsJoin::twoDBRunTime(), meta::pure::router::extension::defaultRelationalExtensions());
    let actualPlan = $result->planToString(meta::pure::router::extension::defaultRelationalExtensions());
    let expected =   'Sequence\n'+
                     '(\n'+
                     '  type = TDS[(firstName, String, VARCHAR(200), \"\"), (eID, Integer, INT, \"\"), (managerID, Integer, INT, \"\"), (fID, Integer, INT, \"\"), (legalName, String, VARCHAR(200), \"\")]\n'+
                     '  (\n'+
                     '    Allocation\n'+
                     '    (\n'+
                     '      type = TDS[(firstName, String, VARCHAR(200), \"\"), (eID, Integer, INT, \"\"), (managerID, Integer, INT, \"\")]\n'+
                     '      name = tdsVar0_0\n'+
                     '      value = \n'+
                     '        (\n'+
                     '          Relational\n'+
                     '          (\n'+
                     '            type = TDS[(firstName, String, VARCHAR(200), \"\"), (eID, Integer, INT, \"\"), (managerID, Integer, INT, \"\")]\n'+
                     '            resultColumns = [(\"firstName\", VARCHAR(200)), (\"eID\", INT), (\"managerID\", \"\")]\n'+
                     '            sql = select \"root\".FIRSTNAME as \"firstName\", \"firmtable_0\".ID as \"eID\", case when \"root\".MANAGERID = 0 then 0 else \"root\".MANAGERID end as \"managerID\" from personTable as \"root\" left outer join firmTable as \"firmtable_0\" on (\"firmtable_0\".ID = \"root\".FIRMID)\n'+
                     '            connection = TestDatabaseConnection(type = \"H2\")\n'+
                     '          )\n'+
                     '        )\n'+
                     '    )\n'+
                     '    Relational\n'+
                     '    (\n'+
                     '      type = TDS[(firstName, String, VARCHAR(200), \"\"), (eID, Integer, INT, \"\"), (managerID, Integer, INT, \"\"), (fID, Integer, INT, \"\"), (legalName, String, VARCHAR(200), \"\")]\n'+
                     '      resultColumns = [(\"firstName\", INT), (\"eID\", INT), (\"managerID\", INT), (\"fID\", INT), (\"legalName\", VARCHAR(200))]\n'+
                     '      sql = select \"tdsvar0_0_0\".firstName as \"firstName\", \"tdsvar0_0_0\".eID as \"eID\", \"tdsvar0_0_0\".managerID as \"managerID\", \"tdsvar0_0_0\".\"fID\" as \"fID\", \"tdsvar0_0_0\".\"legalName\" as \"legalName\" from (select * from (${tdsVar0_0}) as \"tdsvar0_0_1\" inner join (select \"root\".ID as \"fID\", \"root\".LEGALNAME as \"legalName\" from firmTable as \"root\") as \"firmtable_0\" on (\"tdsvar0_0_1\".eID = \"firmtable_0\".\"fID\")) as \"tdsvar0_0_0\"\n'+
                     '      connection = TestDatabaseConnection(type = \"H2\")\n'+
                     '    )\n'+
                     '  )\n'+
                     ')\n';
   assertEquals($expected, $actualPlan);
}

function <<test.ToFix>> meta::pure::executionPlan::tests::tdsJoinTwoDBWithFilter():Boolean[1]
{
    //TODO: Push filters down to relevant cluster
    let result = executionPlan({|
    testJoinTDS_Person.all()->meta::pure::tds::project([col(p|$p.firstName, 'firstName'), col(p|$p.employerID, 'eID')])->join(testJoinTDS_Firm.all()->project([col(p|$p.firmID, 'fID'),
    col(p|$p.legalName, 'legalName')]), JoinType.INNER, {a,b|$a.getInteger('eID') == $b.getInteger('fID');})->filter( f| $f.getString('firstName')=='Adam' &&   $f.getString('legalName')=='Firm X')

    ;}, meta::relational::tests::tds::tdsJoin::testJoinTDSMappingTwoDatabase, meta::relational::tests::tds::tdsJoin::twoDBRunTime(), meta::pure::router::extension::defaultRelationalExtensions());
    $result->planToString(meta::pure::router::extension::defaultRelationalExtensions())->println();
      true;
}

function <<test.Test>> meta::pure::executionPlan::tests::twoDBRenameColumns():Boolean[1]
{
    let result = executionPlan({|
    meta::relational::tests::tds::tdsJoin::testJoinTDS_Person.all()->meta::pure::tds::project([col(p|$p.firstName, 'firstName2'), col(p|$p.employerID, 'eID2')])
     ->join(meta::relational::tests::tds::tdsJoin::testJoinTDS_Firm.all()->project([col(p|$p.firmID, 'fID2'), col(p|$p.legalName, 'legalName2')]), JoinType.INNER, {a,b|$a.getInteger('eID2') == $b.getInteger('fID2');})

    ;}, meta::relational::tests::tds::tdsJoin::testJoinTDSMappingTwoDatabase, meta::relational::tests::tds::tdsJoin::twoDBRunTime(), meta::pure::router::extension::defaultRelationalExtensions());
   $result->planToString(meta::pure::router::extension::defaultRelationalExtensions())->println();
   true;
}

function <<test.Test>> meta::pure::executionPlan::tests::tdsJoinTwoDBExtend():Boolean[1]
{
    let result = executionPlan({|
    meta::relational::tests::tds::tdsJoin::testJoinTDS_Person.all()->meta::pure::tds::project([col(p|$p.firstName, 'firstName'), col(p|$p.employerID, 'eID')])->join(meta::relational::tests::tds::tdsJoin::testJoinTDS_Firm.all()->project([col(p|$p.firmID, 'fID'),
    col(p|$p.legalName, 'legalName')]), JoinType.INNER, {a,b|$a.getInteger('eID') == $b.getInteger('fID');})

    ;}, meta::relational::tests::tds::tdsJoin::testJoinTDSMappingTwoDatabase, meta::relational::tests::tds::tdsJoin::twoDBRunTime(), meta::pure::router::extension::defaultRelationalExtensions());
    assertEquals('Sequence\n'+
    '(\n'+
     '  type = TDS[(firstName, String, VARCHAR(200), \"\"), (eID, Integer, INT, \"\"), (fID, Integer, INT, \"\"), (legalName, String, VARCHAR(200), \"\")]\n'+
     '  (\n'+
     '    Allocation\n'+
     '    (\n'+
     '      type = TDS[(firstName, String, VARCHAR(200), \"\"), (eID, Integer, INT, \"\")]\n'+
     '      name = tdsVar0_0\n'+
     '      value = \n'+
     '        (\n'+
     '          Relational\n'+
     '          (\n'+
     '            type = TDS[(firstName, String, VARCHAR(200), \"\"), (eID, Integer, INT, \"\")]\n'+
     '            resultColumns = [("firstName", VARCHAR(200)), ("eID", INT)]\n'+
     '            sql = select \"root\".FIRSTNAME as \"firstName\", \"root\".FIRMID as \"eID\" from personTable as \"root\"\n'+
     '            connection = TestDatabaseConnection(type = \"H2\")\n'+
     '          )\n'+
     '        )\n'+
     '    )\n'+
     '    Relational\n'+
     '    (\n'+
     '      type = TDS[(firstName, String, VARCHAR(200), \"\"), (eID, Integer, INT, \"\"), (fID, Integer, INT, \"\"), (legalName, String, VARCHAR(200), \"\")]\n'+
     '      resultColumns = [("firstName", INT), ("eID", INT), ("fID", INT), ("legalName", VARCHAR(200))]\n'+
     '      sql = select \"tdsvar0_0_0\".firstName as "firstName", \"tdsvar0_0_0\".eID as "eID", \"tdsvar0_0_0\".\"fID\" as \"fID\", \"tdsvar0_0_0\".\"legalName\" as \"legalName\" from (select * from (${tdsVar0_0}) as \"tdsvar0_0_1\" inner join (select \"root\".ID as \"fID\", \"root\".LEGALNAME as \"legalName\" from firmTable as \"root\") as \"firmtable_0\" on (\"tdsvar0_0_1\".eID = \"firmtable_0\".\"fID\")) as \"tdsvar0_0_0\"\n'+
     '      connection = TestDatabaseConnection(type = \"H2\")\n'+
     '    )\n'+
     '  )\n'+
    ')\n'
    , $result->planToString(meta::pure::router::extension::defaultRelationalExtensions()));
}

function <<test.Test>> meta::pure::executionPlan::tests::tdsTwoJoinThreeDB():Boolean[1]
{
    let resultOneExpression = executionPlan({|
    testJoinTDS_Person.all()->meta::pure::tds::project([col(p|$p.firstName, 'firstName'), col(p|$p.employerID, 'eID')])
    ->join(testJoinTDS_Firm.all()->project([col(p|$p.firmID, 'fID'),col(p|$p.firmAddrID, 'firmAddrID')]), JoinType.INNER, {a,b|$a.getInteger('eID') == $b.getInteger('fID');})
    ->join(testJoinTDS_Address.all()->project([col(p|$p.addrName, 'addrName'), col(p|$p.addrID, 'addrID')]), JoinType.INNER, {a,b |$a.getInteger('firmAddrID')  == $b.getInteger('addrID');});}
    , meta::relational::tests::tds::tdsJoin::testJoinTDSMappingThreeDatabase, meta::relational::tests::testRuntime(), meta::pure::router::extension::defaultRelationalExtensions());


    let expected ='Sequence\n'+
    '(\n'+
    '  type = TDS[(firstName, String, VARCHAR(200), \"\"), (eID, Integer, INT, \"\"), (fID, Integer, INT, \"\"), (firmAddrID, Integer, INT, \"\"), (addrName, String, VARCHAR(200), \"\"), (addrID, Integer, INT, \"\")]\n'+
     '  (\n'+
     '    Allocation\n'+
     '    (\n'+
     '      type = TDS[(firstName, String, VARCHAR(200), \"\"), (eID, Integer, INT, \"\")]\n'+
     '      name = tdsVar1_0\n'+
     '      value = \n'+
     '        (\n'+
     '          Relational\n'+
     '          (\n'+
     '            type = TDS[(firstName, String, VARCHAR(200), \"\"), (eID, Integer, INT, \"\")]\n'+
     '            resultColumns = [("firstName", VARCHAR(200)), ("eID", INT)]\n'+
     '            sql = select \"root\".FIRSTNAME as \"firstName\", \"root\".FIRMID as \"eID\" from personTable as \"root\"\n'+
     '            connection = TestDatabaseConnection(type = \"H2\")\n'+
     '          )\n'+
     '        )\n'+
     '    )\n'+
     '    Allocation\n'+
     '    (\n'+
     '      type = TDS[(firstName, String, VARCHAR(200), \"\"), (eID, Integer, INT, \"\"), (fID, Integer, INT, \"\"), (firmAddrID, Integer, INT, \"\")]\n'+
     '      name = tdsVar0_0\n'+
     '      value = \n'+
     '        (\n'+
     '          Relational\n'+
     '          (\n'+
     '            type = TDS[(firstName, String, VARCHAR(200), \"\"), (eID, Integer, INT, \"\"), (fID, Integer, INT, \"\"), (firmAddrID, Integer, INT, \"\")]\n'+
     '            resultColumns = [("firstName", INT), ("eID", INT), ("fID", INT), ("firmAddrID", INT)]\n'+
     '            sql = select \"tdsvar1_0_0\".firstName as "firstName", \"tdsvar1_0_0\".eID as "eID", \"tdsvar1_0_0\".\"fID\" as \"fID\", \"tdsvar1_0_0\".\"firmAddrID\" as \"firmAddrID\" from (select * from (${tdsVar1_0}) as \"tdsvar1_0_1\" inner join (select \"root\".ID as \"fID\", \"root\".ADDRESSID as \"firmAddrID\" from firmTable as \"root\") as \"firmtable_0\" on (\"tdsvar1_0_1\".eID = \"firmtable_0\".\"fID\")) as \"tdsvar1_0_0\"\n'+
     '            connection = TestDatabaseConnection(type = \"H2\")\n'+
     '          )\n'+
     '        )\n'+
     '    )\n'+
     '    Relational\n'+
     '    (\n'+
     '      type = TDS[(firstName, String, VARCHAR(200), \"\"), (eID, Integer, INT, \"\"), (fID, Integer, INT, \"\"), (firmAddrID, Integer, INT, \"\"), (addrName, String, VARCHAR(200), \"\"), (addrID, Integer, INT, \"\")]\n'+
     '      resultColumns = [("firstName", INT), ("eID", INT), ("fID", INT), ("firmAddrID", INT), ("addrName", VARCHAR(200)), ("addrID", INT)]\n'+
     '      sql = select \"tdsvar0_0_0\".firstName as "firstName", \"tdsvar0_0_0\".eID as "eID", \"tdsvar0_0_0\".fID as "fID", \"tdsvar0_0_0\".firmAddrID as "firmAddrID", \"tdsvar0_0_0\".\"addrName\" as \"addrName\", \"tdsvar0_0_0\".\"addrID\" as \"addrID\" from (select * from (${tdsVar0_0}) as \"tdsvar0_0_1\" inner join (select \"root\".NAME as \"addrName\", \"root\".ID as \"addrID\" from addressTable as \"root\") as \"addresstable_0\" on (\"tdsvar0_0_1\".firmAddrID = \"addresstable_0\".\"addrID\")) as \"tdsvar0_0_0\"\n'+
     '      connection = TestDatabaseConnection(type = \"H2\")\n'+
    '    )\n'+
    '  )\n'+
    ')\n';

    assertEquals($expected,$resultOneExpression->planToString(meta::pure::router::extension::defaultRelationalExtensions()));
}

function <<test.Test>> meta::pure::executionPlan::tests::testTwoMappingsOneRuntime():Boolean[1]
{

  let plan =  executionPlan({|
     Person.all().firm->project([col(p|$p.legalName, 'legalName'), col(p|$p.legalName, 'legalNameSimple')])->from(alternateSimpleMapping, meta::relational::tests::testRuntime())
     ->join(Person.all().firm->project([col(p|$p.legalName, 'legalName'),col(p|$p.legalName, 'legalNameALT')])->from(alternateSimpleMapping2, meta::relational::tests::testRuntime()), JoinType.INNER, ['legalName'])},^Mapping(name = ''), ^meta::pure::runtime::Runtime(), meta::pure::router::extension::defaultRelationalExtensions());
 assertEquals('Relational\n'+
'(\n'+
'  type = TDS[(legalName, String, VARCHAR(200), ""), (legalNameSimple, String, VARCHAR(200), ""), (legalNameALT, String, VARCHAR(200), "")]\n'+
'  resultColumns = [("legalName", VARCHAR(200)), ("legalNameSimple", VARCHAR(200)), ("legalNameALT", VARCHAR(200))]\n'+
'  sql = select "persontable_0"."legalName" as "legalName", "persontable_0"."legalNameSimple" as "legalNameSimple", "persontable_0"."legalNameALT" as "legalNameALT" from (select "persontable_1"."legalName" as "legalName", "persontable_1"."legalNameSimple" as "legalNameSimple", "persontable_3"."legalNameALT" as "legalNameALT" from (select "otherfirmtable_0".LEGALNAME as "legalName", "otherfirmtable_0".LEGALNAME as "legalNameSimple" from personTable as "root" left outer join otherFirmTable as "otherfirmtable_0" on ("root".FIRMID = "otherfirmtable_0".ID)) as "persontable_1" inner join (select "firmtable_0".LEGALNAME as "legalName", "firmtable_0".LEGALNAME as "legalNameALT" from personTable as "root" left outer join firmTable as "firmtable_0" on ("firmtable_0".ID = "root".FIRMID)) as "persontable_3" on ("persontable_1"."legalName" = "persontable_3"."legalName")) as "persontable_0"\n'+
'  connection = TestDatabaseConnection(type = "H2")\n'+
')\n',$plan->planToString(meta::pure::router::extension::defaultRelationalExtensions()));
}

function <<test.Test>> meta::pure::executionPlan::tests::letVariableFunctionNow() : Boolean[1]
{
    let lambda = {| let x = now();
                     meta::relational::tests::model::simple::Person.all()
                     ->filter(p|$x>now()->adjust(-1, DurationUnit.DAYS))
                     ->project([col({p:meta::relational::tests::model::simple::Person[1]|$p.firstName}, 'firstName')]);};

   let res = meta::pure::executionPlan::executionPlan($lambda,simpleRelationalMapping, meta::relational::tests::testRuntime(), meta::pure::router::extension::defaultRelationalExtensions());

   let expected =
   'Sequence\n'+
   '(\n'+
   '  type = TDS[(firstName, String, VARCHAR(200), "")]\n'+
   '  (\n'+
   '    Allocation\n'+
   '    (\n'+
   '      type = DateTime\n'+
   '      name = x\n'+
   '      value = \n'+
   '        (\n'+
   '          PureExp\n'+
   '          (\n'+
   '            type = DateTime\n'+
   '            expression = now()\n'+
   '          )\n'+
   '        )\n'+
   '    )\n'+
   '    Relational\n'+
   '    (\n'+
   '      type = TDS[(firstName, String, VARCHAR(200), "")]\n'+
   '      resultColumns = [("firstName", VARCHAR(200))]\n' +
   '      sql = select "root".FIRSTNAME as "firstName" from personTable as "root" where \'${x}\' > dateadd(DAY, -1, current_timestamp())\n'+
   '      connection = TestDatabaseConnection(type = "H2")\n'+
   '    )\n'+
   '  )\n'+
   ')\n';

   assertEquals($expected, $res->planToString(meta::pure::router::extension::defaultRelationalExtensions()));

   let withJava = $res->generatePlatformCode(^PlatformCodeGenerationConfig(platform=Platform.JAVA), defaultRelationalExtensions());

   let expectedJava =
   'Sequence\n' +
   '(\n' +
   '  type = TDS[(firstName, String, VARCHAR(200), "")]\n' +
   '  (\n' +
   '    Allocation\n' +
   '    (\n' +
   '      type = DateTime\n' +
   '      name = x\n' +
   '      value = \n' +
   '        (\n' +
   '          PureExp\n' +
   '          (\n' +
   '            type = DateTime\n' +
   '            expression = now()\n' +
   '            implementation\n' +
   '            (\n' +
   '              calls = org.finos.legend.engine.plan.dependencies.store.platform.PredefinedExpressions.now\n' +
   '            )\n' +
   '          )\n' +
   '        )\n' +
   '    )\n' +
   '    Relational\n' +
   '    (\n' +
   '      type = TDS[(firstName, String, VARCHAR(200), "")]\n' +
   '      resultColumns = [("firstName", VARCHAR(200))]\n' +
   '      sql = select "root".FIRSTNAME as "firstName" from personTable as "root" where \'${x}\' > dateadd(DAY, -1, current_timestamp())\n' +
   '      connection = TestDatabaseConnection(type = "H2")\n' +
   '    )\n' +
   '  )\n' +
   ')\n';

   assertEquals($expectedJava, $withJava->planToString(meta::pure::router::extension::defaultRelationalExtensions()));
}

function <<test.Test>> meta::pure::executionPlan::tests::letVariableFunctionAdjustNow() : Boolean[1]
{
   let lambda = {| let x = adjust(now(),1,DurationUnit.DAYS);
                     meta::relational::tests::model::simple::Person.all()
                     ->filter(p|$x>now()->adjust(-1, DurationUnit.DAYS))
                     ->project([col({p:meta::relational::tests::model::simple::Person[1]|$p.firstName}, 'firstName')]);};
   let res = meta::pure::executionPlan::executionPlan($lambda,simpleRelationalMapping, meta::relational::tests::testRuntime(), meta::pure::router::extension::defaultRelationalExtensions());
   let expected =
   'Sequence\n'+
   '(\n'+
   '  type = TDS[(firstName, String, VARCHAR(200), "")]\n'+
   '  (\n'+
   '    Allocation\n'+
   '    (\n'+
   '      type = Date\n'+
   '      name = x\n'+
   '      value = \n'+
   '        (\n'+
   '          PureExp\n'+
   '          (\n'+
   '            type = Date\n'+
   '            expression = now() -> adjust(1, Enumeration DurationUnit -> extractEnumValue(\'DAYS\'))\n'+
   '          )\n'+
   '        )\n'+
   '    )\n'+
   '    Relational\n'+
   '    (\n'+
   '      type = TDS[(firstName, String, VARCHAR(200), "")]\n'+
   '      resultColumns = [("firstName", VARCHAR(200))]\n' +
   '      sql = select "root".FIRSTNAME as "firstName" from personTable as "root" where \'${x}\' > dateadd(DAY, -1, current_timestamp())\n'+
   '      connection = TestDatabaseConnection(type = "H2")\n'+
   '    )\n'+
   '  )\n'+
   ')\n';

   assertEquals($expected, $res->planToString(meta::pure::router::extension::defaultRelationalExtensions()));

   let withJava = $res->generatePlatformCode(^PlatformCodeGenerationConfig(platform=Platform.JAVA), defaultRelationalExtensions());

   let expectedJava =
   'Sequence\n' +
   '(\n' +
   '  type = TDS[(firstName, String, VARCHAR(200), "")]\n' +
   '  (\n' +
   '    Allocation\n' +
   '    (\n' +
   '      type = Date\n' +
   '      name = x\n' +
   '      value = \n' +
   '        (\n' +
   '          PureExp\n' +
   '          (\n' +
   '            type = Date\n' +
   '            expression = now() -> adjust(1, Enumeration DurationUnit -> extractEnumValue(\'DAYS\'))\n' +
   '            implementation\n' +
   '            (\n' +
   '              calls = _pure.plan.root.n1.n1.Execute.execute\n' +
   '            )\n' +
   '          )\n' +
   '        )\n' +
   '    )\n' +
   '    Relational\n' +
   '    (\n' +
   '      type = TDS[(firstName, String, VARCHAR(200), "")]\n' +
   '      resultColumns = [("firstName", VARCHAR(200))]\n' +
   '      sql = select "root".FIRSTNAME as "firstName" from personTable as "root" where \'${x}\' > dateadd(DAY, -1, current_timestamp())\n' +
   '      connection = TestDatabaseConnection(type = "H2")\n' +
   '    )\n' +
   '  )\n' +
   ')\n' +
   'globalImplementationSupport\n' +
   '(\n' +
   '  classes =\n' +
   '      _pure.plan.root.n1.n1.Execute\n' +
   '      0001 package _pure.plan.root.n1.n1;\n' +
   '      0002 \n' +
   '      0003 import java.util.Date;\n' +
   '      0004 import org.finos.legend.engine.plan.dependencies.domain.date.DurationUnit;\n' +
   '      0005 import org.finos.legend.engine.plan.dependencies.domain.date.PureDate;\n' +
   '      0006 import org.finos.legend.engine.plan.dependencies.store.shared.IExecutionNodeContext;\n' +
   '      0007 import org.finos.legend.engine.plan.dependencies.util.Library;\n' +
   '      0008 \n' +
   '      0009 public class Execute {\n' +
   '      0010 \n' +
   '      0011     public static Object execute(IExecutionNodeContext context) {\n' +
   '      0012         try\n' +
   '      0013         {\n' +
   '      0014             return Library.adjustDate(PureDate.fromDate(new Date()), 1L, DurationUnit.DAYS);\n' +
   '      0015         }\n' +
   '      0016         catch (Exception e)\n' +
   '      0017         {\n' +
   '      0018             throw new RuntimeException("Failed in node: root.n1.n1", e);\n' +
   '      0019         }\n' +
   '      0020     }\n' +
   '      0021 }\n' +
   ')\n';
   assertEquals($expectedJava, $withJava->planToString(true, meta::pure::router::extension::defaultRelationalExtensions()));
}

function <<test.Test>> meta::pure::executionPlan::tests::letVariableFunctionAdjustDateLiteral() : Boolean[1]
{
   let lambda = {| let x = adjust(%2005-10-10,1,DurationUnit.DAYS);
                     meta::relational::tests::model::simple::Person.all()
                     ->filter(p|$x>%2005-10-10->adjust(-1, DurationUnit.DAYS))
                     ->project([col({p:meta::relational::tests::model::simple::Person[1]|$p.firstName}, 'firstName')]);};

   let res = meta::pure::executionPlan::executionPlan($lambda,simpleRelationalMapping, meta::relational::tests::testRuntime(), meta::pure::router::extension::defaultRelationalExtensions());
   let expected =
   'Sequence\n'+
   '(\n'+
   '  type = TDS[(firstName, String, VARCHAR(200), "")]\n'+
   '  (\n'+
   '    Allocation\n'+
   '    (\n'+
   '      type = Date\n'+
   '      name = x\n'+
   '      value = \n'+
   '        (\n'+
   '          PureExp\n'+
   '          (\n'+
   '            type = Date\n'+
   '            expression = 2005-10-10 -> adjust(1, Enumeration DurationUnit -> extractEnumValue(\'DAYS\'))\n'+
   '          )\n'+
   '        )\n'+
   '    )\n'+
   '    Relational\n'+
   '    (\n'+
   '      type = TDS[(firstName, String, VARCHAR(200), "")]\n'+
   '      resultColumns = [("firstName", VARCHAR(200))]\n' +
   '      sql = select "root".FIRSTNAME as "firstName" from personTable as "root" where \'${x}\' > dateadd(DAY, -1, \'2005-10-10\')\n'+
   '      connection = TestDatabaseConnection(type = "H2")\n'+
   '    )\n'+
   '  )\n'+
   ')\n';

   assertEquals($expected, $res->planToString(meta::pure::router::extension::defaultRelationalExtensions()));

   let withJava = $res->generatePlatformCode(^PlatformCodeGenerationConfig(platform=Platform.JAVA), defaultRelationalExtensions());

   let expectedJava =
   'Sequence\n' +
   '(\n' +
   '  type = TDS[(firstName, String, VARCHAR(200), "")]\n' +
   '  (\n' +
   '    Allocation\n' +
   '    (\n' +
   '      type = Date\n' +
   '      name = x\n' +
   '      value = \n' +
   '        (\n' +
   '          PureExp\n' +
   '          (\n' +
   '            type = Date\n' +
   '            expression = 2005-10-10 -> adjust(1, Enumeration DurationUnit -> extractEnumValue(\'DAYS\'))\n' +
   '            implementation\n' +
   '            (\n' +
   '              calls = _pure.plan.root.n1.n1.Execute.execute\n' +
   '            )\n' +
   '          )\n' +
   '        )\n' +
   '    )\n' +
   '    Relational\n' +
   '    (\n' +
   '      type = TDS[(firstName, String, VARCHAR(200), "")]\n' +
   '      resultColumns = [("firstName", VARCHAR(200))]\n' +
   '      sql = select "root".FIRSTNAME as "firstName" from personTable as "root" where \'${x}\' > dateadd(DAY, -1, \'2005-10-10\')\n' +
   '      connection = TestDatabaseConnection(type = "H2")\n' +
   '    )\n' +
   '  )\n' +
   ')\n' +
   'globalImplementationSupport\n' +
   '(\n' +
   '  classes =\n' +
   '      _pure.plan.root.n1.n1.Execute\n' +
   '      0001 package _pure.plan.root.n1.n1;\n' +
   '      0002 \n' +
   '      0003 import org.finos.legend.engine.plan.dependencies.domain.date.DurationUnit;\n' +
   '      0004 import org.finos.legend.engine.plan.dependencies.domain.date.PureDate;\n' +
   '      0005 import org.finos.legend.engine.plan.dependencies.store.shared.IExecutionNodeContext;\n' +
   '      0006 import org.finos.legend.engine.plan.dependencies.util.Library;\n' +
   '      0007 \n' +
   '      0008 public class Execute {\n' +
   '      0009 \n' +
   '      0010     public static Object execute(IExecutionNodeContext context) {\n' +
   '      0011         try\n' +
   '      0012         {\n' +
   '      0013             return Library.adjustDate(PureDate.parsePureDate("2005-10-10"), 1L, DurationUnit.DAYS);\n' +
   '      0014         }\n' +
   '      0015         catch (Exception e)\n' +
   '      0016         {\n' +
   '      0017             throw new RuntimeException("Failed in node: root.n1.n1", e);\n' +
   '      0018         }\n' +
   '      0019     }\n' +
   '      0020 }\n' +
   ')\n';
   assertEquals($expectedJava, $withJava->planToString(true, meta::pure::router::extension::defaultRelationalExtensions()));

}

function <<test.Test>> meta::pure::executionPlan::tests::testTemporalDateVariableAtRoot():Boolean[1]
{
   let l = {bd:Date[1]|meta::relational::tests::milestoning::Product.all($bd)->project(col(t|$t.id, 'id'))};
   let result = executionPlan($l, meta::relational::tests::milestoning::milestoningmap, meta::relational::tests::testRuntime(), meta::pure::router::extension::defaultRelationalExtensions());
   let rlnNode = $result.rootExecutionNode.executionNodes->filter(n|$n->instanceOf(RelationalInstantiationExecutionNode))->at(0).executionNodes->at(0)->cast(@SQLExecutionNode);
   let rlnNodeSQL = $rlnNode.sqlQuery;
   assertEquals('select "root".id as "id" from ProductTable as "root" where "root".from_z <= \'${bd}\' and "root".thru_z > \'${bd}\'', $rlnNodeSQL);
}

function <<test.Test>> meta::pure::executionPlan::tests::testTemporalDateVariableInPropertySequence():Boolean[1]
{
   let l = {bd:Date[1]|meta::relational::tests::milestoning::Product.all($bd)->project(t|$t.classification($bd).type, 'classificationType')};
   let result = executionPlan($l, meta::relational::tests::milestoning::milestoningmap, meta::relational::tests::testRuntime(), meta::pure::router::extension::defaultRelationalExtensions());
   let rlnNode = $result.rootExecutionNode.executionNodes->filter(n|$n->instanceOf(RelationalInstantiationExecutionNode))->at(0).executionNodes->at(0)->cast(@SQLExecutionNode);
   let rlnNodeSQL = $rlnNode.sqlQuery;
   assertEquals('select "productclassificationtable_0".type as "classificationType" from ProductTable as "root" left outer join ProductClassificationTable as "productclassificationtable_0" on ("root".type = "productclassificationtable_0".type and "productclassificationtable_0".from_z <= \'${bd}\' and "productclassificationtable_0".thru_z > \'${bd}\') where "root".from_z <= \'${bd}\' and "root".thru_z > \'${bd}\'', $rlnNodeSQL);
}

function <<test.Test>> meta::pure::executionPlan::tests::testTemporalDateVariableInFunctionExpression():Boolean[1]
{
   let l = {bd:Date[1]|meta::relational::tests::milestoning::Product.all($bd)->project(t|$t.classification($bd->adjust(1, DurationUnit.DAYS)).type, 'classificationType')};
   let result = executionPlan($l, meta::relational::tests::milestoning::milestoningmap, meta::relational::tests::testRuntime(), meta::pure::router::extension::defaultRelationalExtensions());
   let rlnNode = $result.rootExecutionNode.executionNodes->filter(n|$n->instanceOf(RelationalInstantiationExecutionNode))->at(0).executionNodes->at(0)->cast(@SQLExecutionNode);
   let rlnNodeSQL = $rlnNode.sqlQuery;
   assertEquals('select "productclassificationtable_0".type as "classificationType" from ProductTable as "root" left outer join ProductClassificationTable as "productclassificationtable_0" on ("root".type = "productclassificationtable_0".type and "productclassificationtable_0".from_z <= dateadd(DAY, 1, \'${bd}\') and "productclassificationtable_0".thru_z > dateadd(DAY, 1, \'${bd}\')) where "root".from_z <= \'${bd}\' and "root".thru_z > \'${bd}\'', $rlnNodeSQL);
}

function <<test.Test>> meta::pure::executionPlan::tests::testTemporalDateVariableInFunctionExpressionWithPropagation():Boolean[1]
{
   let l = {bd:Date[1]|meta::relational::tests::milestoning::Product.all($bd)->project(t|$t.classification($bd->adjust(1, DurationUnit.DAYS)).exchange.name, 'exchangeName')};
   let result = executionPlan($l, meta::relational::tests::milestoning::milestoningmap, meta::relational::tests::testRuntime(), meta::pure::router::extension::defaultRelationalExtensions());
   let rlnNode = $result.rootExecutionNode.executionNodes->filter(n|$n->instanceOf(RelationalInstantiationExecutionNode))->at(0).executionNodes->at(0)->cast(@SQLExecutionNode);
   let rlnNodeSQL = $rlnNode.sqlQuery;
   assertEquals('select "productexchangetable_0".name as "exchangeName" from ProductTable as "root" left outer join ProductClassificationTable as "productclassificationtable_0" on ("root".type = "productclassificationtable_0".type and "productclassificationtable_0".from_z <= dateadd(DAY, 1, \'${bd}\') and "productclassificationtable_0".thru_z > dateadd(DAY, 1, \'${bd}\')) left outer join (select "productexchangetable_1".name as name from ProductExchangeTable as "productexchangetable_1" where "productexchangetable_1".from_z <= dateadd(DAY, 1, \'${bd}\') and "productexchangetable_1".thru_z > dateadd(DAY, 1, \'${bd}\')) as "productexchangetable_0" on ("productclassificationtable_0".exchange = "productexchangetable_0".name) where "root".from_z <= \'${bd}\' and "root".thru_z > \'${bd}\'', $rlnNodeSQL);
}

function <<test.Test>> meta::pure::executionPlan::tests::testModelConnectionSimple() : Boolean[1]
{
   let res = executionPlan(
                  |meta::pure::mapping::modelToModel::test::shared::dest::Firm.all()->project([f|$f.legalName], ['legalName']),
                  meta::pure::mapping::modelToModel::test::simple::simpleModelMappingWithAssociation,
                  ^Runtime(connections = [^meta::pure::mapping::modelToModel::ModelChainConnection(element = ^meta::pure::mapping::modelToModel::ModelStore(),
                                                                                                   mappings = meta::pure::mapping::modelToModel::test::shared::relationalMapping),
                     getConnection()]), meta::pure::router::extension::defaultRelationalExtensions());

   let expected =
      'Relational\n'+
      '(\n'+
      '  type = TDS[(legalName, String, "", "")]\n'+
      '  resultColumns = [("legalName", VARCHAR(200))]\n'+
      '  sql = select "root".name as "legalName" from Firm as "root"\n'+
      '  connection = TestDatabaseConnection(type = "H2")\n'+
      ')\n';
   assertEquals($expected, $res->planToString(meta::pure::router::extension::defaultRelationalExtensions()));
}

function <<test.Test>> meta::pure::executionPlan::tests::testModelConnectionDeepFunction() : Boolean[1]
{
   let res = executionPlan(
                  |meta::pure::mapping::modelToModel::test::shared::dest::Person.all()->project([p|$p.firstName, p|$p.lastName], ['firstName','lastName']),
                     meta::pure::mapping::modelToModel::test::simple::simpleModelMappingO,
                     ^Runtime(connections = [
                        ^meta::pure::mapping::modelToModel::ModelChainConnection(element = ^meta::pure::mapping::modelToModel::ModelStore(),
                                                                                 mappings = [meta::pure::mapping::modelToModel::test::simple::simpleModelMapping,
                                                                                             meta::pure::mapping::modelToModel::test::shared::relationalMapping]
                                                                                  ),
                        getConnection()]
                        )
            , meta::pure::router::extension::defaultRelationalExtensions());

   let expected =
      'Relational\n'+
      '(\n'+
      '  type = TDS[(firstName, String, "", ""), (lastName, String, "", "")]\n'+
      '  resultColumns = [("firstName", ""), ("lastName", "")]\n'+
      '  sql = select concat(substring("root".fullname, 0, LOCATE(\' \', "root".fullname)), \'XX\') as "firstName", concat(substring("root".fullname, (LOCATE(\' \', "root".fullname) + 1), char_length("root".fullname)), \'ZZ\') as "lastName" from SPerson as "root"\n'+
      '  connection = TestDatabaseConnection(type = "H2")\n'+
      ')\n';
   assertEquals($expected, $res->planToString(meta::pure::router::extension::defaultRelationalExtensions()));
}

function <<test.Test>> meta::pure::executionPlan::tests::testModelConnectionJoin() : Boolean[1]
{
   let res = executionPlan(
                  |meta::pure::mapping::modelToModel::test::shared::dest::Firm.all()->project([f|$f.legalName, f|$f.employees.lastName], ['legalName', 'lastName']),
                  meta::pure::mapping::modelToModel::test::simple::simpleModelMappingWithAssociation,
                  ^Runtime(connections = [^meta::pure::mapping::modelToModel::ModelChainConnection(element = ^meta::pure::mapping::modelToModel::ModelStore(),
                                                                                                   mappings = meta::pure::mapping::modelToModel::test::shared::relationalMapping),
                     getConnection()]), meta::pure::router::extension::defaultRelationalExtensions());
   let expected =
      'Relational\n'+
      '(\n'+
      '  type = TDS[(legalName, String, "", ""), (lastName, String, "", "")]\n'+
      '  resultColumns = [("legalName", VARCHAR(200)), ("lastName", "")]\n'+
      '  sql = select "root".name as "legalName", substring("person_0".fullname, (LOCATE(\' \', "person_0".fullname) + 1), char_length("person_0".fullname)) as "lastName" from Firm as "root" left outer join Person as "person_0" on ("person_0".firm = "root".name)\n'+
      '  connection = TestDatabaseConnection(type = "H2")\n'+
      ')\n';
   assertEquals($expected, $res->planToString(meta::pure::router::extension::defaultRelationalExtensions()));
}

function <<test.Test>> meta::pure::executionPlan::tests::testModelConnectionAgg() : Boolean[1]
{
   let g = agg(x:meta::pure::mapping::modelToModel::test::shared::dest::Person[1] | $x.lastName,  y:String[*] | $y->count());
   let res = executionPlan(|meta::pure::mapping::modelToModel::test::shared::dest::Person.all()->groupBy([x | $x.firstName], $g, ['FirstName', 'PersonCount' ]),
            meta::pure::mapping::modelToModel::test::simple::simpleModelMapping,
            ^Runtime(connections = [^meta::pure::mapping::modelToModel::ModelChainConnection(element = ^meta::pure::mapping::modelToModel::ModelStore(),
                                                                                             mappings = meta::pure::mapping::modelToModel::test::shared::relationalMapping),
                                       meta::pure::mapping::modelToModel::test::shared::getConnection()
                                   ]
             ), meta::pure::router::extension::defaultRelationalExtensions());
   let expected =
      'Relational\n'+
      '(\n'+
      '  type = TDS[(FirstName, String, "", ""), (PersonCount, Integer, INT, "")]\n'+
      '  resultColumns = [("FirstName", ""), ("PersonCount", "")]\n'+
      '  sql = select substring("root".fullname, 0, LOCATE(\' \', "root".fullname)) as "FirstName", count(substring("root".fullname, (LOCATE(\' \', "root".fullname) + 1), char_length("root".fullname))) as "PersonCount" from SPerson as "root" group by "FirstName"\n'+
      '  connection = TestDatabaseConnection(type = "H2")\n'+
      ')\n';
   assertEquals($expected, $res->planToString(meta::pure::router::extension::defaultRelationalExtensions()));
}

function <<test.Test>> meta::pure::executionPlan::tests::testExecutionPLanGenerationForFrom() : Boolean[1]
{
   let res = executionPlan(
      |_Firm.all()->from(meta::pure::mapping::modelToModel::test::shared::relationalMapping, ^Runtime(connections=meta::pure::mapping::modelToModel::test::shared::getConnection()));, meta::pure::router::extension::defaultRelationalExtensions()
   );
   let expected =
      'Relational\n'+
      '(\n'+
      '  type = Class[impls=(meta::pure::mapping::modelToModel::test::shared::src::_Firm | relationalMapping.meta_pure_mapping_modelToModel_test_shared_src__Firm)]\n'+
      '  resultSizeRange = *\n'+
      '  resultColumns = [("pk_0", VARCHAR(200)), ("name", VARCHAR(200))]\n'+
      '  sql = select "root".name as "pk_0", "root".name as "name" from Firm as "root"\n'+
      '  connection = TestDatabaseConnection(type = "H2")\n'+
      ')\n';
   assertEquals($expected, $res->planToString(meta::pure::router::extension::defaultRelationalExtensions()));
}

function <<test.Test>> meta::pure::executionPlan::tests::testExecutionPLanGenerationForFromInAllocation() : Boolean[1]
{
   let res = executionPlan(
      | let var = _Firm.all()->from(meta::pure::mapping::modelToModel::test::shared::relationalMapping, ^Runtime(connections=meta::pure::mapping::modelToModel::test::shared::getConnection()));, meta::pure::router::extension::defaultRelationalExtensions()
   );
   let expected =
      'Allocation\n'+
      '(\n'+
      '  type = Class[impls=(meta::pure::mapping::modelToModel::test::shared::src::_Firm | relationalMapping.meta_pure_mapping_modelToModel_test_shared_src__Firm)]\n'+
      '  resultSizeRange = *\n'+
      '  name = var\n'+
      '  value = \n'+
      '    (\n'+
      '      Relational\n'+
      '      (\n'+
      '        type = Class[impls=(meta::pure::mapping::modelToModel::test::shared::src::_Firm | relationalMapping.meta_pure_mapping_modelToModel_test_shared_src__Firm)]\n'+
      '        resultSizeRange = *\n'+
      '        resultColumns = [("pk_0", VARCHAR(200)), ("name", VARCHAR(200))]\n'+
      '        sql = select "root".name as "pk_0", "root".name as "name" from Firm as "root"\n'+
      '        connection = TestDatabaseConnection(type = "H2")\n'+
      '      )\n'+
      '    )\n'+
      ')\n';
   assertEquals($expected, $res->planToString(meta::pure::router::extension::defaultRelationalExtensions()));
}

function <<test.Test>> meta::pure::executionPlan::tests::testExecutionPLanGenerationForFromWithMultiClusters() : Boolean[1]
{
   let res = executionPlan(
      {|  let var = _Firm.all()->from(meta::pure::mapping::modelToModel::test::shared::relationalMapping, ^Runtime(connections=meta::pure::mapping::modelToModel::test::shared::getConnection()));
         _Firm.all()->from(meta::pure::mapping::modelToModel::test::shared::relationalMapping, ^Runtime(connections=meta::pure::mapping::modelToModel::test::shared::getConnection()));}, meta::pure::router::extension::defaultRelationalExtensions()
   );
   let expected =
      'Sequence\n'+
      '(\n'+
      '  type = Class[impls=(meta::pure::mapping::modelToModel::test::shared::src::_Firm | relationalMapping.meta_pure_mapping_modelToModel_test_shared_src__Firm)]\n'+
      '  resultSizeRange = *\n'+
      '  (\n'+
      '    Allocation\n'+
      '    (\n'+
      '      type = Class[impls=(meta::pure::mapping::modelToModel::test::shared::src::_Firm | relationalMapping.meta_pure_mapping_modelToModel_test_shared_src__Firm)]\n'+
      '      resultSizeRange = *\n'+
      '      name = var\n'+
      '      value = \n'+
      '        (\n'+
      '          Relational\n'+
      '          (\n'+
      '            type = Class[impls=(meta::pure::mapping::modelToModel::test::shared::src::_Firm | relationalMapping.meta_pure_mapping_modelToModel_test_shared_src__Firm)]\n'+
      '            resultSizeRange = *\n'+
      '            resultColumns = [("pk_0", VARCHAR(200)), ("name", VARCHAR(200))]\n'+
      '            sql = select "root".name as "pk_0", "root".name as "name" from Firm as "root"\n'+
      '            connection = TestDatabaseConnection(type = "H2")\n'+
      '          )\n'+
      '        )\n'+
      '    )\n'+
      '    Relational\n'+
      '    (\n'+
      '      type = Class[impls=(meta::pure::mapping::modelToModel::test::shared::src::_Firm | relationalMapping.meta_pure_mapping_modelToModel_test_shared_src__Firm)]\n'+
      '      resultSizeRange = *\n'+
      '      resultColumns = [("pk_0", VARCHAR(200)), ("name", VARCHAR(200))]\n'+
      '      sql = select "root".name as "pk_0", "root".name as "name" from Firm as "root"\n'+
      '      connection = TestDatabaseConnection(type = "H2")\n'+
      '    )\n'+
      '  )\n'+
      ')\n';
   assertEquals($expected, $res->planToString(meta::pure::router::extension::defaultRelationalExtensions()));
}

function <<test.Test>> meta::pure::executionPlan::tests::testExecutionPlanGenerationForInWithCollectionInput() : Boolean[1]
{
   let res = executionPlan(
      {name:String[*] |_Person.all()->filter(x | $x.fullName->in($name))->project([x | $x.fullName], ['fullName']);},
      meta::pure::mapping::modelToModel::test::shared::relationalMapping, ^Runtime(connections=^DatabaseConnection(element = relationalDB, type=DatabaseType.MemSQL)), meta::pure::router::extension::defaultRelationalExtensions()
   );
   let expected = 'RelationalBlockExecutionNode(type=TDS[(fullName,String,VARCHAR(1000),"")](FunctionParametersValidationNode(functionParameters=[name:String[*]])Allocation(type=Stringname=inFilterClause_namevalue=(FreeMarkerConditionalExecutionNode(type=Stringcondition=${(instanceOf(name,"Stream")||((collectionSize(name)?number)>1048576))?c}trueBlock=(Sequence(type=String(CreateAndPopulateTempTable(type=meta::pure::router::VoidinputVarNames=[name]tempTableName=tempTableForIn_nametempTableColumns=[(ColumnForStoringInCollection,VARCHAR(200))]connection=DatabaseConnection(type="MemSQL"))Constant(type=Stringvalues=[select`temptableforin_name_0`.ColumnForStoringInCollectionasColumnForStoringInCollectionfromtempTableForIn_nameas`temptableforin_name_0`]))))falseBlock=(Constant(type=Stringvalues=[\'${renderCollection(name"\',\'")}\'])))))Relational(type=TDS[(fullName,String,VARCHAR(1000),"")]resultColumns=[("fullName",VARCHAR(1000))]sql=select`root`.fullnameas`fullName`fromPersonas`root`where`root`.fullnamein(${inFilterClause_name})connection=DatabaseConnection(type="MemSQL"))))';
   assertEquals($expected, $res->planToStringWithoutFormatting(meta::pure::router::extension::defaultRelationalExtensions()));
}

function <<test.Test, test.ToFix>> meta::pure::executionPlan::tests::testExecutionPlanGenerationForInWithCollectionIntegerInput():Boolean[1]
{
   let res = executionPlan(
      {lengths:Integer[*] |_Person.all()->filter(x | $x.fullName->length()->in($lengths))->project([x | $x.fullName], ['fullName']);},
      meta::pure::mapping::modelToModel::test::shared::relationalMapping, ^Runtime(connections=^DatabaseConnection(element = relationalDB, type=DatabaseType.MemSQL)), meta::pure::router::extension::defaultRelationalExtensions()
   );
   let expected = 'RelationalBlockExecutionNode(type=TDS[(fullName,String,VARCHAR(1000),"")](FunctionParametersValidationNode(functionParameters=[lengths:Integer[*]])Allocation(type=Stringname=inFilterClause_lengthsvalue=(FreeMarkerConditionalExecutionNode(type=Stringcondition=${(instanceOf(lengths,"Stream")||((collectionSize(lengths)?number)>1048576))?c}trueBlock=(Sequence(type=String(CreateAndPopulateTempTable(type=meta::pure::router::VoidinputVarNames=[lengths]tempTableName=tempTableForIn_lengthstempTableColumns=[(ColumnForStoringInCollection,INT)]connection=DatabaseConnection(type="MemSQL"))Constant(type=Stringvalues=[select`temptableforin_lengths_0`.ColumnForStoringInCollectionasColumnForStoringInCollectionfromtempTableForIn_lengthsas`temptableforin_lengths_0`]))))falseBlock=(Constant(type=Stringvalues=[\'${renderCollection(lengths\',\')}\'])))))Relational(type=TDS[(fullName,String,VARCHAR(1000),"")]resultColumns=[("fullName",VARCHAR(1000))]sql=select`root`.fullnameas`fullName`fromPersonas`root`wherechar_length(`root`.fullname)in(${inFilterClause_lengths})connection=DatabaseConnection(type="MemSQL"))))';
   assertEquals($expected, $res->planToStringWithoutFormatting(meta::pure::router::extension::defaultRelationalExtensions()));
}

function <<test.Test>> meta::pure::executionPlan::tests::testExecutionPlanGenerationForMultipleInWithCollectionAndConstantInputs() : Boolean[1]
{
   let res = executionPlan(
      {name:String[*] |_Person.all()->filter(x | $x.fullName->in($name))->filter(x | $x.fullName->in(['A', 'B']))->project([x | $x.fullName], ['fullName']);},
      meta::pure::mapping::modelToModel::test::shared::relationalMapping, ^Runtime(connections=^DatabaseConnection(element = relationalDB, type=DatabaseType.SybaseIQ)), meta::pure::router::extension::defaultRelationalExtensions()
   );
   let expected = 'RelationalBlockExecutionNode(type=TDS[(fullName,String,VARCHAR(1000),"")](FunctionParametersValidationNode(functionParameters=[name:String[*]])Allocation(type=Stringname=inFilterClause_namevalue=(FreeMarkerConditionalExecutionNode(type=Stringcondition=${(instanceOf(name,"Stream")||((collectionSize(name)?number)>250000))?c}trueBlock=(Sequence(type=String(CreateAndPopulateTempTable(type=meta::pure::router::VoidinputVarNames=[name]tempTableName=tempTableForIn_nametempTableColumns=[(ColumnForStoringInCollection,VARCHAR(200))]connection=DatabaseConnection(type="SybaseIQ"))Constant(type=Stringvalues=[select"temptableforin_name_0".ColumnForStoringInCollectionasColumnForStoringInCollectionfromtempTableForIn_nameas"temptableforin_name_0"]))))falseBlock=(Constant(type=Stringvalues=[\'${renderCollection(name"\',\'")}\'])))))Relational(type=TDS[(fullName,String,VARCHAR(1000),"")]resultColumns=[("fullName",VARCHAR(1000))]sql=select"root".fullnameas"fullName"fromPersonas"root"where"root".fullnamein(${inFilterClause_name})and"root".fullnamein(\'A\',\'B\')connection=DatabaseConnection(type="SybaseIQ"))))';
   assertEquals($expected, $res->planToStringWithoutFormatting(meta::pure::router::extension::defaultRelationalExtensions()));
}

function <<test.Test>> meta::pure::executionPlan::tests::testExecutionPlanGenerationForMultipleInWithTwoCollectionInputs() : Boolean[1]
{
   let res = executionPlan(
      {name:String[*], name1:String[*]|_Person.all()->filter(x | $x.fullName->in($name))->filter(x | $x.fullName->in($name1))->project([x | $x.fullName], ['fullName']);},
      meta::pure::mapping::modelToModel::test::shared::relationalMapping, ^Runtime(connections=^DatabaseConnection(element = relationalDB, type=DatabaseType.DB2)), meta::pure::router::extension::defaultRelationalExtensions()
   );
   let expected = ['RelationalBlockExecutionNode(type=TDS[(fullName,String,VARCHAR(1000),"")](FunctionParametersValidationNode(functionParameters=[name:String[*],name1:String[*]])Allocation(type=Stringname=inFilterClause_name1value=(FreeMarkerConditionalExecutionNode(type=Stringcondition=${(instanceOf(name1,"Stream")||((collectionSize(name1)?number)>32767))?c}trueBlock=(Sequence(type=String(CreateAndPopulateTempTable(type=meta::pure::router::VoidinputVarNames=[name1]tempTableName=tempTableForIn_name1tempTableColumns=[(ColumnForStoringInCollection,VARCHAR(200))]connection=DatabaseConnection(type="DB2"))Constant(type=Stringvalues=[select"temptableforin_name1_0".ColumnForStoringInCollectionasColumnForStoringInCollectionfromtempTableForIn_name1as"temptableforin_name1_0"]))))falseBlock=(Constant(type=Stringvalues=[\'${renderCollection(name1"\',\'")}\'])))))Allocation(type=Stringname=inFilterClause_namevalue=(FreeMarkerConditionalExecutionNode(type=Stringcondition=${(instanceOf(name,"Stream")||((collectionSize(name)?number)>32767))?c}trueBlock=(Sequence(type=String(CreateAndPopulateTempTable(type=meta::pure::router::VoidinputVarNames=[name]tempTableName=tempTableForIn_nametempTableColumns=[(ColumnForStoringInCollection,VARCHAR(200))]connection=DatabaseConnection(type="DB2"))Constant(type=Stringvalues=[select"temptableforin_name_0".ColumnForStoringInCollectionasColumnForStoringInCollectionfromtempTableForIn_nameas"temptableforin_name_0"]))))falseBlock=(Constant(type=Stringvalues=[\'${renderCollection(name"\',\'")}\'])))))Relational(type=TDS[(fullName,String,VARCHAR(1000),"")]resultColumns=[("fullName",VARCHAR(1000))]sql=select"root".fullnameas"fullName"fromPersonas"root"where"root".fullnamein(${inFilterClause_name})and"root".fullnamein(${inFilterClause_name1})connection=DatabaseConnection(type="DB2"))))',
      'RelationalBlockExecutionNode(type=TDS[(fullName,String,VARCHAR(1000),"")](FunctionParametersValidationNode(functionParameters=[name:String[*],name1:String[*]])Allocation(type=Stringname=inFilterClause_namevalue=(FreeMarkerConditionalExecutionNode(type=Stringcondition=${(instanceOf(name,"Stream")||((collectionSize(name)?number)>32767))?c}trueBlock=(Sequence(type=String(CreateAndPopulateTempTable(type=meta::pure::router::VoidinputVarNames=[name]tempTableName=tempTableForIn_nametempTableColumns=[(ColumnForStoringInCollection,VARCHAR(200))]connection=DatabaseConnection(type="DB2"))Constant(type=Stringvalues=[select"temptableforin_name_0".ColumnForStoringInCollectionasColumnForStoringInCollectionfromtempTableForIn_nameas"temptableforin_name_0"]))))falseBlock=(Constant(type=Stringvalues=[\'${renderCollection(name"\',\'")}\'])))))Allocation(type=Stringname=inFilterClause_name1value=(FreeMarkerConditionalExecutionNode(type=Stringcondition=${(instanceOf(name1,"Stream")||((collectionSize(name1)?number)>32767))?c}trueBlock=(Sequence(type=String(CreateAndPopulateTempTable(type=meta::pure::router::VoidinputVarNames=[name1]tempTableName=tempTableForIn_name1tempTableColumns=[(ColumnForStoringInCollection,VARCHAR(200))]connection=DatabaseConnection(type="DB2"))Constant(type=Stringvalues=[select"temptableforin_name1_0".ColumnForStoringInCollectionasColumnForStoringInCollectionfromtempTableForIn_name1as"temptableforin_name1_0"]))))falseBlock=(Constant(type=Stringvalues=[\'${renderCollection(name1"\',\'")}\'])))))Relational(type=TDS[(fullName,String,VARCHAR(1000),"")]resultColumns=[("fullName",VARCHAR(1000))]sql=select"root".fullnameas"fullName"fromPersonas"root"where"root".fullnamein(${inFilterClause_name})and"root".fullnamein(${inFilterClause_name1})connection=DatabaseConnection(type="DB2"))))'];
   assert($expected->contains($res->planToStringWithoutFormatting(meta::pure::router::extension::defaultRelationalExtensions())));
}

function <<test.Test>> meta::pure::executionPlan::tests::testExecutionPlanGenerationForMultipleInWithTwoCollectionInputsForSnowflake() : Boolean[1]
{
   let res = executionPlan({ids:Integer[*], dates:Date[*]|Trade.all()->filter(t|$t.settlementDateTime->in($dates) && $t.id->in($ids))->project([x | $x.id], ['TradeId'])},
                           simpleRelationalMapping, ^Runtime(connections=^DatabaseConnection(element = relationalDB, type=DatabaseType.Snowflake)), meta::pure::router::extension::defaultRelationalExtensions());
   let expected = ['RelationalBlockExecutionNode(type=TDS[(TradeId,Integer,INT,"")](FunctionParametersValidationNode(functionParameters=[ids:Integer[*],dates:Date[*]])Allocation(type=Stringname=inFilterClause_datesvalue=(FreeMarkerConditionalExecutionNode(type=Stringcondition=${(instanceOf(dates,"Stream")||((collectionSize(dates)?number)>16348))?c}trueBlock=(Sequence(type=String(CreateAndPopulateTempTable(type=meta::pure::router::VoidinputVarNames=[dates]tempTableName=tempTableForIn_datestempTableColumns=[(ColumnForStoringInCollection,TIMESTAMP)]connection=DatabaseConnection(type="Snowflake"))Constant(type=Stringvalues=[select"temptableforin_dates_0".ColumnForStoringInCollectionasColumnForStoringInCollectionfromtempTableForIn_datesas"temptableforin_dates_0"]))))falseBlock=(Constant(type=Stringvalues=[\'${renderCollection(dates"\',\'")}\'])))))Allocation(type=Stringname=inFilterClause_idsvalue=(FreeMarkerConditionalExecutionNode(type=Stringcondition=${(instanceOf(ids,"Stream")||((collectionSize(ids)?number)>16348))?c}trueBlock=(Sequence(type=String(CreateAndPopulateTempTable(type=meta::pure::router::VoidinputVarNames=[ids]tempTableName=tempTableForIn_idstempTableColumns=[(ColumnForStoringInCollection,INT)]connection=DatabaseConnection(type="Snowflake"))Constant(type=Stringvalues=[select"temptableforin_ids_0".ColumnForStoringInCollectionasColumnForStoringInCollectionfromtempTableForIn_idsas"temptableforin_ids_0"]))))falseBlock=(Constant(type=Stringvalues=[${renderCollection(ids\',\')}])))))Relational(type=TDS[(TradeId,Integer,INT,"")]resultColumns=[("TradeId",INT)]sql=select"root".IDas"TradeId"fromtradeTableas"root"where("root".settlementDateTimein(${inFilterClause_dates})and"root".IDin(${inFilterClause_ids}))connection=DatabaseConnection(type="Snowflake"))))',
      'RelationalBlockExecutionNode(type=TDS[(TradeId,Integer,INT,"")](FunctionParametersValidationNode(functionParameters=[ids:Integer[*],dates:Date[*]])Allocation(type=Stringname=inFilterClause_idsvalue=(FreeMarkerConditionalExecutionNode(type=Stringcondition=${(instanceOf(ids,"Stream")||((collectionSize(ids)?number)>16348))?c}trueBlock=(Sequence(type=String(CreateAndPopulateTempTable(type=meta::pure::router::VoidinputVarNames=[ids]tempTableName=tempTableForIn_idstempTableColumns=[(ColumnForStoringInCollection,INT)]connection=DatabaseConnection(type="Snowflake"))Constant(type=Stringvalues=[select"temptableforin_ids_0".ColumnForStoringInCollectionasColumnForStoringInCollectionfromtempTableForIn_idsas"temptableforin_ids_0"]))))falseBlock=(Constant(type=Stringvalues=[${renderCollection(ids\',\')}])))))Allocation(type=Stringname=inFilterClause_datesvalue=(FreeMarkerConditionalExecutionNode(type=Stringcondition=${(instanceOf(dates,"Stream")||((collectionSize(dates)?number)>16348))?c}trueBlock=(Sequence(type=String(CreateAndPopulateTempTable(type=meta::pure::router::VoidinputVarNames=[dates]tempTableName=tempTableForIn_datestempTableColumns=[(ColumnForStoringInCollection,TIMESTAMP)]connection=DatabaseConnection(type="Snowflake"))Constant(type=Stringvalues=[select"temptableforin_dates_0".ColumnForStoringInCollectionasColumnForStoringInCollectionfromtempTableForIn_datesas"temptableforin_dates_0"]))))falseBlock=(Constant(type=Stringvalues=[\'${renderCollection(dates"\',\'")}\'])))))Relational(type=TDS[(TradeId,Integer,INT,"")]resultColumns=[("TradeId",INT)]sql=select"root".IDas"TradeId"fromtradeTableas"root"where("root".settlementDateTimein(${inFilterClause_dates})and"root".IDin(${inFilterClause_ids}))connection=DatabaseConnection(type="Snowflake"))))'];

   assert($expected->contains($res->planToStringWithoutFormatting(meta::pure::router::extension::defaultRelationalExtensions())));
}

function <<test.Test>> meta::pure::executionPlan::tests::testExecutionPlanGenerationForInWithVarAndConstantInputs():Boolean[1]
{
   let res = executionPlan({name:String[1] |_Person.all()->filter(x | $x.fullName->in([$name, 'John', 'Peter', '1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12', '13', '14', '15', '16', '17', '18', '19', '20', '21', '22', '23', '24', '25', '26', '27', '28', '29', '30', '31', '32', '33', '34', '35', '36', '37', '38', '39', '40', '41', '42', '43', '44', '45', '46', '47', '48', '49', '50']))->project([x | $x.fullName], ['fullName']);},
                           meta::pure::mapping::modelToModel::test::shared::relationalMapping, ^Runtime(connections=^TestDatabaseConnection(element = relationalDB, type=DatabaseType.H2)), meta::pure::router::extension::defaultRelationalExtensions());
   let expected = 'RelationalBlockExecutionNode(type=TDS[(fullName,String,VARCHAR(1000),"")](FunctionParametersValidationNode(functionParameters=[name:String[1]])Allocation(type=meta::pure::functions::collection::Listname=tempVarForIn_4value=(Constant(type=meta::pure::functions::collection::Listvalues=[[[John,Peter,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50]]])))CreateAndPopulateTempTable(type=meta::pure::router::VoidinputVarNames=[name,tempVarForIn_4]tempTableName=tempTableForIn_4tempTableColumns=[(ColumnForStoringInCollection,VARCHAR(200))]connection=TestDatabaseConnection(type="H2"))Relational(type=TDS[(fullName,String,VARCHAR(1000),"")]resultColumns=[("fullName",VARCHAR(1000))]sql=select"root".fullnameas"fullName"fromPersonas"root"where"root".fullnamein(select"temptableforin_4_0".ColumnForStoringInCollectionasColumnForStoringInCollectionfromtempTableForIn_4as"temptableforin_4_0")connection=TestDatabaseConnection(type="H2"))))';
   assertEquals($expected, $res->planToStringWithoutFormatting(meta::pure::router::extension::defaultRelationalExtensions()));
}

function <<test.Test>> meta::pure::executionPlan::tests::relationalTDSTypeForColumnsAndQuoting():Boolean[1]
{
   let queryWithoutQuotes   = {|tableToTDS(meta::relational::functions::database::tableReference(meta::relational::tests::db,'default','tableWithQuotedColumns'))
                  ->project([
                               col({r:TDSRow[1]|$r.getString('FIRST NAME')}, 'FIRST NAME'),
                               col({r:TDSRow[1]|$r.getString('LAST NAME')}, 'LAST NAME'),
                               col({r:TDSRow[1]|$r.getString('1columnStartsWithNumber')}, '1columnStartsWithNumber')
                              ])
                 ->restrict(['FIRST NAME', 'LAST NAME', '1columnStartsWithNumber'])
                 ->filter({r | $r.getString('FIRST NAME') == 'Peter'})};

   let mapping = meta::relational::tests::tds::tabletds::EmptyMapping;
   let runtime = meta::relational::tests::testRuntime();

   let expected =
      'Relational\n'+
      '(\n'+
      '  type = TDS[(FIRST NAME, String, VARCHAR(200), ""), (LAST NAME, String, VARCHAR(200), ""), (1columnStartsWithNumber, String, VARCHAR(200), "")]\n'+
      '  resultColumns = [("FIRST NAME", VARCHAR(200)), ("LAST NAME", VARCHAR(200)), ("1columnStartsWithNumber", VARCHAR(200))]\n'+
      '  sql = select "root"."FIRST NAME" as "FIRST NAME", "root"."LAST NAME" as "LAST NAME", "root"."1columnStartsWithNumber" as "1columnStartsWithNumber" from tableWithQuotedColumns as "root" where "root"."FIRST NAME" = \'Peter\'\n'+
      '  connection = TestDatabaseConnection(type = "H2")\n'+
      ')\n';

   let planWithoutQuotes = executionPlan($queryWithoutQuotes, $mapping, $runtime, meta::pure::router::extension::defaultRelationalExtensions());

   assertEquals($expected, $planWithoutQuotes->planToString(meta::pure::router::extension::defaultRelationalExtensions()));

    let queryWithQuotes   = {|tableToTDS(meta::relational::functions::database::tableReference(meta::relational::tests::db,'default','tableWithQuotedColumns'))
                            ->project([
                               col({r:TDSRow[1]|$r.getString('FIRST NAME')}, 'FIRST NAME'),
                               col({r:TDSRow[1]|$r.getString('LAST NAME')}, 'LAST NAME'),
                               col({r:TDSRow[1]|$r.getString('1columnStartsWithNumber')}, '1columnStartsWithNumber')
                              ])
                 ->restrict(['"FIRST NAME"', '"LAST NAME"', '"1columnStartsWithNumber"'])
                 ->filter({r | $r.getString('"FIRST NAME"') == 'Peter'})};

   let planWithQuotes = executionPlan($queryWithoutQuotes, $mapping, $runtime, meta::pure::router::extension::defaultRelationalExtensions());

   assertEquals($expected, $planWithQuotes->planToString(meta::pure::router::extension::defaultRelationalExtensions()));
}

function <<test.Test>> meta::pure::executionPlan::tests::testSupportStreamFlagSimple():Boolean[1]
{
   let plan = executionPlan({id:Integer[1], name:String[*]|Person.all()->filter(p|$p.name->in($name) || $p.age == $id)->project(col(p|$p.firstName, 'firstName'))}, simpleRelationalMapping, meta::relational::tests::testRuntime(), meta::pure::router::extension::defaultRelationalExtensions());
   let functionParameters = $plan.rootExecutionNode->allNodes(defaultRelationalExtensions())->filter(node | $node->instanceOf(FunctionParametersValidationNode))->cast(@FunctionParametersValidationNode).functionParameters;

   assertEquals($functionParameters->filter(param | $param.name == 'id').supportsStream, false);
   assertEquals($functionParameters->filter(param | $param.name == 'name').supportsStream, true);
}

function <<test.Test>> meta::pure::executionPlan::tests::testSupportStreamFlagWithSupportedAndUnSupportedUsages():Boolean[1]
{
   let plan = executionPlan({name:String[*]|Person.all()->filter(p|$p.name->in($name) || $name->isEmpty())->project(col(p|$p.firstName, 'firstName'))}, simpleRelationalMapping, meta::relational::tests::testRuntime(), meta::pure::router::extension::defaultRelationalExtensions());
   let functionParameters = $plan.rootExecutionNode->allNodes(defaultRelationalExtensions())->filter(node | $node->instanceOf(FunctionParametersValidationNode))->cast(@FunctionParametersValidationNode).functionParameters;

   assertEquals($functionParameters->filter(param | $param.name == 'name').supportsStream, false);
}

function <<test.Test>> meta::pure::executionPlan::tests::testSupportStreamFlagWithTdsJoinForOneDB():Boolean[1]
{
   let plan =executionPlan({name:String[*]|
                testJoinTDS_Person.all()->filter(p|$p.firstName->in($name))->meta::pure::tds::project([col(p|$p.firstName, 'firstName'), col(p|$p.employerID, 'eID')])
                ->join(testJoinTDS_Firm.all()->filter(p|$p.legalName->in($name))->project([col(p|$p.firmID, 'fID'), col(p|$p.legalName, 'legalName')]), JoinType.INNER, {a,b|$a.getInteger('eID') == $b.getInteger('fID');});},testJoinTDSMapping, meta::relational::tests::testRuntime(), meta::pure::router::extension::defaultRelationalExtensions());
   let functionParameters = $plan.rootExecutionNode->allNodes(defaultRelationalExtensions())->filter(node | $node->instanceOf(FunctionParametersValidationNode))->cast(@FunctionParametersValidationNode).functionParameters;

   assertEquals($functionParameters->filter(param | $param.name == 'name').supportsStream, true);
}

function <<test.Test>> meta::pure::executionPlan::tests::testSupportStreamFlagithTdsJoinForTwoDB():Boolean[1]
{
   let plan = executionPlan({name:String[*]|
                                 meta::relational::tests::tds::tdsJoin::testJoinTDS_Person.all()->filter(p|$p.firstName->in($name))->meta::pure::tds::project([col(p|$p.firstName, 'firstName'), col(p|$p.employerID, 'eID')])
                          ->join(meta::relational::tests::tds::tdsJoin::testJoinTDS_Firm.all()->filter(p|$p.legalName->in($name))->project([col(p|$p.firmID, 'fID'),col(p|$p.legalName, 'legalName')]), JoinType.INNER, {a,b|$a.getInteger('eID') == $b.getInteger('fID');});}
                            , meta::relational::tests::tds::tdsJoin::testJoinTDSMappingTwoDatabase, meta::relational::tests::tds::tdsJoin::twoDBRunTime(), meta::pure::router::extension::defaultRelationalExtensions());

   let functionParameters = $plan.rootExecutionNode->allNodes(defaultRelationalExtensions())->filter(node | $node->instanceOf(FunctionParametersValidationNode))->cast(@FunctionParametersValidationNode).functionParameters;

   assertEquals($functionParameters->filter(param | $param.name == 'name').supportsStream, false);
}

function <<test.Test>> meta::pure::executionPlan::tests::testSupportStreamFlagFromSimple():Boolean[1]
{
   let plan = executionPlan({id:Integer[1], name:String[*]|Person.all()->filter(p|$p.name->in($name) || $p.age == $id)->project(col(p|$p.firstName, 'firstName'))->from(simpleRelationalMapping, meta::relational::tests::testRuntime())}, meta::pure::router::extension::defaultRelationalExtensions());
   let functionParameters = $plan.rootExecutionNode->allNodes(defaultRelationalExtensions())->filter(node | $node->instanceOf(FunctionParametersValidationNode))->cast(@FunctionParametersValidationNode).functionParameters;

   assertEquals($functionParameters->filter(param | $param.name == 'id').supportsStream, false);
   assertEquals($functionParameters->filter(param | $param.name == 'name').supportsStream, true);
}

function <<test.Test>> meta::pure::executionPlan::tests::testSupportStreamFlagGraphFetchSimple():Boolean[1]
{
   let tree = #{
      Person {
         firstName,
         firm {
            legalName
         }
      }
   }#;

   let query = {name:String[*]|Person.all()->filter(p|$p.name->in($name))->graphFetch($tree)->serialize($tree)};
   let mapping = meta::relational::tests::mapping::embedded::model::mapping::testMappingEmbedded;
   let runtime = meta::relational::tests::testRuntime();

   let plan = executionPlan($query, $mapping, $runtime, meta::pure::router::extension::defaultRelationalExtensions());
   let functionParameters = $plan.rootExecutionNode->allNodes(defaultRelationalExtensions())->filter(node | $node->instanceOf(FunctionParametersValidationNode))->cast(@FunctionParametersValidationNode).functionParameters;

   assertEquals($functionParameters->filter(param | $param.name == 'name').supportsStream, true);
}

function <<test.Test>> meta::pure::executionPlan::tests::testSupportStreamFlagWithGraphFetchAndFrom():Boolean[1]
{
   let runtime = ^Runtime(connections = getConnection());
   let query = {firmName:String[*]|
                 let targetGraph = #{meta::pure::mapping::modelToModel::test::shared::dest::Firm{legalName,
                                          employees{
                                             firstName,
                                             lastName,
                                             addresses { street }
                                          }
                                       }}#;
                 let sourceGraph = meta::pure::graphFetch::calculateSourceTree($targetGraph, meta::relational::tests::functions::objectReferenceIn::simpleModelMapping, defaultRelationalExtensions());
                 let sourceFirms = _Firm.all()->filter(f | $f.name->in($firmName))
                                              ->graphFetch($sourceGraph)->from(meta::pure::mapping::modelToModel::test::shared::relationalMapping, $runtime);
                 Firm.all()->graphFetch($targetGraph)->serialize($targetGraph)->from(meta::relational::tests::functions::objectReferenceIn::simpleModelMapping, getRuntimeWithModelConnection(_Firm, $sourceFirms));
               };

   let plan = executionPlan($query, meta::pure::router::extension::defaultRelationalExtensions());
   let functionParameters = $plan.rootExecutionNode->allNodes(meta::pure::router::extension::defaultRelationalExtensions())->filter(node | $node->instanceOf(FunctionParametersValidationNode))->cast(@FunctionParametersValidationNode).functionParameters;

   assertEquals($functionParameters->filter(param | $param.name == 'firmName').supportsStream, true);
}

function <<test.Test>> meta::pure::executionPlan::tests::classPathsInfluencedByPlanId() : Boolean[1]
{
   let lambda = {| let x = adjust(%2005-10-10,1,DurationUnit.DAYS);
                     meta::relational::tests::model::simple::Person.all()
                     ->filter(p|$x>%2005-10-10->adjust(-1, DurationUnit.DAYS))
                     ->project([col({p:meta::relational::tests::model::simple::Person[1]|$p.firstName}, 'firstName')]);};

   let unbound = meta::pure::executionPlan::executionPlan($lambda,simpleRelationalMapping, meta::relational::tests::testRuntime(), meta::pure::router::extension::defaultRelationalExtensions());

   let withoutPlanId        = $unbound->generatePlatformCode(^PlatformCodeGenerationConfig(platform=Platform.JAVA), defaultRelationalExtensions());
   let withoutPlanIdPackage = $withoutPlanId.globalImplementationSupport->cast(@JavaPlatformImplementation).classes.package->removeDuplicates();

   let withPlanId           = $unbound->generatePlatformCode(^PlatformCodeGenerationConfig(platform=Platform.JAVA, planId='abc'), defaultRelationalExtensions());
   let withPlanIdPackage    = $withPlanId.globalImplementationSupport->cast(@JavaPlatformImplementation).classes.package->removeDuplicates();

   assertEquals('_pure.plan.root.n1.n1', $withoutPlanIdPackage);
   assertEquals('_pure.plan_abc.plan.root.n1.n1', $withPlanIdPackage);
}

function <<test.Test>> meta::pure::executionPlan::tests::testQuoteIdentifiersFlag():Boolean[1]
{
   let runtime = ^Runtime(connections = ^TestDatabaseConnection(element = meta::relational::tests::db,
                                                                type = DatabaseType.H2,
                                                                quoteIdentifiers = true
                                                             ));
   let result = executionPlan({|Product.all()->filter(p|$p.name == 'bla')}, simpleRelationalMapping, $runtime, meta::pure::router::extension::defaultRelationalExtensions());
   assertEquals('Relational\n'+
                '(\n'+
                '  type = Class[impls=(meta::relational::tests::model::simple::Product | simpleRelationalMapping.meta_relational_tests_model_simple_Product)]\n'+
                '  resultSizeRange = *\n'+
                '  resultColumns = [("pk_0", INT), ("name", VARCHAR(200))]\n'+
                '  sql = select "root"."ID" as "pk_0", "root"."NAME" as "name" from "productSchema"."productTable" as "root" where "root"."NAME" = \'bla\'\n'+
                '  connection = TestDatabaseConnection(type = "H2")\n'+
                ')\n', $result->planToString(meta::pure::router::extension::defaultRelationalExtensions()));
}

function <<test.Test>> meta::pure::executionPlan::tests::testQuoteIdentifiersFlagInOrderByClause():Boolean[1]
{
   let runtime = ^Runtime(connections = ^TestDatabaseConnection(element = meta::relational::tests::db,
                                                                type = DatabaseType.H2,
                                                                quoteIdentifiers = true
                                                             ));
   let result = executionPlan({|Product.all()->project(p|$p.name, 'name')->sort('name')}, simpleRelationalMapping, $runtime, meta::pure::router::extension::defaultRelationalExtensions());
   assertEquals('Relational\n'+
                '(\n'+
                '  type = TDS[(name, String, VARCHAR(200), "")]\n'+
                '  resultColumns = [("name", VARCHAR(200))]\n'+
                '  sql = select "root"."NAME" as "name" from "productSchema"."productTable" as "root" order by "name"\n'+
                '  connection = TestDatabaseConnection(type = "H2")\n'+
                ')\n', $result->planToString(meta::pure::router::extension::defaultRelationalExtensions()));
}

function <<test.Test>> meta::pure::executionPlan::tests::testQuoteIdentifiersFlagInGroupBy():Boolean[1]
{
   let runtime = ^Runtime(connections = ^TestDatabaseConnection(element = meta::relational::tests::db,
                                                                type = DatabaseType.H2,
                                                                quoteIdentifiers = true
                                                             ));
   let result = executionPlan({|Product.all()->project([#/Product/name!prodName#])->groupBy('prodName', agg('cnt', x|$x, y| $y->count()))}, simpleRelationalMapping, $runtime, meta::pure::router::extension::defaultRelationalExtensions());
   assertEquals('Relational\n'+
                '(\n'+
                '  type = TDS[(prodName, String, VARCHAR(200), ""), (cnt, Integer, INT, "")]\n'+
                '  resultColumns = [("prodName", VARCHAR(200)), ("cnt", "")]\n'+
                '  sql = select "root"."NAME" as "prodName", count(*) as "cnt" from "productSchema"."productTable" as "root" group by "prodName"\n'+
                '  connection = TestDatabaseConnection(type = "H2")\n'+
                ')\n', $result->planToString(meta::pure::router::extension::defaultRelationalExtensions()));
}

function <<test.Test>> meta::pure::executionPlan::tests::testQuoteIdentifiersFlagWithGraphFetch():Boolean[1]
{
   let runtime = ^Runtime(connections = ^TestDatabaseConnection(element = meta::relational::tests::db,
                                                                type = DatabaseType.H2,
                                                                quoteIdentifiers = true
                                                             ));
   let graph = #{Product{name}}#;
   let result = executionPlan({|Product.all()->graphFetch($graph)->serialize($graph)}, simpleRelationalMapping, $runtime, meta::pure::router::extension::defaultRelationalExtensions());
   assertEquals('PureExp(type=Stringexpression=[NodeIndex:0]->serialize(meta::relational::tests::model::simple::Product{name})(GlobalGraphFetch(type=PartialClass[impls=[(meta::relational::tests::model::simple::Product|simpleRelationalMapping.meta_relational_tests_model_simple_Product)],propertiesWithParameters=[name]]resultSizeRange=*store=meta::relational::tests::dblocalGraphFetchExecutionNode=RelationalGraphFetch(type=PartialClass[impls=[(meta::relational::tests::model::simple::Product|simpleRelationalMapping.meta_relational_tests_model_simple_Product)],propertiesWithParameters=[name]]nodeIndex=0relationalNode=SQL(type=meta::pure::metamodel::type::AnyresultColumns=[("pk_0",INT),("name",VARCHAR(200))]sql=select"root"."ID"as"pk_0","root"."NAME"as"name"from"productSchema"."productTable"as"root"connection=TestDatabaseConnection(type="H2"))children=[])children=[])))', $result->planToStringWithoutFormatting(meta::pure::router::extension::defaultRelationalExtensions()));
}
