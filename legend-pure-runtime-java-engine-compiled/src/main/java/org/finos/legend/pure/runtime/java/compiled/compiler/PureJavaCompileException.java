// Copyright 2020 Goldman Sachs
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package org.finos.legend.pure.runtime.java.compiled.compiler;

import org.eclipse.collections.api.RichIterable;
import org.eclipse.collections.api.list.ImmutableList;
import org.eclipse.collections.api.list.MutableList;
import org.eclipse.collections.impl.block.factory.Predicates;
import org.eclipse.collections.impl.factory.Lists;
import org.eclipse.collections.impl.factory.Sets;
import org.eclipse.collections.impl.utility.ArrayIterate;
import org.eclipse.collections.impl.utility.Iterate;
import org.eclipse.collections.impl.utility.LazyIterate;

import javax.tools.Diagnostic;
import javax.tools.DiagnosticCollector;
import javax.tools.JavaFileObject;

/**
 * Error that occurs during compilation of Java files generated by Pure.
 */
public class PureJavaCompileException extends Exception
{
    private static final int MAX_SOURCES_FOR_MESSAGE = 5;
    private static final int MAX_LINES_FOR_MESSAGE = 250;
    private static final long SOURCE_CONTEXT_LINES = 20;

    private final ImmutableList<Diagnostic<? extends JavaFileObject>> diagnostics;

    public PureJavaCompileException(Iterable<Diagnostic<? extends JavaFileObject>> diagnostics)
    {
        super(createMessage(diagnostics));
        this.diagnostics = Lists.immutable.withAll(diagnostics);
    }

    public PureJavaCompileException(DiagnosticCollector<JavaFileObject> diagnosticCollector)
    {
        this(diagnosticCollector.getDiagnostics());
    }

    public RichIterable<Diagnostic<? extends JavaFileObject>> getDiagnostics()
    {
        return this.diagnostics;
    }

    public RichIterable<Diagnostic<? extends JavaFileObject>> getErrorDiagnostics()
    {
        return LazyIterate.select(this.diagnostics, PureJavaCompileException::isErrorDiagnostic);
    }

    private static String createMessage(Iterable<Diagnostic<? extends JavaFileObject>> diagnostics)
    {
        MutableList<Diagnostic<? extends JavaFileObject>> errorDiagnostics = Iterate.select(diagnostics, PureJavaCompileException::isErrorDiagnostic, Lists.mutable.empty());
        return (errorDiagnostics.isEmpty())
                ? "Unknown error compiling generated Java code"
                : new MessageBuilder(errorDiagnostics).getMessage();
    }

    private static boolean isErrorDiagnostic(Diagnostic<?> diagnostic)
    {
        return (diagnostic != null) && (Diagnostic.Kind.ERROR == diagnostic.getKind());
    }

    private static String getSourceName(Diagnostic<? extends JavaFileObject> diagnostic)
    {
        JavaFileObject source = diagnostic.getSource();
        return (source == null) ? null : source.getName();
    }

    private static class MessageBuilder
    {
        private final MutableList<Diagnostic<? extends JavaFileObject>> diagnostics;
        private MutableList<String> lines;
        private String lastSourceName;
        private String[] sourceLines;
        private long sourceLinesHighwater;

        private MessageBuilder(MutableList<Diagnostic<? extends JavaFileObject>> diagnostics)
        {
            this.diagnostics = diagnostics;
        }

        String getMessage()
        {
            this.lines = Lists.mutable.empty();
            this.lastSourceName = null;

            addLine(createSummaryMessage());
            this.diagnostics.forEach(diagnostic -> printLines(diagnostic.toString()));
            this.diagnostics.groupBy(PureJavaCompileException::getSourceName).forEachValue(this::printDiagnosticSource);
            return lines.makeString("\n");
        }

        private void addLine(String line)
        {
            if (this.lines.size() < MAX_LINES_FOR_MESSAGE)
            {
                this.lines.add(line);
            }
            else if (this.lines.size() == MAX_LINES_FOR_MESSAGE)
            {
                this.lines.add("... (max message size exceeded)");
            }
        }

        private void printLines(String text)
        {
            String[] lines = text.split("\\n");
            ArrayIterate.forEach(lines, this::addLine);
        }

        private String createSummaryMessage()
        {
            StringBuilder builder = new StringBuilder();
            int count = this.diagnostics.size();
            builder.append(count);
            builder.append((count == 1) ? " error compiling " : " errors compiling ");
            MutableList<String> sourceNames = LazyIterate.collect(this.diagnostics, PureJavaCompileException::getSourceName).select(Predicates.notNull(), Sets.mutable.empty()).toSortedList();

            if (sourceNames.size() <= MAX_SOURCES_FOR_MESSAGE)
            {
                sourceNames.appendString(builder, ", ");
            }
            else
            {
                LazyIterate.take(sourceNames, MAX_SOURCES_FOR_MESSAGE).appendString(builder, "", ", ", ", ... (and ");
                builder.append(sourceNames.size() - MAX_SOURCES_FOR_MESSAGE);
                builder.append(" more)");
            }
            return builder.toString();
        }

        private void printDiagnosticSource(Diagnostic<? extends JavaFileObject> diagnostic)
        {
            String sourceName = getSourceName(diagnostic);
            if (sourceName != this.lastSourceName) //NOSONAR
            {
                JavaFileObject source = diagnostic.getSource();
                if (source instanceof StringJavaSource)
                {
                    this.sourceLines = ((StringJavaSource) source).getCode().split("\\n");
                    this.sourceLinesHighwater = 0;
                    addLine("");
                    addLine(sourceName);
                }
                else
                {
                    this.sourceLines = new String[0];
                    this.sourceLinesHighwater = 0;
                }
                this.lastSourceName = sourceName;
            }
            long lineNo = Math.max(diagnostic.getLineNumber() - SOURCE_CONTEXT_LINES, this.sourceLinesHighwater + 1);
            long end = Math.min(diagnostic.getLineNumber() + SOURCE_CONTEXT_LINES, this.sourceLines.length);
            if (lineNo - this.sourceLinesHighwater > 2)
            {
                addLine(String.format("%04d:%04d ...", this.sourceLinesHighwater + 1, lineNo - 1));
                this.sourceLinesHighwater = lineNo - 1;
            }
            else
            {
                lineNo = this.sourceLinesHighwater + 1;
            }

            while (lineNo < end)
            {
                if (this.sourceLinesHighwater < lineNo)
                {
                    addLine(String.format("%04d %s", lineNo, this.sourceLines[(int) (lineNo - 1)]));
                    this.sourceLinesHighwater = lineNo;
                }
                lineNo++;
            }
        }
    }
}
