import meta::legend::service::metamodel::*;

import meta::pure::persist::metamodel::*;
import meta::pure::persist::metamodel::backend::*;
import meta::pure::persist::metamodel::batch::*;
import meta::pure::persist::metamodel::batch::audit::*;
import meta::pure::persist::metamodel::batch::deduplication::*;
import meta::pure::persist::metamodel::batch::mode::*;
import meta::pure::persist::metamodel::batch::mode::appendonly::*;
import meta::pure::persist::metamodel::batch::mode::delta::*;
import meta::pure::persist::metamodel::batch::mode::delta::merge::*;
import meta::pure::persist::metamodel::batch::mode::snapshot::*;
import meta::pure::persist::metamodel::batch::transactionmilestoned::*;
import meta::pure::persist::metamodel::batch::validitymilestoned::*;
import meta::pure::persist::metamodel::batch::validitymilestoned::derivation::*;
import meta::pure::persist::metamodel::event::*;

/**********
 * service persistence
 **********/

Class
{doc.doc = 'A service persistence specification. This consists of a trigger event type, a reference to a service that sources and transforms data in response to incoming events, and a specification of how to persist the service output to a datastore.'}
meta::pure::persist::metamodel::ServicePersistence extends PackageableElement
{
   {doc.doc = 'A functional description of this service persistence specification.'}
   documentation: String[1];

   {doc.doc = 'Owners of this service persistence specification.'}
   owners: String[1..*];

   {doc.doc = 'The type of event that serves as a trigger for service execution and then persistence.'}
   trigger: EventType[1];

   {doc.doc = 'The service that specifies sourcing and transformation logic to run for incoming events.' }
   service: Service[1];

   {doc.doc = 'The persistence approach to be applied to the output of the service.'}
   persistence: Persistence[1];
}

/**********
 * backend
 **********/

Class
<<typemodifiers.abstract>>
{doc.doc = 'The mapping of a service persistence specification to a backend system for execution.'}
meta::pure::persist::metamodel::ServicePersistenceBackend extends PackageableElement
{
   servicePersistence: ServicePersistence[1];
}

Class
{doc.doc = 'Backend details for executing on the AWS Glue managed ETL service.'}
meta::pure::persist::metamodel::AwsGlueServicePersistenceBackend extends ServicePersistenceBackend
{
}

/**********
 * event type
 **********/

Class
<<typemodifiers.abstract>>
{doc.doc = 'Types of events that may trigger a persistence pipeline.'}
meta::pure::persist::metamodel::event::EventType
{
}

Class meta::pure::persist::metamodel::event::ScheduleTriggered extends EventType
{
}

Class meta::pure::persist::metamodel::event::RegistryDatasetAvailable extends EventType
{
}

/**********
 * persistence
 **********/

Class
<<typemodifiers.abstract>>
{doc.doc = 'The persistence logic to run on the output of the engine service.'}
meta::pure::persist::metamodel::Persistence
{
   inputShape: DataShape[1];
   inputClass: Class<Any>[1];
}

Enum
{doc.doc = 'The shape of the service output and thus the expected shape of the persistence input.'}
meta::pure::persist::metamodel::DataShape
{
   {doc.doc = 'A flat object whose properties are primitive types with single multiplicity.'}
   FLAT,

   {doc.doc = 'An object nested one level deep. Each property of the root object is a flat object whose properties are primitive types with single multiplicity.'}
   GROUPED_FLAT,

   {doc.doc = 'An arbitrarily deeply nested object.'}
   NESTED
}

Class meta::pure::persist::metamodel::streaming::StreamingPersistence extends Persistence
{
}

Class meta::pure::persist::metamodel::batch::BatchPersistence extends Persistence
{
   transactionMode: BatchTransactionMode[1];
   targetSpecification: BatchDatastoreSpecification[1];
}

Enum
{doc.doc = 'The transaction granularity for the persistence'}
meta::pure::persist::metamodel::batch::BatchTransactionMode
{
   {doc.doc = 'Each dataset in the datastore executes in its own transaction; each succeeds or fails independently.'}
   SINGLE_DATASET,

   {doc.doc = 'All datasets in the datastore execute in a single transaction; all succeed or fail together.'}
   ALL_DATASETS
}

Class
{doc.doc = 'A target datastore for a batch persistence.'}
meta::pure::persist::metamodel::batch::BatchDatastoreSpecification
{
   datastoreName: String[1];
   datasets: BatchDatasetSpecification[1..*];
}

Class
{doc.doc = 'A target dataset for a batch persistence.'}
meta::pure::persist::metamodel::batch::BatchDatasetSpecification
{
   datasetName: String[1];
   partitionProperties: Property<Nil, Any|1>[*];
   deduplicationStrategy: DeduplicationStrategy[1];
   milestoningMode: BatchMilestoningMode[1];
}

/**********
 * deduplication strategy
 **********/

Class
<<typemodifiers.abstract>>
meta::pure::persist::metamodel::batch::deduplication::DeduplicationStrategy
{
}

Class meta::pure::persist::metamodel::batch::deduplication::NoDeduplicationStrategy extends DeduplicationStrategy
{
}

Class meta::pure::persist::metamodel::batch::deduplication::AnyDeduplicationStrategy extends DeduplicationStrategy
{
}

Class meta::pure::persist::metamodel::batch::deduplication::CountDeduplicationStrategy extends DeduplicationStrategy
{
   duplicateCountPropertyName: String[1];
}

Class meta::pure::persist::metamodel::batch::deduplication::MaxVersionDeduplicationStrategy extends DeduplicationStrategy
{
   versionProperty: Property<Nil, Any|1>[1];
}

/**********
 * batch mode
 **********/

Class
<<typemodifiers.abstract>>
{doc.doc = 'The batch milestoning strategy to apply.'}
meta::pure::persist::metamodel::batch::mode::BatchMilestoningMode
{
}

/**********
 * batch mode - snapshot
 **********/

Class
{doc.doc = 'Values in the incoming batch represent the full dataset and will replace the existing dataset destructively.'}
meta::pure::persist::metamodel::batch::mode::snapshot::NonMilestonedSnapshot extends BatchMilestoningMode
{
   auditScheme: AuditScheme[1];
}

Class
{doc.doc = 'Values in the incoming batch represent the full dataset and will replace the existing dataset non-destructively. New incoming values represent a logical create; updated incoming values represent a logical update; missing incoming values represent a logical delete in the transaction (processing) dimension. The data have only a transaction (processing) dimension and no validity (business) dimension.'}
meta::pure::persist::metamodel::batch::mode::snapshot::UnitemporalSnapshot extends BatchMilestoningMode
{
   transactionMilestoningScheme: TransactionMilestoningScheme[1];
}

Class
{doc.doc = 'Values in the incoming batch represent the full dataset and will replace the existing dataset non-destructively. New incoming values represent a logical create; updated incoming values represent a logical update; missing incoming values represent a logical delete in the transaction (processing) dimension. The data have a transaction (processing) dimension and a validity (business) dimension.'}
meta::pure::persist::metamodel::batch::mode::snapshot::BitemporalSnapshot extends BatchMilestoningMode
{
   transactionMilestoningScheme: TransactionMilestoningScheme[1];
   validityMilestoningScheme: ValidityMilestoningScheme[1];
   validityDerivation: ValidityDerivation[1];
}

/**********
 * batch mode - delta
 **********/

Class
{doc.doc = 'Values in the incoming batch represent a delta to be applied on top of the existing dataset destructively. New incoming values are appended. Updated incoming values overwrite existing ones. Missing incoming values result in a no-op.'}
meta::pure::persist::metamodel::batch::mode::delta::NonMilestonedDelta extends BatchMilestoningMode
{
   auditScheme: AuditScheme[1];
}

Class
{doc.doc = 'Values in the incoming batch represent a delta to be applied on top of the existing dataset non-destructively. New incoming values represent a logical create; updated incoming values represent a logical update; missing incoming values represent a no-op in the transaction (processing) dimension. Additional merge semantics, including logical deletes, can be supported via a merge scheme. The data have only a transaction (processing) dimension and no validity (business) dimension.' }
meta::pure::persist::metamodel::batch::mode::delta::UnitemporalDelta extends BatchMilestoningMode
{
   mergeScheme: MergeScheme[1];
   transactionMilestoningScheme: TransactionMilestoningScheme[1];
}

Class
{doc.doc = 'Values in the incoming batch represent a delta to be applied on top of the existing dataset non-destructively. New incoming values represent a logical create; updated incoming values represent a logical update; missing incoming values represent a no-op in the transaction (processing) dimension. Additional merge semantics, including logical deletes, can be supported via a merge scheme. The data have a transaction (processing) dimension and a validity (business) dimension.' }
meta::pure::persist::metamodel::batch::mode::delta::BitemporalDelta extends BatchMilestoningMode
{
   mergeScheme: MergeScheme[1];
   transactionMilestoningScheme: TransactionMilestoningScheme[1];
   validityMilestoningScheme: ValidityMilestoningScheme[1];
   validityDerivation: ValidityDerivation[1];
}

// merge scheme

Class
<<typemodifiers.abstract>>
meta::pure::persist::metamodel::batch::mode::delta::merge::MergeScheme
{
}

Class
meta::pure::persist::metamodel::batch::mode::delta::merge::NoDeletesMergeScheme extends MergeScheme
{
}

Class
meta::pure::persist::metamodel::batch::mode::delta::merge::DeleteIndicatorMergeScheme extends MergeScheme
{
   deleteProperty: Property<Nil, Any|1>[1];
   deleteValues: String[1..*];
}

/**********
 * batch mode - append only
 **********/

Class
{doc.doc = 'Values in the incoming batch are appended to the existing dataset. No updates or deletes occur. Duplicates may optionally be filtered out.'}
meta::pure::persist::metamodel::batch::mode::appendonly::AppendOnly extends BatchMilestoningMode
{
   auditScheme: AuditScheme[1];
   filterDuplicates: Boolean[1];
}

/**********
 * audit scheme
 **********/

Class
<<typemodifiers.abstract>>
{doc.doc = 'Strategy for representing audit information in the underlying system.'}
meta::pure::persist::metamodel::batch::audit::AuditScheme
{
}

Class
{doc.doc = 'Audit information is not captured in the underlying system.'}
meta::pure::persist::metamodel::batch::audit::NoAuditScheme extends AuditScheme
{
}

Class
{doc.doc = 'Audit information is represented via a transaction datetime in the underlying system.'}
meta::pure::persist::metamodel::batch::audit::BatchDateTimeAuditScheme extends AuditScheme
{
   transactionDateTimePropertyName: String[1];
}

Class
{doc.doc = 'Audit information is represented at the discretion of the underlying system.'}
meta::pure::persist::metamodel::batch::audit::OpaqueAuditScheme extends AuditScheme
{
}

/**********
 * transaction milestoning dimension
 **********/

Class
<<typemodifiers.abstract>>
{doc.doc = 'Strategy for representing the transaction (processing) temporal dimension in the underlying system.'}
meta::pure::persist::metamodel::batch::transactionmilestoned::TransactionMilestoningScheme
{
}

Class
{doc.doc = 'The representation of the transaction (processing) temporal dimension is via integral "in" and "out" batch ids.'}
meta::pure::persist::metamodel::batch::transactionmilestoned::BatchIdTransactionMilestoningScheme extends TransactionMilestoningScheme
{
   {doc.doc = 'The name of the property representing the "in" batch id in the underlying system.'}
   batchIdInName: String[1];

   {doc.doc = 'The name of the property representing the "out" batch id in the underlying system.'}
   batchIdOutName: String[1];
}

Class
{doc.doc = 'The representation of the transaction (processing) temporal dimension is via "in" and "out" datetimes.'}
meta::pure::persist::metamodel::batch::transactionmilestoned::DateTimeTransactionMilestoningScheme extends TransactionMilestoningScheme
{
   {doc.doc = 'The name of the property representing the "in" datetime in the underlying system.'}
   transactionDateTimeInName: String[1];

   {doc.doc = 'The name of the property representing the "out" datetime in the underlying system.'}
   transactionDateTimeOutName: String[1];
}

Class
{doc.doc = 'The representation of the transaction (processing) temporal dimension is via integral "in" and "out" batch ids and "in" and "out" datetimes.'}
meta::pure::persist::metamodel::batch::transactionmilestoned::BatchIdAndDateTimeTransactionMilestoningScheme extends TransactionMilestoningScheme
{
   {doc.doc = 'The name of the property representing the "in" batch id in the underlying system.'}
   batchIdInName: String[1];

   {doc.doc = 'The name of the property representing the "out" batch id in the underlying system.'}
   batchIdOutName: String[1];

   {doc.doc = 'The name of the property representing the "in" datetime in the underlying system.'}
   transactionDateTimeInName: String[1];

   {doc.doc = 'The name of the property representing the "out" datetime in the underlying system.'}
   transactionDateTimeOutName: String[1];
}

Class
{doc.doc = 'The representation of the transaction (processing) temporal dimension is at the discretion of the implementing system.'}
meta::pure::persist::metamodel::batch::transactionmilestoned::OpaqueTransactionMilestoningScheme extends TransactionMilestoningScheme
{
}

/**********
 * validity milestoning dimension
 **********/

Class
<<typemodifiers.abstract>>
{doc.doc = 'Strategy for representing the validity (business) temporal dimension in the underlying system.'}
meta::pure::persist::metamodel::batch::validitymilestoned::ValidityMilestoningScheme
{
}

Class
{doc.doc = 'The representation of the validity (business) temporal dimension is via "from" and "thru" datetimes.'}
meta::pure::persist::metamodel::batch::validitymilestoned::DateTimeValidityMilestoningScheme extends ValidityMilestoningScheme
{
   {doc.doc = 'The name of the property representing the "in" datetime in the underlying system.'}
   validDateTimeFromName: String[1];

   {doc.doc = 'The name of the property representing the "out" datetime in the underlying system.'}
   validDateTimeThruName: String[1];
}

Class
{doc.doc = 'The representation of the validity (business) temporal dimension is at the discretion of the implementing system.'}
meta::pure::persist::metamodel::batch::validitymilestoned::OpaqueValidityMilestoningScheme extends ValidityMilestoningScheme
{
}

// data provider

Class
<<typemodifiers.abstract>>
{doc.doc = 'Strategy for representing the validity (business) temporal dimension in the underlying system.'}
meta::pure::persist::metamodel::batch::validitymilestoned::derivation::ValidityDerivation
{
}

Class
{doc.doc = 'Source data provide validity from datetime.'}
meta::pure::persist::metamodel::batch::validitymilestoned::derivation::SourceSpecifiesValidFromDate extends ValidityDerivation
{
   sourceValidDateTimeFromProperty: Property<Nil,  Any|1>[1];
}

Class
{doc.doc = 'Source data provide validity from and thru datetimes.'}
meta::pure::persist::metamodel::batch::validitymilestoned::derivation::SourceSpecifiesValidFromAndThruDate extends ValidityDerivation
{
   sourceValidDateTimeFromProperty: Property<Nil, Any|1>[1];
   sourceValidDateTimeThruProperty: Property<Nil, Any|1>[1];
}
