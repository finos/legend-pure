// Copyright 2021 Goldman Sachs
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import meta::protocols::pure::vX_X_X::transformation::fromPureGraph::service::*;
import meta::pure::runtime::*;
import meta::pure::mapping::*;
import meta::protocols::pure::vX_X_X::transformation::fromPureGraph::*;
import meta::pure::mapping::modelToModel::*;
import meta::legend::service::metamodel::*;
import meta::protocols::*;

function meta::protocols::pure::vX_X_X::transformation::fromPureGraph::service::transformService(service:meta::legend::service::metamodel::Service[1], extensions: meta::pure::router::extension::RouterExtension[*]):meta::protocols::pure::vX_X_X::metamodel::service::Service[1]
{
   let protocol = ^Protocol(name='pure', version='vX_X_X');
   ^meta::protocols::pure::vX_X_X::metamodel::service::Service
                  (
                    _type = 'service',
                    name = if ($service.name->isEmpty(), | 'Name_toDefine', | $service.name->toOne()),
                    package = 'Package_toDefine',
                    pattern = $service.pattern,
                    owners = $service.owners,
                    documentation = $service.documentation,
                    autoActivateUpdates = $service.autoActivateUpdates,
                    execution = transformExecution($service.execution, $extensions),
                    test = transformServiceTests($service.test, $extensions),
                    tags = $service.tags->map(t| ^meta::protocols::pure::vX_X_X::metamodel::service::ServiceTag(name= $t.name, value=$t.value))
                  );
}

function meta::protocols::pure::vX_X_X::transformation::fromPureGraph::service::buildPointer(e:Execution[1]): meta::protocols::pure::vX_X_X::metamodel::PackageableElementPointer[*]
{
   let mapping = $e->match([
                     s:meta::legend::service::metamodel::PureSingleExecution[1]|
                                                   $s.mapping->concatenate(getMappingsFromRuntime($s.runtime));,
                     m:meta::legend::service::metamodel::PureMultiExecution[1]|
                                                   $m.executionParameters.mapping->concatenate($m.executionParameters.runtime->map(r | $r->getMappingsFromRuntime()))
                                                                                 ->removeDuplicates();
                  ]);

    $mapping->map(m| ^meta::protocols::pure::vX_X_X::metamodel::PackageableElementPointer
                  (
                    type=meta::protocols::pure::vX_X_X::metamodel::PackageableElementType.MAPPING,
                    path= $m->elementToPath()
                  ));
}

function meta::protocols::pure::vX_X_X::transformation::fromPureGraph::service::transformExecution(e:Execution[1], extensions: meta::pure::router::extension::RouterExtension[*]): meta::protocols::pure::vX_X_X::metamodel::service::Execution[1]
{
  $e->match([
     s:meta::legend::service::metamodel::PureSingleExecution[1]|
          ^meta::protocols::pure::vX_X_X::metamodel::service::PureSingleExecution(
                                   _type = 'pureSingleExecution',
                                   func = $s.func->meta::protocols::pure::vX_X_X::transformation::fromPureGraph::valueSpecification::transformAny([], newMap([]->cast(@Pair<String,List<Any>>)), PureOne, $extensions)->cast(@meta::protocols::pure::vX_X_X::metamodel::valueSpecification::raw::Lambda)->toOne(),
                                   mapping = $s.mapping->elementToPath(),
                                   runtime = $s.runtime->meta::protocols::pure::vX_X_X::transformation::fromPureGraph::runtime::transformRuntime($extensions)
                                ),
    m: meta::legend::service::metamodel::PureMultiExecution[1]|
         ^meta::protocols::pure::vX_X_X::metamodel::service::PureMultiExecution(
            _type = 'pureMultiExecution',
            func = $m.func->meta::protocols::pure::vX_X_X::transformation::fromPureGraph::valueSpecification::transformAny([], newMap([]->cast(@Pair<String,List<Any>>)), PureOne, $extensions)->cast(@meta::protocols::pure::vX_X_X::metamodel::valueSpecification::raw::Lambda)->toOne(),
            executionKey = $m.executionKey,
            executionParameters = $m.executionParameters->map(es|^meta::protocols::pure::vX_X_X::metamodel::service::KeyedExecutionParameter(
                                                      key = $es.key,
                                                      mapping = $es.mapping->elementToPath(),
                                                      runtime = $es.runtime->meta::protocols::pure::vX_X_X::transformation::fromPureGraph::runtime::transformRuntime($extensions)
                                                      )
                                                )
         )
  ])
}

function meta::protocols::pure::vX_X_X::transformation::fromPureGraph::service::transformServiceTests(t:Test[1], extensions: meta::pure::router::extension::RouterExtension[*]):meta::protocols::pure::vX_X_X::metamodel::service::Test[1]
{
   $t->match([
      s:meta::legend::service::metamodel::SingleExecutionTest[1]|
            ^meta::protocols::pure::vX_X_X::metamodel::service::SingleExecutionTest
            (
               _type = 'singleExecutionTest',
               data = $s.data,
               asserts = $s.asserts->transformAsserts($extensions)
            ),

      m: meta::legend::service::metamodel::MultiExecutionTest[1]|
         ^meta::protocols::pure::vX_X_X::metamodel::service::MultiExecutionTest(
            _type = 'multiExecutionTest',
            tests = $m.tests->map(r|^meta::protocols::pure::vX_X_X::metamodel::service::KeyedSingleExecutionTest(
                                 key = $r.key,
                                 data = $r.data,
                                 asserts = $r.asserts->transformAsserts($extensions)
                              )
                           )
            )

   ])
}

function meta::protocols::pure::vX_X_X::transformation::fromPureGraph::service::transformAsserts(a:TestContainer[1..*], extensions: meta::pure::router::extension::RouterExtension[*]):meta::protocols::pure::vX_X_X::metamodel::service::TestContainer[1..*]
{
   $a->map(t|^meta::protocols::pure::vX_X_X::metamodel::service::TestContainer
              (
                 parametersValues = $t.parametersValues->map(v|$v->meta::protocols::pure::vX_X_X::transformation::fromPureGraph::valueSpecification::transformAny([], newMap([]->cast(@Pair<String,List<Any>>)), PureOne, $extensions)),
                 assert = $t.assert->meta::protocols::pure::vX_X_X::transformation::fromPureGraph::transformLambda($extensions)
              )
           )
}