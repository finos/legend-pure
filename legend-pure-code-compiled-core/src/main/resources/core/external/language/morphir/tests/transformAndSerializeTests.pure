import meta::json::*;
import meta::external::language::morphir::transform::tests::*;

function meta::external::language::morphir::transform::tests::verboseMin(v1:Number[1], v2:Number[1]):Number[1]
{
   if($v1 < $v2, |$v1,|$v2);
}

function meta::external::language::morphir::transform::tests::addTwoPointFive(v1:Number[1]):Number[1]
{
   $v1 + 2.5;
}

function meta::external::language::morphir::transform::tests::verboseMinAdd(v1:Number[1], v2:Number[1]):Number[1]
{
   if($v1 < $v2, |$v1 + 2.5,|$v2);
}

function meta::external::language::morphir::transform::tests::letFunction():Number[1]
{
   let a = 5;
}

function meta::external::language::morphir::transform::tests::zeroDivisionFunction(v1:Number[1]):Number[1]
{
   $v1 / (1 - 1);
}

function meta::external::language::morphir::transform::tests::multipleStatementFunction(v1:Number[1]):Number[1]
{
   let v2 = 2.5;
   $v1 + $v2;
}

function meta::external::language::morphir::transform::tests::multipleStatementFunctionWithZeroDivision(v1:Number[1]):Number[1]
{
   let v2 = 0.0;
   $v1 / $v2;
}

function meta::external::language::morphir::transform::tests::getRentals(requests: Number[1], available: Number[1], allowPartials: Boolean[1]):Number[1]
{
   if(0.25 < $requests / $available, 
      |0.0, 
      |if($requests < $available, 
          |$requests, 
          |if($allowPartials, 
              |$available, 
              |0.0)))
}

function meta::external::language::morphir::transform::tests::getRentalsTwo(requests: Number[1], available: Number[1], allowPartials: Boolean[1]):Number[1]
{
   let maximumAllowed = if (0.5 < $requests / $available, | $available / 2, | $requests);
   if($requests <= $maximumAllowed, 
      |$requests, 
      |if($allowPartials, 
          |$maximumAllowed, 
          |0.0));
}

// Note: Add new class or function definitions from tail to maintain existent source information.

// ------ Morphir Rental Use Cases ------

Enum meta::external::language::morphir::transform::tests::WindCategory
{
   Calm, Windy, HighWinds, DangerousWinds
}

Enum meta::external::language::morphir::transform::tests::ForecastDetail
{
   Showers, Thunderstorms, Snow, Fog
}

Enum meta::external::language::morphir::transform::tests::Reason
{
   InsufficientAvailability, ClosedDueToConditions
}

Class meta::external::language::morphir::transform::tests::Result
{
}

// For use case 1
Class meta::external::language::morphir::transform::tests::ErrResult extends meta::external::language::morphir::transform::tests::Result
{
   reason: Reason[1];
}

// For use case 2
Class meta::external::language::morphir::transform::tests::ErrResultSimple extends meta::external::language::morphir::transform::tests::Result
{
   reason: String[1];
}

Class meta::external::language::morphir::transform::tests::OkResult extends meta::external::language::morphir::transform::tests::Result
{
   reservedQuantity: Integer[1];
}

// For use case 1
function meta::external::language::morphir::transform::tests::request(availability:Integer[1], requestedQuantity:Integer[1]):Result[1]
{
   if ($requestedQuantity <= $availability,
       | ^OkResult(reservedQuantity=$requestedQuantity),
       | ^ErrResultSimple(reason='Insufficient availability'))
}

// For use case 2
function meta::external::language::morphir::transform::tests::decide(windCategory:WindCategory[1],
                                                                     forecastDetail:ForecastDetail[1],
                                                                     currentInventory:Integer[1],
                                                                     existingReservations:Integer[1],
                                                                     pendingReturns:Integer[1],
                                                                     requestedQuantity:Integer[1],
                                                                     allowPartials:Boolean[1]
                                                                     ):Result[1]
{
   let isClosed = ($windCategory == WindCategory.DangerousWinds) || ($forecastDetail == ForecastDetail.Thunderstorms);
   let availability = $currentInventory - $existingReservations + $pendingReturns;

   if ($isClosed,
       | ^ErrResult(reason=Reason.ClosedDueToConditions),
       | if ($requestedQuantity <= $availability,
             | ^OkResult(reservedQuantity=$requestedQuantity),
             | if ($allowPartials,
                   | ^OkResult(reservedQuantity=$availability),
                   | ^ErrResult(reason=Reason.InsufficientAvailability))));
}

function meta::external::language::morphir::transform::tests::decideTemp(windCategory:WindCategory[1],
                                                                        forecastDetail:String[1],
                                                                        currentInventory:Integer[1],
                                                                        existingReservations:Integer[1],
                                                                        pendingReturns:Integer[1],
                                                                        requestedQuantity:Integer[1],
                                                                        allowPartials:Boolean[1]
                                                                        ):Integer[1]
{
  //  let isClosed = ($windCategory == WindCategory.DangerousWinds) || ($forecastDetail == ForecastDetail.Thunderstorms);
  //  let availability = $currentInventory - $existingReservations + $pendingReturns;

   if ($windCategory == WindCategory.DangerousWinds || $forecastDetail == 'thun',
       | -1,
       | if ($requestedQuantity <= $currentInventory, // $currentInventory - $existingReservations + $pendingReturns,
             | $requestedQuantity,
             | if ($allowPartials,
                   | 0, // $currentInventory - $existingReservations + $pendingReturns
                   | -1)));
}

function <<test.Test>> meta::external::language::morphir::transform::tests::testTransformAndSerializeVerboseMinFunction():Boolean[1]
{
   let func = meta::external::language::morphir::transform::tests::verboseMin_Number_1__Number_1__Number_1_;
   let minFuncTransformedModel = $func->meta::external::language::morphir::transform::transformToMorphirModel();
   let minFuncSerializedComplete = $minFuncTransformedModel->meta::external::language::morphir::serialization::morphirModelToJson();
   let completeResult = $minFuncSerializedComplete->map(elem| $elem->toCompactJSONString());

   assertEquals($completeResult, '{"formatVersion":1,"distribution":["library",[["system"],["morphir"]],[],{"modules":[{"name":[["transform"]],"def":["public",{"types":[],"values":[[["verbose","min"],["public",{"inputTypes":[[["v","1"],["reference",{},[[["morphir"],["s","d","k"]],[["basics"]],["float"]],[]],["reference",{},[[["morphir"],["s","d","k"]],[["basics"]],["float"]],[]]],[["v","2"],["reference",{},[[["morphir"],["s","d","k"]],[["basics"]],["float"]],[]],["reference",{},[[["morphir"],["s","d","k"]],[["basics"]],["float"]],[]]]],"outputType":["reference",{},[[["morphir"],["s","d","k"]],[["basics"]],["float"]],[]],"body":["if_then_else",["reference",{},[[["morphir"],["s","d","k"]],[["basics"]],["float"]],[]],["apply",["reference",{},[[["morphir"],["s","d","k"]],[["basics"]],["bool"]],[]],["apply",["function",{},["reference",{},[[["morphir"],["s","d","k"]],[["basics"]],["float"]],[]],["reference",{},[[["morphir"],["s","d","k"]],[["basics"]],["bool"]],[]]],["reference",["function",{},["reference",{},[[["morphir"],["s","d","k"]],[["basics"]],["float"]],[]],["function",{},["reference",{},[[["morphir"],["s","d","k"]],[["basics"]],["float"]],[]],["reference",{},[[["morphir"],["s","d","k"]],[["basics"]],["bool"]],[]]]],[[["morphir"],["s","d","k"]],[["basics"]],["less","than"]]],["variable",["reference",{},[[["morphir"],["s","d","k"]],[["basics"]],["float"]],[]],["v","1"]]],["variable",["reference",{},[[["morphir"],["s","d","k"]],[["basics"]],["float"]],[]],["v","2"]]],["variable",["reference",{},[[["morphir"],["s","d","k"]],[["basics"]],["float"]],[]],["v","1"]],["variable",["reference",{},[[["morphir"],["s","d","k"]],[["basics"]],["float"]],[]],["v","2"]]]}]]]}]}]}]}');
}

function <<test.Test>> meta::external::language::morphir::transform::tests::testTransformAndSerializeAddFunction():Boolean[1]
{
   let func = meta::external::language::morphir::transform::tests::addTwoPointFive_Number_1__Number_1_;
   let addFuncTransformedModel = $func->meta::external::language::morphir::transform::transformToMorphirModel();
   let addFuncSerializedComplete = $addFuncTransformedModel->meta::external::language::morphir::serialization::morphirModelToJson();
   let addCompleteResult = $addFuncSerializedComplete->map(elem| $elem->toCompactJSONString());

   assertEquals($addCompleteResult, '{"formatVersion":1,"distribution":["library",[["system"],["morphir"]],[],{"modules":[{"name":[["transform"]],"def":["public",{"types":[],"values":[[["add","two","point","five"],["public",{"inputTypes":[[["v","1"],["reference",{},[[["morphir"],["s","d","k"]],[["basics"]],["float"]],[]],["reference",{},[[["morphir"],["s","d","k"]],[["basics"]],["float"]],[]]]],"outputType":["reference",{},[[["morphir"],["s","d","k"]],[["basics"]],["float"]],[]],"body":["apply",["reference",{},[[["morphir"],["s","d","k"]],[["basics"]],["float"]],[]],["apply",["function",{},["reference",{},[[["morphir"],["s","d","k"]],[["basics"]],["float"]],[]],["reference",{},[[["morphir"],["s","d","k"]],[["basics"]],["float"]],[]]],["reference",["function",{},["reference",{},[[["morphir"],["s","d","k"]],[["basics"]],["float"]],[]],["function",{},["reference",{},[[["morphir"],["s","d","k"]],[["basics"]],["float"]],[]],["reference",{},[[["morphir"],["s","d","k"]],[["basics"]],["float"]],[]]]],[[["morphir"],["s","d","k"]],[["basics"]],["add"]]],["variable",["reference",{},[[["morphir"],["s","d","k"]],[["basics"]],["float"]],[]],["v","1"]]],["literal",["reference",{},[[["morphir"],["s","d","k"]],[["basics"]],["float"]],[]],["float_literal",2.5]]]}]]]}]}]}]}');
}

function <<test.Test>> meta::external::language::morphir::transform::tests::testTransformAndSerializeVerboseMinAddFunction():Boolean[1]
{
   let func = meta::external::language::morphir::transform::tests::verboseMinAdd_Number_1__Number_1__Number_1_;
   let minFuncTwoTransformedModel = $func->meta::external::language::morphir::transform::transformToMorphirModel();
   let minFuncTwoSerializedComplete = $minFuncTwoTransformedModel->meta::external::language::morphir::serialization::morphirModelToJson();
   let minFuncTwoCompleteResult = $minFuncTwoSerializedComplete->map(elem| $elem->toCompactJSONString());

   assertEquals($minFuncTwoCompleteResult, '{"formatVersion":1,"distribution":["library",[["system"],["morphir"]],[],{"modules":[{"name":[["transform"]],"def":["public",{"types":[],"values":[[["verbose","min","add"],["public",{"inputTypes":[[["v","1"],["reference",{},[[["morphir"],["s","d","k"]],[["basics"]],["float"]],[]],["reference",{},[[["morphir"],["s","d","k"]],[["basics"]],["float"]],[]]],[["v","2"],["reference",{},[[["morphir"],["s","d","k"]],[["basics"]],["float"]],[]],["reference",{},[[["morphir"],["s","d","k"]],[["basics"]],["float"]],[]]]],"outputType":["reference",{},[[["morphir"],["s","d","k"]],[["basics"]],["float"]],[]],"body":["if_then_else",["reference",{},[[["morphir"],["s","d","k"]],[["basics"]],["float"]],[]],["apply",["reference",{},[[["morphir"],["s","d","k"]],[["basics"]],["bool"]],[]],["apply",["function",{},["reference",{},[[["morphir"],["s","d","k"]],[["basics"]],["float"]],[]],["reference",{},[[["morphir"],["s","d","k"]],[["basics"]],["bool"]],[]]],["reference",["function",{},["reference",{},[[["morphir"],["s","d","k"]],[["basics"]],["float"]],[]],["function",{},["reference",{},[[["morphir"],["s","d","k"]],[["basics"]],["float"]],[]],["reference",{},[[["morphir"],["s","d","k"]],[["basics"]],["bool"]],[]]]],[[["morphir"],["s","d","k"]],[["basics"]],["less","than"]]],["variable",["reference",{},[[["morphir"],["s","d","k"]],[["basics"]],["float"]],[]],["v","1"]]],["variable",["reference",{},[[["morphir"],["s","d","k"]],[["basics"]],["float"]],[]],["v","2"]]],["apply",["reference",{},[[["morphir"],["s","d","k"]],[["basics"]],["float"]],[]],["apply",["function",{},["reference",{},[[["morphir"],["s","d","k"]],[["basics"]],["float"]],[]],["reference",{},[[["morphir"],["s","d","k"]],[["basics"]],["float"]],[]]],["reference",["function",{},["reference",{},[[["morphir"],["s","d","k"]],[["basics"]],["float"]],[]],["function",{},["reference",{},[[["morphir"],["s","d","k"]],[["basics"]],["float"]],[]],["reference",{},[[["morphir"],["s","d","k"]],[["basics"]],["float"]],[]]]],[[["morphir"],["s","d","k"]],[["basics"]],["add"]]],["variable",["reference",{},[[["morphir"],["s","d","k"]],[["basics"]],["float"]],[]],["v","1"]]],["literal",["reference",{},[[["morphir"],["s","d","k"]],[["basics"]],["float"]],[]],["float_literal",2.5]]],["variable",["reference",{},[[["morphir"],["s","d","k"]],[["basics"]],["float"]],[]],["v","2"]]]}]]]}]}]}]}');
}

function <<test.Test>> meta::external::language::morphir::transform::tests::testTransformAndSerializeLetFunction():Boolean[1]
{
   let func = meta::external::language::morphir::transform::tests::letFunction__Number_1_;
   let letFuncTransformedModel = $func->meta::external::language::morphir::transform::transformToMorphirModel();
   let letFuncSerializedComplete = $letFuncTransformedModel->meta::external::language::morphir::serialization::morphirModelToJson();
   let letFuncTwoCompleteResult = $letFuncSerializedComplete->map(elem| $elem->toCompactJSONString());

   assertEquals($letFuncTwoCompleteResult, '{"formatVersion":1,"distribution":["library",[["system"],["morphir"]],[],{"modules":[{"name":[["transform"]],"def":["public",{"types":[],"values":[[["let","function"],["public",{"inputTypes":[],"outputType":["reference",{},[[["morphir"],["s","d","k"]],[["basics"]],["int"]],[],[]],"body":["let_definition",["reference",{},[[["morphir"],["s","d","k"]],[["basics"]],["int"]],[],[]],["a"],{"inputTypes":[],"outputType":["reference",{},[[["morphir"],["s","d","k"]],[["basics"]],["int"]],[],[]],"body":["literal",["reference",{},[[["morphir"],["s","d","k"]],[["basics"]],["int"]],[],[]],["int_literal",5]]},["variable",["reference",{},[[["morphir"],["s","d","k"]],[["basics"]],["string"]],[],[]],["a"]]]}]]]}]}]}]}');
}

function <<test.Test>> meta::external::language::morphir::transform::tests::testTransformAndSerializeZeroDivisionFunction():Boolean[1]
{
   let func = meta::external::language::morphir::transform::tests::zeroDivisionFunction_Number_1__Number_1_;
   let zeroDivFuncTransformedModel = $func->meta::external::language::morphir::transform::transformToMorphirModel();
   let zeroDivFuncSerializedComplete = $zeroDivFuncTransformedModel->meta::external::language::morphir::serialization::morphirModelToJson();
   let completeResult = $zeroDivFuncSerializedComplete->map(elem| $elem->toCompactJSONString());

   assertEquals($completeResult, '{"formatVersion":1,"distribution":["library",[["system"],["morphir"]],[],{"modules":[{"name":[["transform"]],"def":["public",{"types":[],"values":[[["zero","division","function"],["public",{"inputTypes":[[["v","1"],["reference",{},[[["morphir"],["s","d","k"]],[["basics"]],["float"]],[],[]],["reference",{},[[["morphir"],["s","d","k"]],[["basics"]],["float"]],[],[]]]],"outputType":["reference",{},[[["morphir"],["s","d","k"]],[["basics"]],["float"]],[],[]],"body":["apply",["reference",{},[[["morphir"],["s","d","k"]],[["basics"]],["float"]],[],[]],["apply",["function",{},["reference",{},[[["morphir"],["s","d","k"]],[["basics"]],["float"]],[],[]],["reference",{},[[["morphir"],["s","d","k"]],[["basics"]],["float"]],[],[]],["sourceInformation",["source","\\/core\\/external\\/language\\/morphir\\/transform.pure"],["startLine",137],["startColumn",97],["endLine",137],["endColumn",149]]],["reference",["function",{},["reference",{},[[["morphir"],["s","d","k"]],[["basics"]],["float"]],[],[]],["function",{},["reference",{},[[["morphir"],["s","d","k"]],[["basics"]],["float"]],[],[]],["reference",{},[[["morphir"],["s","d","k"]],[["basics"]],["float"]],[],[]],["sourceInformation",["source","\\/core\\/external\\/language\\/morphir\\/transform.pure"],["startLine",187],["startColumn",79],["endLine",187],["endColumn",129]]],["sourceInformation",["source","\\/core\\/external\\/language\\/morphir\\/transform.pure"],["startLine",225],["startColumn",83],["endLine",225],["endColumn",127]]],[[["morphir"],["s","d","k"]],[["basics"]],["divide"]]],["variable",["reference",{},[[["morphir"],["s","d","k"]],[["basics"]],["float"]],[],[]],["v","1"]]],["literal",["reference",{},[[["morphir"],["s","d","k"]],[["basics"]],["float"]],[],[]],["float_literal",0.0]]]}]]]}]}]}]}');
}

function <<test.Test, test.ToFix>> meta::external::language::morphir::transform::tests::testTransformAndSerializeMultipleStatementFunction():Boolean[1]
{
   let func = meta::external::language::morphir::transform::tests::multipleStatementFunction_Number_1__Number_1_;
   let funcTransformedModel = $func->meta::external::language::morphir::transform::transformToMorphirModel();
   let funcSerializedComplete = $funcTransformedModel->meta::external::language::morphir::serialization::morphirModelToJson();
   let completeResult = $funcSerializedComplete->map(elem| $elem->toCompactJSONString());

   assertEquals($completeResult, '');
}
function <<test.Test, test.ToFix>> meta::external::language::morphir::transform::tests::testTransformTemp():Boolean[1]
{
   let func = meta::external::language::morphir::transform::tests::decideTemp_WindCategory_1__String_1__Integer_1__Integer_1__Integer_1__Integer_1__Boolean_1__Integer_1_;
   let funcTransformedModel = $func->meta::external::language::morphir::transform::transformToMorphirModel();
   let funcSerializedComplete = $funcTransformedModel->meta::external::language::morphir::serialization::morphirModelToJson();
   let completeResult = $funcSerializedComplete->map(elem| $elem->toCompactJSONString());

   assertEquals($completeResult, '');
}

function <<test.Test, test.ToFix>> meta::external::language::morphir::transform::tests::testTransformRentals():Boolean[1]
{
   let func = meta::external::language::morphir::transform::tests::getRentals_Number_1__Number_1__Boolean_1__Number_1_;
   let funcTransformedModel = $func->meta::external::language::morphir::transform::transformToMorphirModel();
   let funcSerializedComplete = $funcTransformedModel->meta::external::language::morphir::serialization::morphirModelToJson();
   let completeResult = $funcSerializedComplete->map(elem| $elem->toCompactJSONString());

   assertEquals($completeResult, '');
}

function <<test.Test, test.ToFix>> meta::external::language::morphir::transform::tests::testTransformRentalsTwo():Boolean[1]
{
   let func = meta::external::language::morphir::transform::tests::getRentalsTwo_Number_1__Number_1__Boolean_1__Number_1_;
   let funcTransformedModel = $func->meta::external::language::morphir::transform::transformToMorphirModel();
   let funcSerializedComplete = $funcTransformedModel->meta::external::language::morphir::serialization::morphirModelToJson();
   let completeResult = $funcSerializedComplete->map(elem| $elem->toCompactJSONString());

   assertEquals($completeResult, '');
}