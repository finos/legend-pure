// Copyright 2020 Goldman Sachs
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import meta::json::*;
import meta::pure::generation::*;
import meta::pure::generation::metamodel::*;
import meta::pure::persistence::metamodel::*;
import meta::external::format::cpb::generation::*;
import meta::external::format::cpb::metamodel::*;

function  meta::external::format::cpb::generation::transform(input: CpbConfig[1]): CpbOutput[*]
{
  meta::legend::test::mayExecuteLegendTest(
       {clientVersion, serverVersion, serializationKind, host, port|
                   let fStr = 'meta::protocols::pure::'+$clientVersion+'::invocation::generation::cpb::legendGenerateCpb_CpbConfig_1__String_1__Integer_1__String_1__CpbOutput_MANY_';
                   let xf = $fStr->pathToElement()->cast(@Function<{CpbConfig[1], String[1], Integer[1], String[1]->CpbOutput[*]}>);
                   $xf->evaluate([$input, $host, $port, $serverVersion]->map(v|list($v)))->toOneMany()->cast(@CpbOutput);},
       | meta::external::format::cpb::generation::internal_transform($input)
    )->toOneMany();   
}

function <<access.private,Generation.Transformation>> meta::external::format::cpb::generation::internal_transform(input: CpbConfig[1]): CpbOutput[*]
{
   assertFalse($input.class->isEmpty(),'a persistence pipe must be provided to cpb transform');
   let possibleElement = forgivingPathToElement($input.class->toOne());
   assertNotEmpty($possibleElement, | $input.class->toOne() + ' was not found');
   assertFalse($possibleElement->size()>1, | $input.class->toOne() + ' more than one found ');
   $input->meta::external::format::cpb::generation::generateCpbFromPure($possibleElement->toOne()->cast(@PersistencePipe));
}


function meta::external::format::cpb::generation::generateCpbFromPureWithScope(config: CpbConfig[1]): CpbOutput[*]
{
   let scopeElements = $config.allPackageScopeElements()->filter(p|$p->instanceOf(PersistencePipe))->cast(@PersistencePipe);
   assertNotEmpty($scopeElements, 'At least one PersistencePipe is needed to transform into cloud-persistent backend form');
   $scopeElements->map(pp| $config->meta::external::format::cpb::generation::generateCpbFromPure($pp));
}

function meta::external::format::cpb::generation::generateCpbFromPure(config: CpbConfig[1], pp: PersistencePipe[1]): CpbOutput[*]
{
   let content = $pp->toJSON();
   ^CpbOutput(content=$content,fileName=$pp->elementToPath()->pathToFileName('cpb'), format='json');
}

