// Copyright 2020 Goldman Sachs
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import meta::json::*;
import meta::pure::generation::*;
import meta::pure::generation::metamodel::*;
import meta::pure::persistence::metamodel::*;
import meta::external::format::cpb::generation::*;
import meta::external::format::cpb::metamodel::*;

import meta::pure::persistence::metamodel::*;
import meta::pure::persistence::metamodel::trigger::*;
import meta::pure::persistence::metamodel::reader::*;
import meta::legend::service::metamodel::*;
import meta::pure::persistence::metamodel::batch::*;
import meta::pure::persistence::metamodel::batch::targetspecification::*;
import meta::pure::persistence::metamodel::batch::deduplication::*;
import meta::pure::persistence::metamodel::batch::mode::snapshot::*;
import meta::pure::persistence::metamodel::batch::audit::*;


function  meta::external::format::cpb::generation::transform(input: CpbConfig[1]): CpbOutput[*]
{
  meta::legend::test::mayExecuteLegendTest(
       {clientVersion, serverVersion, serializationKind, host, port|
                   let fStr = 'meta::protocols::pure::'+$clientVersion+'::invocation::generation::cpb::legendGenerateCpb_CpbConfig_1__String_1__Integer_1__String_1__CpbOutput_MANY_';
                   let xf = $fStr->pathToElement()->cast(@Function<{CpbConfig[1], String[1], Integer[1], String[1]->CpbOutput[*]}>);
                   $xf->evaluate([$input, $host, $port, $serverVersion]->map(v|list($v)))->toOneMany()->cast(@CpbOutput);},
       | meta::external::format::cpb::generation::internal_transform($input)
    )->toOneMany();   
}

function <<access.private,Generation.Transformation>> meta::external::format::cpb::generation::internal_transform(input: CpbConfig[1]): CpbOutput[*]
{
   let possibleElement = $input.allPackageScopeElements()->filter(p|$p->instanceOf(PersistencePipe))->cast(@PersistencePipe);
   assertNotEmpty($possibleElement, | 'No persistence pipe was found');
   assertFalse($possibleElement->size()>1, | 'More than one persistence pipe was found');
   $input->meta::external::format::cpb::generation::generateCpbFromPure($possibleElement->toOne()->cast(@PersistencePipe));
}


function meta::external::format::cpb::generation::generateCpbFromPureWithScope(config: CpbConfig[1]): CpbOutput[*]
{
   let scopeElements = $config.allPackageScopeElements()->filter(p|$p->instanceOf(PersistencePipe))->cast(@PersistencePipe);
   assertNotEmpty($scopeElements, 'At least one PersistencePipe is needed to transform into cloud-persistent backend form');
   $scopeElements->map(pp| $config->meta::external::format::cpb::generation::generateCpbFromPure($pp));
}

function meta::external::format::cpb::generation::generateCpbFromPure(config: CpbConfig[1], pp: PersistencePipe[1]): CpbOutput[*]
{
   let content = $pp->generateCpbBackend();
   let out = ^CpbOutput(content=$content,fileName=$pp->elementToPath()->pathToFileName('cpb'), format='json');
   $out;
}

function meta::external::format::cpb::generation::generateCpbBackend(pp: PersistencePipe[1]): String[1]
{
  let jsonConfig = config(false, false, true, true);
  let fileName = 'persistence/' + $pp->elementToPath()->pathToFileName('json');
  let content = ^PersistenceCPB(documentation=$pp.documentation, owners=$pp.owners, trigger=$pp.trigger, reader=$pp.reader, persister=$pp.persister);
  $content->toJSONElement(meta::external::format::cpb::generation::extraJsonSerializers(), 1000, $jsonConfig)->toCompactJSONString();
}

function meta::external::format::cpb::generation::extraJsonSerializers():Function<{Nil[1],JSONState[1] ->JSONElement[1]}>[*]
{
  [
    // TODO: Add based on what _type we want etc. on the CNAS side
  ]
}
