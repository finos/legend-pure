// Copyright 2020 Goldman Sachs
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import meta::java::generation::code::*;
import meta::java::generation::functions::date::pure::*;
import meta::java::generation::convention::*;
import meta::java::generation::expression::*;
import meta::java::generation::plan::*;
import meta::java::generation::utils::*;
import meta::java::metamodel::factory::*;
import meta::java::metamodel::project::*;
import meta::java::serialization::*;

Enum meta::java::generation::convention::ClassPurpose
{
   ENUMERATION,
   MODEL
}

Class meta::java::generation::convention::Conventions
[
   validBasePackage: !$this.basePackageName->endsWith('.')
]
{
   fieldNameStrategy          : Function<{String[1]->String[1]}>[1];
   getterNameStrategy         : Function<{String[1]->String[1]}>[1];
   setterNameStrategy         : Function<{String[1]->String[1]}>[1];

   defaultClassPurpose        : Any[1];

   identifierFactory          : Function<{String[1]->String[1]}>[1];
   basePackageName            : String[1];
   functionSignatureFactory   : Function<{ConcreteFunctionDefinition<Any>[1],Conventions[1]->FunctionSignature[1]}>[1];
   providedTypes              : ProvidedType[*];

   classCoders                : Map<Any, Function<{Type[1],Conventions[1],DebugContext[1]->meta::java::metamodel::Class[1]}>>[1];
   functionCoders             : Map<String, Function<{FunctionExpression[1],Conventions[1],DebugContext[1]->Code[1]}>>[1];
   prohibitedFunctionStrategy : Function<{Conventions[1],Function<Any>[1]->Boolean[1]}>[1];

   libraries                  : ConventionsLibrary[*];
   imports                    : meta::java::metamodel::Class[*];
   newFunctionProhibitedList  : Class<Any>[*];
   providedVariables          : Map<String, Code>[1];
   
   extensions : meta::pure::router::extension::RouterExtension[*];
}

Class <<access.private>> meta::java::generation::convention::TypeConversion
{
   type           : Type[1];
   oneJavaType    : meta::java::metamodel::Type[1];
   nonOneJavaType : meta::java::metamodel::Type[1];
   literalCoder   : Function<{Any[1]->Code[1]}>[1];
}

Class meta::java::generation::convention::ConventionsLibrary
{
   name               : String[0..1];
   typeConversions    : Map<Type, TypeConversion>[1];
   functionCoders     : Map<String, Function<{FunctionExpression[1],Conventions[1],DebugContext[1]->Code[1]}>>[1];
   javaPackagesUsed   : meta::java::metamodel::Package[*];
   javaClassesUsed    : meta::java::metamodel::Class[*];
   javaClassesDefined : meta::java::metamodel::Class[*];
   fundamentals       : Function<{Conventions[1],DebugContext[1]->Project[1]}>[1];
}

Class meta::java::generation::convention::FunctionSignature
{
   class  : meta::java::metamodel::Class[1];
   method : meta::java::metamodel::Method[1];
}

Class meta::java::generation::convention::ProvidedType
{
   type           : Type[1];
   providedAs     : meta::java::metamodel::Class[1];
}

function {doc.doc='Returns any base-level java types and dependencied necessary'}
meta::java::generation::convention::fundamentals(conventions: Conventions[1], debug:DebugContext[1]): Project[0..1]
{
   let libFundamentals = $conventions.libraries->map(l|$l.fundamentals->eval($conventions, $debug));

   $libFundamentals->match([
      p:  Project[0..1] | $p,
      ps: Project[1..*] | mergeProjects($ps)
   ]);
}

function meta::java::generation::convention::usesLibrary(conventions: Conventions[1], name: String[1]): Boolean[1]
{
   $conventions.libraries->exists(l | $l.name == $name);
}

function meta::java::generation::convention::fieldName(conventions: Conventions[1], property: AbstractProperty<Any>[1]): String[1]
{
   $conventions->identifier($conventions.fieldNameStrategy->eval($property.name->toOne()));
}

function meta::java::generation::convention::getterName(conventions: Conventions[1], property: AbstractProperty<Any>[1]): String[1]
{
   $conventions->identifier($conventions.getterNameStrategy->eval($property.name->toOne()));
}

function meta::java::generation::convention::setterName(conventions: Conventions[1], property: AbstractProperty<Any>[1]): String[1]
{
   $conventions->identifier($conventions.setterNameStrategy->eval($property.name->toOne()));
}

function meta::java::generation::convention::fieldName(conventions: Conventions[1], propertyName: String[1]): String[1]
{
   $conventions->identifier($conventions.fieldNameStrategy->eval($propertyName));
}

function meta::java::generation::convention::getterName(conventions: Conventions[1], propertyName: String[1]): String[1]
{
   $conventions->identifier($conventions.getterNameStrategy->eval($propertyName));
}

function meta::java::generation::convention::setterName(conventions: Conventions[1], propertyName: String[1]): String[1]
{
   $conventions->identifier($conventions.setterNameStrategy->eval($propertyName));
}

function meta::java::generation::convention::getProvidedType(conventions: Conventions[1], type: Type[1]): meta::java::metamodel::Class[1]
{
   $conventions.providedTypes->filter(pt| $pt.type == $type).providedAs->toOne();
}

function meta::java::generation::convention::isProvidedType(conventions: Conventions[1], type: Type[1]): Boolean[1]
{
   $conventions.providedTypes->filter(pt| $pt.type == $type)->isNotEmpty();
}

function meta::java::generation::convention::getProvidedVariable(conventions: Conventions[1], name:String[1]): Code[1]
{
   $conventions.providedVariables->get($name)->toOne();
}

function meta::java::generation::convention::isProvidedVariable(conventions:Conventions[1], name:String[1]): Boolean[1]
{
   $conventions.providedVariables->keys()->contains($name);
}

function meta::java::generation::convention::pureTypeToJavaType(conventions:Conventions[1], p:AbstractProperty<Any>[1]): meta::java::metamodel::Type[1]
{
   $conventions->pureTypeToJavaType($p.genericType, $p.multiplicity);
}

function meta::java::generation::convention::pureTypeToJavaType(conventions:Conventions[1], g:GenericType[1], mult:Multiplicity[1]): meta::java::metamodel::Type[1]
{
   if($g.rawType == Function,
      {|
         let fType = $g.typeArguments->at(0).rawType->toOne()->cast(@FunctionType);
         let rtn   = $conventions->pureTypeToJavaType($fType.returnType, $fType.returnMultiplicity);
         assert($fType.parameters->isEmpty(), | 'Function with parameters not yet handled');
         javaSupplier($rtn)->listIfMulti($mult);
      },
      | $conventions->pureTypeToJavaType($g.rawType->toOne(), $mult)
   );
}

function meta::java::generation::convention::pureTypeToJavaType(conventions:Conventions[1], type:Type[1], mult:Multiplicity[1]): meta::java::metamodel::Type[1]
{
   let t = if($type == Nil,
              | javaList(javaWildcard()),
              |
           if($type == String,
              | $conventions->stringType($mult),
              |
           if($type == Boolean,
              | $conventions->booleanType($mult),
              |
           if($type == Integer,
              | $conventions->integerType($mult),
              |
           if($type == Float,
              | $conventions->floatType($mult),
              |
           if($type == Decimal,
              | $conventions->decimalType($mult),
              |
           if($type == Number,
              | $conventions->numberType($mult),
              |
           if($type == StrictDate,
              | $conventions->strictDateType($mult),
              |
           if($type == DateTime,
              | $conventions->dateTimeType($mult),
              |
           if($type == Date,
              | $conventions->dateType($mult),
              |
           if($type->instanceOf(Enumeration) || $type->instanceOf(Class) || $type->instanceOf(Unit) || $type->instanceOf(Measure),
              | $conventions->className($type)->listIfMulti($mult),
              | fail('Unsupported type: ' + $type.name->toOne());
                ^meta::java::metamodel::Type();
   )))))))))));
}

function meta::java::generation::convention::stringType(     conventions:Conventions[1]): meta::java::metamodel::Type[1] { $conventions->stringType(     PureOne); }
function meta::java::generation::convention::booleanType(    conventions:Conventions[1]): meta::java::metamodel::Type[1] { $conventions->booleanType(    PureOne); }
function meta::java::generation::convention::integerType(    conventions:Conventions[1]): meta::java::metamodel::Type[1] { $conventions->integerType(    PureOne); }
function meta::java::generation::convention::floatType(      conventions:Conventions[1]): meta::java::metamodel::Type[1] { $conventions->floatType(      PureOne); }
function meta::java::generation::convention::decimalType(    conventions:Conventions[1]): meta::java::metamodel::Type[1] { $conventions->decimalType(    PureOne); }
function meta::java::generation::convention::numberType(     conventions:Conventions[1]): meta::java::metamodel::Type[1] { $conventions->numberType(     PureOne); }
function meta::java::generation::convention::strictDateType( conventions:Conventions[1]): meta::java::metamodel::Type[1] { $conventions->strictDateType( PureOne); }
function meta::java::generation::convention::dateTimeType(   conventions:Conventions[1]): meta::java::metamodel::Type[1] { $conventions->dateTimeType(   PureOne); }
function meta::java::generation::convention::dateType(       conventions:Conventions[1]): meta::java::metamodel::Type[1] { $conventions->dateType(       PureOne); }

function meta::java::generation::convention::stringType(conventions:Conventions[1], mult:Multiplicity[1]): meta::java::metamodel::Type[1]
{
    javaString()->listIfMulti($mult)
}

function meta::java::generation::convention::booleanType(conventions:Conventions[1], mult:Multiplicity[1]): meta::java::metamodel::Type[1]
{
   if($mult == PureOne, |javaBoolean(), | javaBooleanBoxed())->listIfMulti($mult)
}

function meta::java::generation::convention::integerType(conventions:Conventions[1], mult:Multiplicity[1]): meta::java::metamodel::Type[1]
{
   $conventions->javaType(Integer, $mult);
}

function meta::java::generation::convention::floatType(conventions:Conventions[1], mult:Multiplicity[1]): meta::java::metamodel::Type[1]
{
   $conventions->javaType(Float, $mult);
}

function meta::java::generation::convention::decimalType(conventions:Conventions[1], mult:Multiplicity[1]): meta::java::metamodel::Type[1]
{
   $conventions->javaType(Decimal, $mult);
}

function meta::java::generation::convention::numberType(conventions:Conventions[1], mult:Multiplicity[1]): meta::java::metamodel::Type[1]
{
   $conventions->javaType(Number, $mult);
}

function meta::java::generation::convention::strictDateType(conventions:Conventions[1], mult:Multiplicity[1]): meta::java::metamodel::Type[1]
{
   $conventions->javaType(StrictDate, $mult);
}

function meta::java::generation::convention::dateTimeType(conventions:Conventions[1], mult:Multiplicity[1]): meta::java::metamodel::Type[1]
{
   $conventions->javaType(DateTime, $mult);
}

function meta::java::generation::convention::dateType(conventions:Conventions[1], mult:Multiplicity[1]): meta::java::metamodel::Type[1]
{
   $conventions->javaType(Date, $mult);
}

function meta::java::generation::convention::stringLiteral(conventions:Conventions[1], s:String[1]): Code[1]
{
   $conventions->typeConversion(String).literalCoder->eval($s)
}

function meta::java::generation::convention::integerLiteral(conventions:Conventions[1], i:Integer[1]): Code[1]
{
   $conventions->typeConversion(Integer).literalCoder->eval($i)
}

function meta::java::generation::convention::floatLiteral(conventions:Conventions[1], f:Float[1]): Code[1]
{
   $conventions->typeConversion(Float).literalCoder->eval($f)
}

function meta::java::generation::convention::decimalLiteral(conventions:Conventions[1], d:Decimal[1]): Code[1]
{
   $conventions->typeConversion(Decimal).literalCoder->eval($d)
}

function meta::java::generation::convention::numberLiteral(conventions:Conventions[1], n:Number[1]): Code[1]
{
   $conventions->typeConversion(Number).literalCoder->eval($n)
}

function meta::java::generation::convention::booleanLiteral(conventions:Conventions[1], b:Boolean[1]) : Code[1]
{
   $conventions->typeConversion(Boolean).literalCoder->eval($b)
}

function meta::java::generation::convention::strictDateLiteral(conventions:Conventions[1], sd:StrictDate[1]): Code[1]
{
   $conventions->typeConversion(StrictDate).literalCoder->eval($sd)
}

function meta::java::generation::convention::dateTimeLiteral(conventions:Conventions[1], dt:DateTime[1]): Code[1]
{
   $conventions->typeConversion(DateTime).literalCoder->eval($dt)
}

function meta::java::generation::convention::dateLiteral(conventions:Conventions[1], d:Date[1]): Code[1]
{
   $conventions->typeConversion(Date).literalCoder->eval($d)
}

function meta::java::generation::convention::primitiveLiteral(conventions: Conventions[1], a: Any[1]): Code[1]
{
   $a->match([
      {s:String[1]      | $conventions->stringLiteral($s)},
      {i:Integer[1]     | $conventions->integerLiteral($i)},
      {f:Float[1]       | $conventions->floatLiteral($f)},
      {d:Decimal[1]     | $conventions->decimalLiteral($d)},
      {sd:StrictDate[1] | $conventions->strictDateLiteral($sd)},
      {dt:DateTime[1]   | $conventions->dateTimeLiteral($dt)},
      {d:Date[1]        | $conventions->dateLiteral($d)},
      {b:Boolean[1]     | $conventions->booleanLiteral($b)},
      {e:Enum[1] |
         let enumeration = $e->type()->cast(@Enumeration<Any>);
         let javaType    = $conventions->pureTypeToJavaType($enumeration, PureOne);
         $javaType->j_field($e.name, $javaType);
      }
   ])
}

function meta::java::generation::convention::identifier(conventions: Conventions[1], name: String[1]):String[1]
{
   $conventions.identifierFactory->eval($name);
}

function meta::java::generation::convention::className(conventions: Conventions[1], pe:PackageableElement[1]): meta::java::metamodel::Class[1]
{
   if($pe->instanceOf(Type) && $conventions->isProvidedType($pe->cast(@Type)),
      | $conventions->getProvidedType($pe->cast(@Type)),
      | $conventions->generateClassName($pe, 'app', '')
   );
}

function meta::java::generation::convention::implClassName(conventions: Conventions[1], pe:PackageableElement[1]): meta::java::metamodel::Class[1]
{
   $conventions->generateClassName($pe, 'internal', '_Impl');
}

function <<access.private>> meta::java::generation::convention::generateClassName(conventions:Conventions[1], pe:PackageableElement[1], zone:String[1], suffix:String[1]): meta::java::metamodel::Class[1]
{
   assert(!$pe->instanceOf(Type) || !$conventions->isProvidedType($pe->cast(@Type)), 'Cannot provide implemention for provided types');
   assert($pe != Function, 'Cannot handle function, should use pureTypeToJavaType with generic type');
 
   let zoneRoot    = $conventions.basePackageName + '.' + $zone + '.';
   let package     = if($pe->instanceOf(meta::pure::mapping::MappingClass), | $pe->cast(@meta::pure::mapping::MappingClass<Any>).generalizations.general->cast(@GenericType).rawType->cast(@Class<Any>).package->toOne(), | $pe.package->toOne());
   let javaPkgName = $zoneRoot + $conventions->identifier($package->elementToPath()->replace('::', '.'));
   if($pe->instanceOf(Enumeration),
      | javaEnum(javaPackage($javaPkgName), $pe.name->toUpperFirstCharacter()->toOne() + $suffix),
      | let className = $pe.name->toOne()->sanitizeIdentifier()->toUpperFirstCharacter()->toOne();
        javaClass(javaPackage($javaPkgName), $className + $suffix);
   );
}

function meta::java::generation::convention::functionSignature(conventions: Conventions[1], cfd:ConcreteFunctionDefinition<Any>[1]): FunctionSignature[1]
{
   $conventions.functionSignatureFactory->eval($cfd, $conventions);
}

function meta::java::generation::convention::codeParseInteger(conventions: Conventions[1], toParse:Code[1]): Code[1]
{
   let intType = $conventions->integerType()->toBoxed();
   if($intType == javaInt()->toBoxed(),
      | javaInt()->toBoxed()->j_invoke('parseInt', $toParse),
      |
   if($intType == javaLong()->toBoxed(),
      | javaLong()->toBoxed()->j_invoke('parseLong', $toParse),
      | fail('Unsupported Integer type: '+$intType->typePathToString(true)); j_null();
   ));
}

function meta::java::generation::convention::codeParseDecimal(conventions: Conventions[1], toParse:Code[1]): Code[1]
{
   let decimalType = $conventions->decimalType()->toBoxed();

   if($decimalType == javaBigDecimal(),
      | javaBigDecimal()->j_new(j_conditional($toParse->j_invoke('endsWith', j_string('D'))->j_or($toParse->j_invoke('endsWith', j_string('d'))), $toParse->j_invoke('substring', [j_int(0), $toParse->j_invoke('length', [])->j_minus(j_int(1))]), $toParse)),
      | fail('Unsupported Decimal type: '+$decimalType->typePathToString(true)); j_null();
   );
}

function meta::java::generation::convention::codeParseFloat(conventions: Conventions[1], toParse:Code[1]): Code[1]
{
   let floatType = $conventions->floatType()->toBoxed();
   if($floatType == javaFloat()->toBoxed(),
      | javaFloat()->toBoxed()->j_invoke('parseFloat', $toParse),
      |
   if($floatType == javaDouble()->toBoxed(),
      | javaDouble()->toBoxed()->j_invoke('parseDouble', $toParse),
      | fail('Unsupported Float type: '+$floatType->typePathToString(true)); j_null();
   ));
}

function meta::java::generation::convention::codeParseBoolean(conventions: Conventions[1], toParse:Code[1]): Code[1]
{
   javaBooleanBoxed()->j_invoke('parseBoolean', $toParse);
}

function meta::java::generation::convention::codeType(conventions: Conventions[1], javaType:meta::java::metamodel::Type[1]): Code[1]
{
   let code = $javaType->match([
      {p:meta::java::metamodel::PrimitiveType[1]     | $p.simpleName},
      {a:meta::java::metamodel::Array[1]             | $conventions->codeType($a.rawType)->codeToString($conventions) + '[]'},
      {p:meta::java::metamodel::ParameterizedType[1] | $conventions->codeType($p.rawType)->codeToString($conventions)+'<'+$p.typeArguments->map(t|$conventions->codeType($t)->codeToString($conventions))->makeString(', ')+'>'},
      {t:meta::java::metamodel::TypeVariable[1]      | $t.name},
      {c:meta::java::metamodel::Class[1] |
         let imported       = $conventions->isImported($c);
         let prefix         = if($imported, |'', |$c.package->packageToString()+'.');
         let res            = $prefix+$c.simpleName;
         if($res=='java.lang.Void' || $res=='Void',|'void',|$res);
      }
   ]);

   j_code($code, $javaType);
}

function meta::java::generation::convention::codeClass(conventions:Conventions[1], type:Type[1], purpose:Any[1], debug:DebugContext[1]): meta::java::metamodel::Class[1]
{
   $conventions.classCoders->get($purpose)->toOne()->eval($type, $conventions, $debug);
}

function meta::java::generation::convention::getFunctionCoder(conventions:Conventions[1], pureFunction:Function<Any>[1]): Function<{FunctionExpression[1],Conventions[1],DebugContext[1]->Code[1]}>[0..1]
{
   let name = $pureFunction.name->toOne();
   if($conventions->isProhibitedFunction($pureFunction),
      | [],
      {|
         // TODO Remove conventions FunctionCoders
         $conventions.libraries->map(l|$l.functionCoders->get($name))->match([
            {f0: Function<{FunctionExpression[1],Conventions[1],DebugContext[1]->Code[1]}>[0] | $conventions.functionCoders->get($name)},
            {f : Function<{FunctionExpression[1],Conventions[1],DebugContext[1]->Code[1]}>[1] | $f},
            {fs: Function<{FunctionExpression[1],Conventions[1],DebugContext[1]->Code[1]}>[*] | fail('Too many function coders for ' + $name); [];}
         ]);
      }
   );
}

function meta::java::generation::convention::isProhibitedFunction(conventions: Conventions[1], pureFunction:Function<Any>[1]): Boolean[1]
{
   $conventions.prohibitedFunctionStrategy->eval($conventions, $pureFunction);
}

function meta::java::generation::convention::standardImports(conventions: Conventions[1]): meta::java::metamodel::Importable[*]
{
   let packages = [javaPackage('java.util'), javaPackage('java.util.stream'), javaPackage('java.util.function')]
      ->concatenate($conventions->definedPackages().package)
      ->concatenate($conventions.libraries.javaPackagesUsed)
      ->removeDuplicates();
   let classes  = $conventions.libraries.javaClassesUsed->removeDuplicates()->filter(c| !$c.package->in($packages));
   $packages->concatenate($classes)->cast(@meta::java::metamodel::Importable);
}

function meta::java::generation::convention::knownPackages(conventions: Conventions[1]): Function<{meta::java::metamodel::Package[1]->meta::java::generation::utils::KnownPackage[1]}>[1]
{
   {pkg: meta::java::metamodel::Package[1]|
      let defined = $conventions->definedPackages()->filter(dp| $dp.package == $pkg);
      if($defined->isEmpty(),
         | knownPackage($pkg),
         | $defined->toOne();
      );
   }
}

function <<access.private>> meta::java::generation::convention::definedPackages(conventions: Conventions[1]): meta::java::generation::utils::KnownPackage[*]
{
   $conventions.libraries.javaClassesDefined
      ->groupBy(c| $c.package)
      ->keyValues()
      ->map(kv| ^meta::java::generation::utils::KnownPackage(package=$kv.first, classNames=$kv.second->map(cs| $cs.values.simpleName)));
}

function meta::java::generation::convention::standardDataTypeImports(conventions: Conventions[1]): meta::java::metamodel::Importable[*]
{
   let javaTypesForPureTypes = [
      $conventions->stringType(ZeroOne),
      $conventions->booleanType(ZeroOne),
      $conventions->integerType(ZeroOne),
      $conventions->floatType(ZeroOne),
      $conventions->decimalType(ZeroOne),
      $conventions->numberType(ZeroOne),
      $conventions->strictDateType(ZeroOne),
      $conventions->dateTimeType(ZeroOne),
      $conventions->dateType(ZeroOne)
   ]->cast(@meta::java::metamodel::Class);

   $conventions->standardImports()->filter(imp|$imp->match([
      p: meta::java::metamodel::Package[1] | $p == javaPackage('java.util') || $p->in($javaTypesForPureTypes.package),
      c: meta::java::metamodel::Class[1]   | $c->in($javaTypesForPureTypes)
   ]));
}

function meta::java::generation::convention::isImported(conventions: Conventions[1], javaClass: meta::java::metamodel::Class[1]): Boolean[1]
{
   $conventions.imports->contains($javaClass);
}

// ----------------------------------------------------------------------------------------------------------
// --- FunctionSignatureFactory factory methods
// ----------------------------------------------------------------------------------------------------------

function meta::java::generation::convention::defaultFunctionSignatureFactory(): Function<{ConcreteFunctionDefinition<Any>[1],Conventions[1]->FunctionSignature[1]}>[1]
{
   {cfd:ConcreteFunctionDefinition<Any>[1], conventions:Conventions[1]|
      let funcsClass = ^Class<Any>(package=$cfd.package, name=if($cfd.package->isEmpty(), |'', |$cfd.package->toOne()->elementToPath('_'))+'__Functions');
      let funcType   = $cfd->functionType();
      assert($funcType.typeParameters->isEmpty(), 'Generics not supported (function: '+$cfd->elementToPath()+')');

      let funcReturn = $conventions->pureTypeToJavaType($funcType.returnType.rawType->toOne(), $funcType.returnMultiplicity);
      let funcParams = $funcType.parameters->map(p| javaParam($conventions->pureTypeToJavaType($p.genericType, $p.multiplicity), $conventions->identifier($p.name->toOne())));

      ^FunctionSignature(
         class  = javaClass(javaPackage($conventions.basePackageName + '.functions'), 'Functions__' + if($cfd.package->isEmpty(), |'Root', |$cfd.package->toOne()->elementToPath('_'))),
         method = javaMethod($funcReturn, $conventions->identifier($cfd.name->toOne()), $funcParams)
      );
   }
}

// ----------------------------------------------------------------------------------------------------------
// --- FunctionCoder helper methods
// ----------------------------------------------------------------------------------------------------------

function meta::java::generation::convention::inlineCoder(pattern: String[1], returnType: String[1]): Function<{FunctionExpression[1],Conventions[1],DebugContext[1]->Code[1]}>[1]
{
   inlineCoder($pattern, javaType($returnType));
}

function meta::java::generation::convention::inlineCoder(pattern: String[1], returnType: meta::java::metamodel::Type[1]): Function<{FunctionExpression[1],Conventions[1],DebugContext[1]->Code[1]}>[1]
{
   {f:FunctionExpression[1], c:Conventions[1], debug:DebugContext[1] |
      let params = $f.parametersValues->evaluateAndDeactivate()->map(v|$v->generateJava($c, $debug->indent()));
      let call   = j_code(format($pattern, $params->map(p| $p->codeToString($c))), $returnType);
      merge($call->concatenate($params)->toOneMany());
   };
}

function meta::java::generation::convention::inlineCoder(patternFunc: Function<{Conventions[1]->String[1]}>[1], returnType: String[1]): Function<{FunctionExpression[1],Conventions[1],DebugContext[1]->Code[1]}>[1]
{
   inlineCoder($patternFunc, javaType($returnType));
}

function meta::java::generation::convention::inlineCoder(patternFunc: Function<{Conventions[1]->String[1]}>[1], returnType: meta::java::metamodel::Type[1]): Function<{FunctionExpression[1],Conventions[1],DebugContext[1]->Code[1]}>[1]
{
   {f:FunctionExpression[1], c:Conventions[1], debug:DebugContext[1] |
      let params  = $f.parametersValues->evaluateAndDeactivate()->map(v|$v->generateJava($c, $debug->indent()));
      let pattern = $patternFunc->eval($c);
      let call    = j_code(format($pattern, $params->map(p| $p->codeToString($c))), $returnType);
      merge($call->concatenate($params)->toOneMany());
   };
}

function meta::java::generation::convention::requires(coder: Function<{FunctionExpression[1],Conventions[1],DebugContext[1]->Code[1]}>[1], dependency: Function<{FunctionExpression[1],Conventions[1],DebugContext[1]->CodeDependency[1]}>[1]): Function<{FunctionExpression[1],Conventions[1],DebugContext[1]->Code[1]}>[1]
{
   {f:FunctionExpression[1], c:Conventions[1], debug:DebugContext[1] |
      merge([$coder->eval($f, $c, $debug), j_code('', javaType('void'), $dependency->eval($f, $c, $debug))]);
   };
}

function meta::java::generation::convention::appendToName(suffix: String[1]):Function<{PackageableElement[1],Conventions[1]->meta::java::metamodel::Class[1]}>[1]
{
   {pe:PackageableElement[1], c:Conventions[1] |
      let base = $c->className($pe);
      ^$base(simpleName=$base.simpleName+$suffix);
   };
}

// ----------------------------------------------------------------------------------------------------------
// --- Factory methods for ConventionsLibrary
// ----------------------------------------------------------------------------------------------------------

function meta::java::generation::convention::newConventionsLibrary():ConventionsLibrary[1]
{
   ^ConventionsLibrary
   (
      typeConversions = newMap(@Pair<Type, TypeConversion>),
      functionCoders  = newMap(@Pair<String, Function<{FunctionExpression[1],Conventions[1],DebugContext[1]->Code[1]}>>),
      fundamentals    = {c:Conventions[1], d:DebugContext[1] | newProject()}
   );
}

function meta::java::generation::convention::newConventionsLibrary(name:String[1]):ConventionsLibrary[1]
{
   let lib = newConventionsLibrary();
   ^$lib(name=$name);
}

function meta::java::generation::convention::setFundamentals(library:ConventionsLibrary[1], fundamentals:Function<{Conventions[1],DebugContext[1]->Project[1]}>[1]): ConventionsLibrary[1]
{
   ^$library(fundamentals=$fundamentals);
}

function meta::java::generation::convention::usesJavaPackage(library:ConventionsLibrary[1], javaPackage:String[1]): ConventionsLibrary[1]
{
   $library->usesJavaPackage(javaPackage($javaPackage));
}

function meta::java::generation::convention::usesJavaPackage(library:ConventionsLibrary[1], javaPackage:meta::java::metamodel::Package[1]): ConventionsLibrary[1]
{
   // Ensure package is well known
   knownPackage($javaPackage);
   ^$library(javaPackagesUsed=$library.javaPackagesUsed->concatenate($javaPackage)->removeDuplicates());
}

function meta::java::generation::convention::usesJavaClass(library:ConventionsLibrary[1], javaClass:String[1]): ConventionsLibrary[1]
{
   $library->usesJavaClass(javaClass($javaClass));
}

function meta::java::generation::convention::usesJavaClass(library:ConventionsLibrary[1], javaClass:meta::java::metamodel::Class[1]): ConventionsLibrary[1]
{
   ^$library(javaClassesUsed=$library.javaClassesUsed->concatenate($javaClass)->removeDuplicates());
}

function meta::java::generation::convention::definesJavaClass(library:ConventionsLibrary[1], javaClass:String[1]): ConventionsLibrary[1]
{
   $library->definesJavaClass(javaClass($javaClass));
}

function meta::java::generation::convention::definesJavaClass(library:ConventionsLibrary[1], javaClass:meta::java::metamodel::Class[1]): ConventionsLibrary[1]
{
   ^$library(javaClassesDefined=$library.javaClassesDefined->concatenate($javaClass)->removeDuplicates());
}

function meta::java::generation::convention::usesString(library:ConventionsLibrary[1], oneJavaType:meta::java::metamodel::Type[1], nonOneJavaType:meta::java::metamodel::Type[1], literalCoder:Function<{String[1]->Code[1]}>[1]): ConventionsLibrary[1]
{
   let typeCoder = ^TypeConversion
   (
      type           = String,
      oneJavaType    = $oneJavaType,
      nonOneJavaType = $nonOneJavaType,
      literalCoder   = {a:Any[1]| $literalCoder->eval($a->cast(@String))}
   );

   ^$library(typeConversions=$library.typeConversions->put(String, $typeCoder));
}

function meta::java::generation::convention::usesInteger(library:ConventionsLibrary[1], oneJavaType:meta::java::metamodel::Type[1], nonOneJavaType:meta::java::metamodel::Type[1], literalCoder:Function<{Integer[1]->Code[1]}>[1]): ConventionsLibrary[1]
{
   let typeCoder = ^TypeConversion
   (
      type           = Integer,
      oneJavaType    = $oneJavaType,
      nonOneJavaType = $nonOneJavaType,
      literalCoder   = {a:Any[1]| $literalCoder->eval($a->cast(@Integer))}
   );

   ^$library(typeConversions=$library.typeConversions->put(Integer, $typeCoder));
}

function meta::java::generation::convention::usesFloat(library:ConventionsLibrary[1], oneJavaType:meta::java::metamodel::Type[1], nonOneJavaType:meta::java::metamodel::Type[1], literalCoder:Function<{Float[1]->Code[1]}>[1]): ConventionsLibrary[1]
{
   let typeCoder = ^TypeConversion
   (
      type           = Float,
      oneJavaType    = $oneJavaType,
      nonOneJavaType = $nonOneJavaType,
      literalCoder   = {a:Any[1]| $literalCoder->eval($a->cast(@Float))}
   );

   ^$library(typeConversions=$library.typeConversions->put(Float, $typeCoder));
}

function meta::java::generation::convention::usesDecimal(library:ConventionsLibrary[1], oneJavaType:meta::java::metamodel::Type[1], nonOneJavaType:meta::java::metamodel::Type[1], literalCoder:Function<{Decimal[1]->Code[1]}>[1]): ConventionsLibrary[1]
{
   let typeCoder = ^TypeConversion
   (
      type           = Decimal,
      oneJavaType    = $oneJavaType,
      nonOneJavaType = $nonOneJavaType,
      literalCoder   = {a:Any[1]| $literalCoder->eval($a->cast(@Decimal))}
   );

   ^$library(typeConversions=$library.typeConversions->put(Decimal, $typeCoder));
}

function meta::java::generation::convention::usesNumber(library:ConventionsLibrary[1], oneJavaType:meta::java::metamodel::Type[1], nonOneJavaType:meta::java::metamodel::Type[1], literalCoder:Function<{Number[1]->Code[1]}>[1]): ConventionsLibrary[1]
{
   let typeCoder = ^TypeConversion
   (
      type           = Number,
      oneJavaType    = $oneJavaType,
      nonOneJavaType = $nonOneJavaType,
      literalCoder   = {a:Any[1]| $literalCoder->eval($a->cast(@Number))}
   );

   ^$library(typeConversions=$library.typeConversions->put(Number, $typeCoder));
}

function meta::java::generation::convention::usesBoolean(library:ConventionsLibrary[1], oneJavaType:meta::java::metamodel::Type[1], nonOneJavaType:meta::java::metamodel::Type[1], literalCoder:Function<{Boolean[1]->Code[1]}>[1]):ConventionsLibrary[1]
{
   let typeCoder = ^TypeConversion
   (
      type           = Boolean,
      oneJavaType    = $oneJavaType,
      nonOneJavaType = $nonOneJavaType,
      literalCoder   = {a:Any[1]| $literalCoder->eval($a->cast(@Boolean))}
   );

   ^$library(typeConversions=$library.typeConversions->put(Boolean, $typeCoder));
}

function meta::java::generation::convention::usesStrictDate(library:ConventionsLibrary[1], javaType:meta::java::metamodel::Type[1], literalCoder:Function<{StrictDate[1]->Code[1]}>[1]): ConventionsLibrary[1]
{
   let typeCoder = ^TypeConversion
   (
      type           = StrictDate,
      oneJavaType    = $javaType,
      nonOneJavaType = $javaType,
      literalCoder   = {a:Any[1]| $literalCoder->eval($a->cast(@StrictDate))}
   );

   ^$library(typeConversions=$library.typeConversions->put(StrictDate, $typeCoder));
}

function meta::java::generation::convention::usesDateTime(library:ConventionsLibrary[1], javaType:meta::java::metamodel::Type[1], literalCoder:Function<{DateTime[1]->Code[1]}>[1]): ConventionsLibrary[1]
{
   let typeCoder = ^TypeConversion
   (
      type           = DateTime,
      oneJavaType    = $javaType,
      nonOneJavaType = $javaType,
      literalCoder   = {a:Any[1]| $literalCoder->eval($a->cast(@DateTime))}
   );

   ^$library(typeConversions=$library.typeConversions->put(DateTime, $typeCoder));
}

function meta::java::generation::convention::usesDate(library:ConventionsLibrary[1], javaType:meta::java::metamodel::Type[1], literalCoder:Function<{Date[1]->Code[1]}>[1]): ConventionsLibrary[1]
{
   let typeCoder = ^TypeConversion
   (
      type           = Date,
      oneJavaType    = $javaType,
      nonOneJavaType = $javaType,
      literalCoder   = {a:Any[1]| $literalCoder->eval($a->cast(@Date))}
   );

   ^$library(typeConversions=$library.typeConversions->put(Date, $typeCoder));
}

// ----------------------------------------------------------------------------------------------------------
// --- Function Coders
// ----------------------------------------------------------------------------------------------------------

Class meta::java::generation::convention::FuncCoderContext
{
   fe          : FunctionExpression[1];
   params      : ValueSpecification[*];
   paramNames  : String[*];
   paramCodes  : Code[*];
   conventions : Conventions[1];
   debug       : DebugContext[1];

   param(name:String[1])
   {
      $this.paramCodes->at($this.paramNames->indexOf($name));
   }:Code[1];

   returnType()
   {
      $this.conventions->pureTypeToJavaType($this.fe.genericType.rawType->toOne(), $this.fe.multiplicity);
   }:meta::java::metamodel::Type[1];
}

Class meta::java::generation::convention::FunctionCoder
{
   pureFunction : String[1];
   coder        : Function<{FunctionExpression[1],Conventions[1],DebugContext[1]->Code[1]}>[1];
}

function meta::java::generation::convention::fc0(pureFunction:Function<Any>[1], coder2:Function<{FuncCoderContext[1]->Code[1]}>[1]): FunctionCoder[1]
{
   fc0($pureFunction.name->toOne(), $coder2);
}

function meta::java::generation::convention::fc0(pureFunction:String[1], coder2:Function<{FuncCoderContext[1]->Code[1]}>[1]): FunctionCoder[1]
{
   fc($pureFunction, adaptCoder($coder2->cast(@FunctionDefinition<Any>)));
}

function meta::java::generation::convention::fc1(pureFunction:Function<Any>[1], coder2:Function<{FuncCoderContext[1],Code[1]->Code[1]}>[1]): FunctionCoder[1]
{
   fc1($pureFunction.name->toOne(), $coder2);
}

function meta::java::generation::convention::fc1(pureFunction:String[1], coder2:Function<{FuncCoderContext[1],Code[1]->Code[1]}>[1]): FunctionCoder[1]
{
   fc($pureFunction, adaptCoder($coder2->cast(@FunctionDefinition<Any>)));
}

function meta::java::generation::convention::fc2(pureFunction:Function<Any>[1], coder2:Function<{FuncCoderContext[1],Code[1],Code[1]->Code[1]}>[1]): FunctionCoder[1]
{
   fc2($pureFunction.name->toOne(), $coder2);
}

function meta::java::generation::convention::fc2(pureFunction:String[1], coder2:Function<{FuncCoderContext[1],Code[1],Code[1]->Code[1]}>[1]): FunctionCoder[1]
{
   fc($pureFunction, adaptCoder($coder2->cast(@FunctionDefinition<Any>)));
}

function meta::java::generation::convention::fc3(pureFunction:Function<Any>[1], coder3:Function<{FuncCoderContext[1],Code[1],Code[1],Code[1]->Code[1]}>[1]): FunctionCoder[1]
{
   fc3($pureFunction.name->toOne(), $coder3);
}

function meta::java::generation::convention::fc3(pureFunction:String[1], coder3:Function<{FuncCoderContext[1],Code[1],Code[1],Code[1]->Code[1]}>[1]): FunctionCoder[1]
{
   fc($pureFunction, adaptCoder($coder3->cast(@FunctionDefinition<Any>)));
}

function meta::java::generation::convention::fc4(pureFunction:Function<Any>[1], coder3:Function<{FuncCoderContext[1],Code[1],Code[1],Code[1],Code[1]->Code[1]}>[1]): FunctionCoder[1]
{
   fc4($pureFunction.name->toOne(), $coder3);
}

function meta::java::generation::convention::fc4(pureFunction:String[1], coder3:Function<{FuncCoderContext[1],Code[1],Code[1],Code[1],Code[1]->Code[1]}>[1]): FunctionCoder[1]
{
   fc($pureFunction, adaptCoder($coder3->cast(@FunctionDefinition<Any>)));
}

function meta::java::generation::convention::fc5(pureFunction:Function<Any>[1], coder5:Function<{FuncCoderContext[1],Code[1],Code[1],Code[1],Code[1],Code[1]->Code[1]}>[1]): FunctionCoder[1]
{
   fc5($pureFunction.name->toOne(), $coder5);
}

function meta::java::generation::convention::fc5(pureFunction:String[1], coder5:Function<{FuncCoderContext[1],Code[1],Code[1],Code[1],Code[1],Code[1]->Code[1]}>[1]): FunctionCoder[1]
{
   fc($pureFunction, adaptCoder($coder5->cast(@FunctionDefinition<Any>)));
}

function meta::java::generation::convention::fc6(pureFunction:Function<Any>[1], coder6:Function<{FuncCoderContext[1],Code[1],Code[1],Code[1],Code[1],Code[1],Code[1]->Code[1]}>[1]): FunctionCoder[1]
{
   fc6($pureFunction.name->toOne(), $coder6);
}

function meta::java::generation::convention::fc6(pureFunction:String[1], coder6:Function<{FuncCoderContext[1],Code[1],Code[1],Code[1],Code[1],Code[1],Code[1]->Code[1]}>[1]): FunctionCoder[1]
{
   fc($pureFunction, adaptCoder($coder6->cast(@FunctionDefinition<Any>)));
}

function meta::java::generation::convention::fc(pureFunction:Function<Any>[1], coder:Function<{FunctionExpression[1],Conventions[1],DebugContext[1]->Code[1]}>[1]): FunctionCoder[1]
{
   fc($pureFunction.name->toOne(), $coder);
}

function meta::java::generation::convention::fc(pureFunction:String[1], coder:Function<{FunctionExpression[1],Conventions[1],DebugContext[1]->Code[1]}>[1]): FunctionCoder[1]
{
   ^FunctionCoder(pureFunction=$pureFunction, coder=$coder);
}

function meta::java::generation::convention::fcAlias(pureFunction:Function<Any>[1]): Function<{FunctionExpression[1],Conventions[1],DebugContext[1]->Code[1]}>[1]
{
   {fe: FunctionExpression[1], conventions:Conventions[1], debug:DebugContext[1] |
      let toEval = $conventions->getFunctionCoder($pureFunction);
      assert($toEval->isNotEmpty(), |'Aliased function ('+$pureFunction.name->toOne()+') missing');
      $toEval->toOne()->eval($fe, $conventions, $debug);
   };
}

function <<access.private>> meta::java::generation::convention::adaptCoder(adaptee:FunctionDefinition<Any>[1]): Function<{FunctionExpression[1],Conventions[1],DebugContext[1]->Code[1]}>[1]
{
   let fType = $adaptee->evaluateAndDeactivate()->functionType();
   assert($fType.returnType.rawType == Code, 'Must return Code');
   assert($fType.parameters->at(0).genericType.rawType == FuncCoderContext, 'First parameter must be a FuncCoderContext');
   assert($fType.parameters->tail()->forAll(p| $p.genericType.rawType == Code), 'Second and subsequent parameters must be Code');

   let codeParamNames = $fType.parameters->tail().name;

   {fe: FunctionExpression[1], conventions:Conventions[1], debug:DebugContext[1] |
      let params = $fe.parametersValues->evaluateAndDeactivate();
      let paramCodes = $codeParamNames->fold(
         {name, a|
            let l = $a.first;
            let n = $a.second;
            print(if($debug.debug,|$debug.space+' - '+$name+' - param('+$n->toString()+')\n', |''));
            let code = $params->at($n)->generateJava($conventions, $debug->indent());
            pair(list($l.values->add($code)), $n+1);
         },
         pair(^List<Code>(), 0)
      ).first.values;

      let ctx = ^FuncCoderContext(
         fe          = $fe,
         params      = $params,
         paramNames  = $codeParamNames,
         paramCodes  = $paramCodes,
         conventions = $conventions,
         debug       = $debug
      );

      let args = list($ctx)->concatenate($paramCodes->map(pc|list($pc)));
      let expr = $adaptee->evaluate($args)->cast(@Code)->toOne();

      if($expr.type->isJavaStream(),
         |$expr->js_resolve($ctx.returnType()),
         |
      if($expr.type->isJavaOptional(),
         |$expr->jo_orElseNull()->j_cast($ctx.returnType()),
         |
      if($ctx.returnType->isJavaList() && !$expr.type->isJavaList(),
         |$expr->j_cast($ctx.returnType()->elementType()),
         |$expr->j_cast($ctx.returnType())
      )));
   };
}

function meta::java::generation::convention::addFunctionCoder(library:ConventionsLibrary[1], pureFunctions:Function<Any>[*], paramNames:String[*], contextCoder:Function<{FuncCoderContext[1]->Code[1]}>[1]): ConventionsLibrary[1]
{
   addFunctionCoder($library, $pureFunctions.name, $paramNames, $contextCoder);
}

function meta::java::generation::convention::addFunctionCoder(library:ConventionsLibrary[1], pureFunctions:String[*], paramNames:String[*], contextCoder:Function<{FuncCoderContext[1]->Code[1]}>[1]): ConventionsLibrary[1]
{
   let coder = {fe: FunctionExpression[1], conventions:Conventions[1], debug:DebugContext[1] |
      let params = $fe.parametersValues->evaluateAndDeactivate();

      let paramCodes = $paramNames->fold(
         {name, a|
            let l = $a.first;
            let n = $a.second;
            let code = if($name == '',
                          |j_null(),
                          {|
                             print(if($debug.debug,|$debug.space+' - '+$name+' - param('+$n->toString()+')\n', |''));
                             $params->at($n)->generateJava($conventions, $debug->indent());
                          }
                       );
            pair(list($l.values->add($code)), $n+1);
         },
         pair(^List<Code>(), 0)
      ).first.values;

      let ctx = ^FuncCoderContext(
         fe          = $fe,
         params      = $params,
         paramNames  = $paramNames,
         paramCodes  = $paramCodes,
         conventions = $conventions,
         debug       = $debug
      );

      let expr = $contextCoder->eval($ctx);
      if($expr.type->isJavaStream(), |$expr->js_resolve($ctx.returnType()), |$expr->j_cast($ctx.returnType()));
   };

   $pureFunctions->fold({f, l| $l->addFunctionCoder($f, $coder)}, $library);
}

function meta::java::generation::convention::addFunctionCoders(library:ConventionsLibrary[1], functionCoders:FunctionCoder[*]): ConventionsLibrary[1]
{
   let existingNames = $library.functionCoders->keys();
   let newNames      = $functionCoders.pureFunction;
   let duplicates    = $existingNames->intersection($newNames);
   assert($duplicates->isEmpty(), |'Function coders already exists for ' + $duplicates->joinStrings('[', ',', ']'));

   ^$library(functionCoders=$library.functionCoders->putAll($functionCoders->map(fc| pair($fc.pureFunction, $fc.coder))));
}

function meta::java::generation::convention::addFunctionCoder(library:ConventionsLibrary[1], pureFunction:Function<Any>[1], coder: Function<{FunctionExpression[1],Conventions[1],DebugContext[1]->Code[1]}>[1]): ConventionsLibrary[1]
{
   addFunctionCoder($library, $pureFunction.name->toOne(), $coder);
}

function meta::java::generation::convention::addFunctionCoder(library:ConventionsLibrary[1], pureFunction:String[1], coder: Function<{FunctionExpression[1],Conventions[1],DebugContext[1]->Code[1]}>[1]): ConventionsLibrary[1]
{
   assert($library.functionCoders->get($pureFunction)->isEmpty(), |'A function is already exists for ' + $pureFunction);
   ^$library(functionCoders=$library.functionCoders->put($pureFunction, $coder));
}

// ----------------------------------------------------------------------------------------------------------
// --- Factory methods for Conventions
// ----------------------------------------------------------------------------------------------------------

function meta::java::generation::convention::newConventions(extensions : meta::pure::router::extension::RouterExtension[*]): Conventions[1]
{
   let result = ^Conventions
   (
      fieldNameStrategy          = {p:String[1] | $p},
      getterNameStrategy         = {p:String[1] | 'get' + $p->toUpperFirstCharacter()->toOne()},
      setterNameStrategy         = {p:String[1] | 'set' + $p->toUpperFirstCharacter()->toOne()},
      defaultClassPurpose        = ClassPurpose.MODEL,

      identifierFactory          = meta::java::generation::convention::sanitizeJavaKeywords_String_1__String_1_,
      basePackageName            = '_pure',
      functionSignatureFactory   = defaultFunctionSignatureFactory(),

      classCoders                = newMap(@Pair<Any, Function<{Type[1],Conventions[1],DebugContext[1]->meta::java::metamodel::Class[1]}>>),
      functionCoders             = newMap(@Pair<String, Function<{FunctionExpression[1],Conventions[1],DebugContext[1]->Code[1]}>>),
      prohibitedFunctionStrategy = defaultProhibitedFunctions($extensions),
      providedVariables          = ^Map<String,Code>(),
      extensions = $extensions
   )
      ->addProvidedType(Any, javaObject())
      ->assumeImportedPackage('java.lang');
}

function meta::java::generation::convention::setBasePackageName(conventions:Conventions[1], name:String[1]): Conventions[1]
{
   assert($name->isValidPackageName(), 'Not a valid base package');
   ^$conventions(basePackageName=$name);
}

function meta::java::generation::convention::addProvidedType(conventions:Conventions[1], type:Type[1], providedAs:String[1]): Conventions[1]
{
   $conventions->addProvidedType($type, javaClass($providedAs));
}

function meta::java::generation::convention::addProvidedType(conventions:Conventions[1], type:Type[1], providedAs:meta::java::metamodel::Class[1]): Conventions[1]
{
   let cleaned = $conventions.providedTypes->filter(pt | $pt.type != $type);
   ^$conventions(providedTypes=$cleaned->add(^ProvidedType(type=$type, providedAs=$providedAs)));
}

function meta::java::generation::convention::addProvidedVariables(conventions:Conventions[1], codes:Code[*]): Conventions[1]
{
   assert($codes->forAll(c|$c->isVariable()));
   let namesToCodes = $codes->map(c|pair($c->variableName(), $c));
   ^$conventions(providedVariables=$conventions.providedVariables->putAll($namesToCodes));
}

function meta::java::generation::convention::assumeImported(conventions: Conventions[1], javaClass: String[1]): Conventions[1]
{
   assumeImported($conventions, javaClass($javaClass))
}

function meta::java::generation::convention::assumeImported(conventions: Conventions[1], javaClass: meta::java::metamodel::Class[1]): Conventions[1]
{
   ^$conventions(imports=$conventions.imports->concatenate($javaClass))
}

function meta::java::generation::convention::assumeImportedPackage(conventions: Conventions[1], pkg: String[1]): Conventions[1]
{
   let knownPackages = $conventions->knownPackages();
   $knownPackages->eval(javaPackage($pkg)).classNames->fold({className, conv| $conv->assumeImported($pkg+'.'+$className)}, $conventions);
}

function meta::java::generation::convention::registerClassCoder(conventions: Conventions[1], purpose: Any[1], coder: Function<{Type[1],Conventions[1],DebugContext[1]->meta::java::metamodel::Class[1]}>[1]): Conventions[1]
{
   ^$conventions(classCoders=$conventions.classCoders->put($purpose, $coder));
}

function meta::java::generation::convention::registerFunctionCoder(conventions: Conventions[1], pureFunction: Function<Any>[1], coder: Function<{FunctionExpression[1],Conventions[1],DebugContext[1]->Code[1]}>[1]): Conventions[1]
{
   registerFunctionCoder($conventions, $pureFunction.name->toOne(), $coder);
}

function meta::java::generation::convention::registerFunctionCoder(conventions: Conventions[1], pureFunction: String[1], coder: Function<{FunctionExpression[1],Conventions[1],DebugContext[1]->Code[1]}>[1]): Conventions[1]
{
   assert($conventions.functionCoders->get($pureFunction)->isEmpty(), |'A function is already registered for ' + $pureFunction);
   ^$conventions(functionCoders=$conventions.functionCoders->put($pureFunction, $coder));
}

function meta::java::generation::convention::registerLibrary(conventions: Conventions[1], library: ConventionsLibrary[1]): Conventions[1]
{
   let stillValidLibraries = $conventions.libraries
      ->filter(
         {l|
            $l.typeConversions->values()->forAll(
               {tc|
                  let newTypeConversion = $library.typeConversions->get($tc.type);
                  $newTypeConversion->isEmpty() || ($newTypeConversion.oneJavaType == $tc.oneJavaType && $newTypeConversion.nonOneJavaType == $tc.nonOneJavaType);
               }
            )
         }
      )
      ->filter(l| $library.name->isEmpty() || $library.name != $l.name);

   ^$conventions(libraries=$stillValidLibraries->concatenate($library));
}

function meta::java::generation::convention::forClass(conventions:Conventions[1], class:meta::java::metamodel::Class[1]): Conventions[1]
{
   $class.additionalImports->fold({imp,conv|
      if($imp->endsWith('.*'),
         |$conv->assumeImportedPackage($imp->substring(0, $imp->length()-2)),
         |$conv->assumeImported(javaClass($imp))
      )

   }, $conventions);
}

function meta::java::generation::convention::defaultProhibitedFunctions(extensions : meta::pure::router::extension::RouterExtension[*]): Function<{Conventions[1],Function<Any>[1]->Boolean[1]}>[1]
{
   let functionsBlacklist = [
      // Instances
      copy_T_1__String_1__KeyExpression_MANY__T_1_,
      copy_T_1__String_1__T_1_,
      dynamicNew_Class_1__KeyValue_MANY__Any_1_,
      dynamicNew_Class_1__KeyValue_MANY__Function_$0_1$__Function_$0_1$__Any_$0_1$__Any_1_,
      dynamicNew_Class_1__KeyValue_MANY__Function_$0_1$__Function_$0_1$__Any_$0_1$__Function_$0_1$__Any_1_,
      dynamicNew_GenericType_1__KeyValue_MANY__Any_1_,
      dynamicNew_GenericType_1__KeyValue_MANY__Function_$0_1$__Function_$0_1$__Any_$0_1$__Any_1_,
      dynamicNew_GenericType_1__KeyValue_MANY__Function_$0_1$__Function_$0_1$__Any_$0_1$__Function_$0_1$__Any_1_,
      mayRemoveOverride_T_$0_1$__T_$0_1$_,
      mutateAdd_T_1__String_1__Any_MANY__T_1_,
      removeOverride_T_1__T_1_,

      // PURE Implementation
      canReactivateDynamically_ValueSpecification_1__Boolean_1_,
      compileValueSpecification_String_m__CompilationResult_m_,
      deactivate_Any_MANY__ValueSpecification_1_,
      evaluateAndDeactivate_T_m__T_m_,
      meta::alloy::test::mayExecuteAlloyTest_Function_1__Function_1__X_k_,
      meta::legend::test::mayExecuteLegendTest_Function_1__Function_1__X_k_,

      // Evaluation
      eval_Function_1__S_n__T_o__U_p__W_q__X_r__Y_s__Z_t__V_m_,
      eval_Function_1__T_n__U_p__V_m_,
      eval_Function_1__T_n__U_p__W_q__V_m_,
      eval_Function_1__T_n__U_p__W_q__X_r__V_m_,
      eval_Function_1__T_n__U_p__W_q__X_r__Y_s__V_m_,
      eval_Function_1__T_n__U_p__W_q__X_r__Y_s__Z_t__V_m_,
      eval_Function_1__T_n__V_m_,
      eval_Function_1__V_m_,
      evaluate_Function_1__List_MANY__Any_MANY_,
      rawEvalProperty_Property_1__Any_1__V_m_,

      // Maps
      groupBy_X_MANY__Function_1__Map_1_,
      get_Map_1__U_1__V_$0_1$_,
      getIfAbsentPutWithKey_Map_1__U_1__Function_1__V_$0_1$_,
      getMapStats_Map_1__MapStats_$0_1$_,
      keys_Map_1__U_MANY_,
      keyValues_Map_1__Pair_MANY_,
      merge_Map_1__Map_1__Map_1_,
      newMap_Pair_MANY__Map_1_,
      newMap_Pair_MANY__Property_MANY__Map_1_,
      newMultiValueMap_Pair_MANY__Map_1_,
      put_Map_1__U_1__V_1__Map_1_,
      putAll_Map_1__Map_1__Map_1_,
      putAll_Map_1__Pair_MANY__Map_1_,
      replaceAll_Map_1__Pair_MANY__Map_1_,
      values_Map_1__V_MANY_,

      // Meta
      getAll_Class_1__T_MANY_,

      // Infrastructure
      meta::pure::functions::cipher::decrypt_String_1__String_1__String_1_,
      meta::pure::functions::cipher::encrypt_Boolean_1__String_1__String_1_,
      meta::pure::functions::cipher::encrypt_Number_1__String_1__String_1_,
      meta::pure::functions::cipher::encrypt_String_1__String_1__String_1_,
      meta::vcs::metamodel::versionHistory_String_MANY__Revision_MANY_,
      profile_T_m__Boolean_1__ProfileResult_1_,
      readFile_String_1__String_$0_1$_,
      
      meta::json::escape_String_1__String_1_,
      meta::json::fromJsonDeprecated_String_1__Class_1__JSONDeserializationConfig_1__T_1_,
      meta::json::fromJson_String_1__Class_1__JSONDeserializationConfig_1__T_1_,
      meta::json::parseJSON_String_1__JSONElement_1_,
      meta::json::toJsonBeta_Any_MANY__JSONSerializationConfig_1__String_1_

      
   ]->concatenate($extensions.java_conventions_defaultProhibitedFunctions);

   let manipulatesPackagesBlacklist = [
      'meta::pure::codestore',
      'meta::pure::deepfetch',
      'meta::pure::diagram',
      'meta::pure::executionPlan',
      'meta::pure::functions::io',
      'meta::pure::functions::lang',
      'meta::pure::functions::meta',
      'meta::pure::functions::tools',
      'meta::pure::generation',
      'meta::pure::graphFetch',
      'meta::pure::lineage',
      'meta::pure::mapping',
      'meta::pure::metamodel',
      'meta::pure::migration',
      'meta::pure::milestoning',
      'meta::pure::router',
      'meta::pure::runtime',
      'meta::pure::service',
      'meta::pure::store',
      'meta::pure::tools',
      'meta::pure::transition',
      'meta::pure::versioning'
   ];

   let manipulatesTypesWhitelist = [
      Any,
      Enumeration,
      Enum,
      Measure,
      Nil,
      Unit,
      Function,
      meta::pure::graphFetch::RootGraphFetchTree
   ];

   {conventions:Conventions[1],func:Function<Any>[1]|
      $func->match([
         {nf:NativeFunction<Any>[1]     | $func->in($functionsBlacklist);},
         {fd:FunctionDefinition<Any>[1] |
            if($func->in($functionsBlacklist),
               | true,
               {|
                  let funcType = $func->evaluateAndDeactivate()->functionType();
                  let types    = $funcType.returnType.rawType->concatenate($funcType.parameters.genericType.rawType);
                  let usesPkgs = $types->filter(t| !$t->in($manipulatesTypesWhitelist) && $t->instanceOf(PackageableElement))->cast(@PackageableElement).package;
                  $usesPkgs->exists({p|
                     let name = $p->elementToPath();
                     $manipulatesPackagesBlacklist->exists(b|$name->startsWith($b));
                  });
               }
            );
         }
      ]);
   };
}

// ----------------------------------------------------------------------------------------------------------
// --- Helpers
// ----------------------------------------------------------------------------------------------------------

function <<access.private>> meta::java::generation::convention::listIfMulti(base: meta::java::metamodel::Type[1], mult:Multiplicity[1]): meta::java::metamodel::Type[1]
{
   if(!$mult->hasUpperBound() || ($mult->getUpperBound() > 1 || $mult->getUpperBound() == -1),
      | javaList($base),
      | $base
   );
}

function <<access.private>> meta::java::generation::convention::typeConversion(conventions:Conventions[1], type:Type[1]): TypeConversion[1]
{
   $conventions.libraries->map(l|$l.typeConversions->get($type))->at(0);
}

function meta::java::generation::convention::javaType(conventions:Conventions[1], type:Type[1], mult:Multiplicity[1]): meta::java::metamodel::Type[1]
{
   let conversion = $conventions->typeConversion($type);
   if($mult == PureOne, |$conversion.oneJavaType, |$conversion.nonOneJavaType)->listIfMulti($mult);
}

function meta::java::generation::convention::sanitizeIdentifier(name: String[1]): String[1]
{
   $name->sanitizeJavaKeywords()->replaceIllegalSymbols();
}

function <<access.private>> meta::java::generation::convention::replaceIllegalSymbols(symbol: String[1]): String[1]
{
   $symbol->replace('~', '_Tilde_');
}

function <<access.private>> meta::java::generation::convention::sanitizeJavaKeywords(name: String[1]): String[1]
{
   $name
      ->split('.')
      ->map(p|if(javaKeywords()->contains($p) || ($p->startsWithNumber()), | '_' + $p, | $p))
      ->map(p|if($p == '_', | '__', | $p))
      ->joinStrings('.');
}

function <<access.private>> meta::java::generation::convention::startsWithNumber(s: String[1]): Boolean[1]
{
   ['0','1','2','3','4','5','6','7','8','9']->contains($s->substring(0, 1))
}
