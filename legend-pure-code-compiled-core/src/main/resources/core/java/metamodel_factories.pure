// Copyright 2020 Goldman Sachs
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import meta::java::generation::code::*;
import meta::java::metamodel::project::*;
import meta::java::generation::utils::*;
import meta::java::metamodel::factory::*;
import meta::java::serialization::*;

function meta::java::metamodel::factory::javaIllegalArgumentException():      meta::java::metamodel::Class[1] { javaClass('java.lang.IllegalArgumentException'); }
function meta::java::metamodel::factory::javaIllegalStateException():         meta::java::metamodel::Class[1] { javaClass('java.lang.IllegalStateException'); }
function meta::java::metamodel::factory::javaIllegalAccessException():        meta::java::metamodel::Class[1] { javaClass('java.lang.IllegalAccessException'); }
function meta::java::metamodel::factory::javaNumberFormatException():         meta::java::metamodel::Class[1] { javaClass('java.lang.NumberFormatException'); }
function meta::java::metamodel::factory::javaRuntimeException():              meta::java::metamodel::Class[1] { javaClass('java.lang.RuntimeException'); }
function meta::java::metamodel::factory::javaUnsupportedOperationException(): meta::java::metamodel::Class[1] { javaClass('java.lang.UnsupportedOperationException'); }
function meta::java::metamodel::factory::javaCharSequence():                  meta::java::metamodel::Class[1] { javaClass('java.lang.CharSequence'); }
function meta::java::metamodel::factory::javaMath():                          meta::java::metamodel::Class[1] { javaClass('java.lang.Math'); }
function meta::java::metamodel::factory::javaSystem():                        meta::java::metamodel::Class[1] { javaClass('java.lang.System'); }
function meta::java::metamodel::factory::javaStringBuilder():                 meta::java::metamodel::Class[1] { javaClass('java.lang.StringBuilder'); }
function meta::java::metamodel::factory::javaAppendable():                    meta::java::metamodel::Class[1] { javaClass('java.lang.Appendable'); }
function meta::java::metamodel::factory::javaClassType():                     meta::java::metamodel::Class[1] { javaClass('java.lang.Class'); }

function meta::java::metamodel::factory::javaReflectType():           meta::java::metamodel::Class[1] { javaClass('java.lang.reflect.Type'); }
function meta::java::metamodel::factory::javaReflectMethod():         meta::java::metamodel::Class[1] { javaClass('java.lang.reflect.Method'); }
function meta::java::metamodel::factory::javaInvocationTargetException():         meta::java::metamodel::Class[1] { javaClass('java.lang.reflect.InvocationTargetException'); }

function meta::java::metamodel::factory::javaMathContext():           meta::java::metamodel::Class[1] { javaClass('java.math.MathContext'); }
function meta::java::metamodel::factory::javaRoundingMode():          meta::java::metamodel::Class[1] { javaClass('java.math.RoundingMode'); }

function meta::java::metamodel::factory::javaIOException():           meta::java::metamodel::Class[1] { javaClass('java.io.IOException'); }
function meta::java::metamodel::factory::javaBufferedInputStream():   meta::java::metamodel::Class[1] { javaClass('java.io.BufferedInputStream'); }
function meta::java::metamodel::factory::javaByteArrayOutputStream(): meta::java::metamodel::Class[1] { javaClass('java.io.ByteArrayOutputStream'); }
function meta::java::metamodel::factory::javaInputStreamReader():     meta::java::metamodel::Class[1] { javaClass('java.io.InputStreamReader'); }
function meta::java::metamodel::factory::javaPrintStream():           meta::java::metamodel::Class[1] { javaClass('java.io.PrintStream'); }
function meta::java::metamodel::factory::javaStringWriter():          meta::java::metamodel::Class[1] { javaClass('java.io.StringWriter'); }
function meta::java::metamodel::factory::javaSerializable():          meta::java::metamodel::Class[1] { javaClass('java.io.Serializable'); }

function meta::java::metamodel::factory::javaURL():  meta::java::metamodel::Class[1] { javaClass('java.net.URL'); }

function meta::java::metamodel::factory::javaNoSuchElementException(): meta::java::metamodel::Class[1] { javaClass('java.util.NoSuchElementException'); }
function meta::java::metamodel::factory::javaArrays():                 meta::java::metamodel::Class[1] { javaClass('java.util.Arrays'); }
function meta::java::metamodel::factory::javaCollections():            meta::java::metamodel::Class[1] { javaClass('java.util.Collections'); }
function meta::java::metamodel::factory::javaLocale():                 meta::java::metamodel::Class[1] { javaClass('java.util.Locale'); }
function meta::java::metamodel::factory::javaObjects():                meta::java::metamodel::Class[1] { javaClass('java.util.Objects'); }
function meta::java::metamodel::factory::javaTreeMap():                meta::java::metamodel::Class[1] { javaClass('java.util.TreeMap'); }
function meta::java::metamodel::factory::javaCalendar():               meta::java::metamodel::Class[1] { javaClass('java.util.Calendar'); }
function meta::java::metamodel::factory::javaGregorianCalendar():      meta::java::metamodel::Class[1] { javaClass('java.util.GregorianCalendar'); }
function meta::java::metamodel::factory::javaSpliterator():            meta::java::metamodel::Class[1] { javaClass('java.util.Spliterator'); }
function meta::java::metamodel::factory::javaSpliterators():           meta::java::metamodel::Class[1] { javaClass('java.util.Spliterators'); }

function meta::java::metamodel::factory::javaInstant():                meta::java::metamodel::Class[1] { javaClass('java.time.Instant'); }
function meta::java::metamodel::factory::javaLocalDate():              meta::java::metamodel::Class[1] { javaClass('java.time.LocalDate'); }

function meta::java::metamodel::factory::javaCollector():              meta::java::metamodel::Class[1] { javaClass('java.util.stream.Collector'); }
function meta::java::metamodel::factory::javaCollectors():             meta::java::metamodel::Class[1] { javaClass('java.util.stream.Collectors'); }
function meta::java::metamodel::factory::javaLongStream():             meta::java::metamodel::Class[1] { javaClass('java.util.stream.LongStream'); }
function meta::java::metamodel::factory::javaStreamSupport():          meta::java::metamodel::Class[1] { javaClass('java.util.stream.StreamSupport'); }

function meta::java::metamodel::factory::javaConcurrentHashMap():      meta::java::metamodel::Class[1] { javaClass('java.util.concurrent.ConcurrentHashMap'); }

function meta::java::metamodel::factory::javaDecimalFormat():          meta::java::metamodel::Class[1] { javaClass('java.text.DecimalFormat'); }
function meta::java::metamodel::factory::javaDecimalFormatSymbols():   meta::java::metamodel::Class[1] { javaClass('java.text.DecimalFormatSymbols'); }

function meta::java::metamodel::factory::javaResultSet():              meta::java::metamodel::Class[1] { javaClass('java.sql.ResultSet'); }
function meta::java::metamodel::factory::javaSqlDate():                meta::java::metamodel::Class[1] { javaClass('java.sql.Date'); }
function meta::java::metamodel::factory::javaSqlTimestamp():                meta::java::metamodel::Class[1] { javaClass('java.sql.Timestamp'); }

function meta::java::metamodel::factory::javaCollection(t:meta::java::metamodel::Type[1]) : meta::java::metamodel::Type[1]
{
   ^meta::java::metamodel::ParameterizedType(rawType=javaClass('java.util.Collection'), typeArguments=$t->toBoxed());
}

function meta::java::metamodel::factory::javaList(t:meta::java::metamodel::Type[1]) : meta::java::metamodel::Type[1]
{
   ^meta::java::metamodel::ParameterizedType(rawType=javaClass('java.util.List'), typeArguments=$t->toBoxed());
}

function meta::java::metamodel::factory::javaQueue(t:meta::java::metamodel::Type[1]) : meta::java::metamodel::Type[1]
{
   ^meta::java::metamodel::ParameterizedType(rawType=javaClass('java.util.Queue'), typeArguments=$t->toBoxed());
}

function meta::java::metamodel::factory::javaArrayList(t:meta::java::metamodel::Type[1]) : meta::java::metamodel::Type[1]
{
   ^meta::java::metamodel::ParameterizedType(rawType=javaClass('java.util.ArrayList'), typeArguments=$t->toBoxed());
}

function meta::java::metamodel::factory::javaLinkedList(t:meta::java::metamodel::Type[1]) : meta::java::metamodel::Type[1]
{
   ^meta::java::metamodel::ParameterizedType(rawType=javaClass('java.util.LinkedList'), typeArguments=$t->toBoxed());
}

function meta::java::metamodel::factory::javaSet(t:meta::java::metamodel::Type[1]) : meta::java::metamodel::Type[1]
{
   ^meta::java::metamodel::ParameterizedType(rawType=javaClass('java.util.Set'), typeArguments=$t->toBoxed());
}

function meta::java::metamodel::factory::javaMap(key:meta::java::metamodel::Type[1], value:meta::java::metamodel::Type[1]) : meta::java::metamodel::Type[1]
{
   ^meta::java::metamodel::ParameterizedType(rawType=javaClass('java.util.Map'), typeArguments=[$key->toBoxed(), $value->toBoxed()]);
}

function meta::java::metamodel::factory::javaTreeMap(key:meta::java::metamodel::Type[1], value:meta::java::metamodel::Type[1]) : meta::java::metamodel::Type[1]
{
   ^meta::java::metamodel::ParameterizedType(rawType=javaTreeMap(), typeArguments=[$key->toBoxed(), $value->toBoxed()]);
}

function meta::java::metamodel::factory::javaStack(t:meta::java::metamodel::Type[1]) : meta::java::metamodel::Type[1]
{
   ^meta::java::metamodel::ParameterizedType(rawType=javaClass('java.util.Stack'), typeArguments=$t->toBoxed());
}

function meta::java::metamodel::factory::javaWildcard() : meta::java::metamodel::WildcardType[1]
{
   javaWildcardType([], []);
}

function meta::java::metamodel::factory::javaWildcardExtends(extend:meta::java::metamodel::Type[*]) : meta::java::metamodel::WildcardType[1]
{
   javaWildcardType([], $extend);
}

function meta::java::metamodel::factory::javaWildcardSuper(super:meta::java::metamodel::Type[*]) : meta::java::metamodel::WildcardType[1]
{
   javaWildcardType($super, []);
}

function meta::java::metamodel::factory::javaWildcardType(super:meta::java::metamodel::Type[*], extend:meta::java::metamodel::Type[*]) : meta::java::metamodel::WildcardType[1]
{
   ^meta::java::metamodel::WildcardType(lowerBounds=$super, upperBounds=$extend);
}

function meta::java::metamodel::factory::javaParameterizedType(rawType:meta::java::metamodel::Class[1], typeArguments:meta::java::metamodel::Type[*]) : meta::java::metamodel::ParameterizedType[1]
{
   ^meta::java::metamodel::ParameterizedType(rawType=$rawType, typeArguments=$typeArguments)
}

function meta::java::metamodel::factory::javaArray(rawType:meta::java::metamodel::Type[1]) : meta::java::metamodel::Array[1]
{
   ^meta::java::metamodel::Array(rawType=$rawType)
}

function meta::java::metamodel::factory::javaClassType(t:meta::java::metamodel::Type[1]) : meta::java::metamodel::ParameterizedType[1]
{
   ^meta::java::metamodel::ParameterizedType(rawType=javaClass('java.lang.Class'), typeArguments=$t->toBoxed());
}

function meta::java::metamodel::factory::javaSpliterator(t:meta::java::metamodel::Type[1]): meta::java::metamodel::ParameterizedType[1] 
{ 
   ^meta::java::metamodel::ParameterizedType(rawType=javaSpliterator(), typeArguments=$t->toBoxed());
}

function meta::java::metamodel::factory::javaStream(t:meta::java::metamodel::Type[1]) : meta::java::metamodel::ParameterizedType[1]
{
   ^meta::java::metamodel::ParameterizedType(rawType=javaStream(), typeArguments=$t->toBoxed());
}

function meta::java::metamodel::factory::javaStream() : meta::java::metamodel::Class[1]
{
   javaClass('java.util.stream.Stream');
}

function meta::java::metamodel::factory::javaOptional() : meta::java::metamodel::Class[1]
{
   javaClass('java.util.Optional');
}

function meta::java::metamodel::factory::javaOptional(t:meta::java::metamodel::Type[1]) : meta::java::metamodel::ParameterizedType[1]
{
   ^meta::java::metamodel::ParameterizedType(rawType=javaClass('java.util.Optional'), typeArguments=$t->toBoxed());
}

function meta::java::metamodel::factory::javaIterator(t:meta::java::metamodel::Type[1]) : meta::java::metamodel::Type[1]
{
   ^meta::java::metamodel::ParameterizedType(rawType=javaClass('java.util.Iterator'), typeArguments=$t->toBoxed());
}

function meta::java::metamodel::factory::javaConsumer(t:meta::java::metamodel::Type[1]) : meta::java::metamodel::Type[1]
{
   ^meta::java::metamodel::ParameterizedType(rawType=javaClass('java.util.function.Consumer'), typeArguments=$t->toBoxed());
}

function meta::java::metamodel::factory::javaSupplier(t:meta::java::metamodel::Type[1]) : meta::java::metamodel::Type[1]
{
   ^meta::java::metamodel::ParameterizedType(rawType=javaClass('java.util.function.Supplier'), typeArguments=$t->toBoxed());
}

function meta::java::metamodel::factory::javaLongPredicate() : meta::java::metamodel::Type[1]
{
   javaClass('java.util.function.LongPredicate');
}

function meta::java::metamodel::factory::javaPredicate(t:meta::java::metamodel::Type[1]) : meta::java::metamodel::Type[1]
{
    ^meta::java::metamodel::ParameterizedType(rawType=javaClass('java.util.function.Predicate'), typeArguments=$t->toBoxed());
}

function meta::java::metamodel::factory::javaBiPredicate(t:meta::java::metamodel::Type[1],u:meta::java::metamodel::Type[1]) : meta::java::metamodel::Type[1]
{
    ^meta::java::metamodel::ParameterizedType(rawType=javaClass('java.util.function.BiPredicate'), typeArguments=[$t->toBoxed(), $u->toBoxed()]);
}

function meta::java::metamodel::factory::javaLongUnaryOperator() : meta::java::metamodel::Type[1]
{
   javaClass('java.util.function.LongUnaryOperator');
}

function meta::java::metamodel::factory::javaObject() : meta::java::metamodel::Class[1]
{
   ^meta::java::metamodel::Class(simpleName = 'Object', package = ^meta::java::metamodel::Package(name = 'lang', parent = ^meta::java::metamodel::Package(name = 'java')));
}

function meta::java::metamodel::factory::javaComparable(t:meta::java::metamodel::Type[1]) : meta::java::metamodel::Type[1]
{
   ^meta::java::metamodel::ParameterizedType(rawType=javaClass('java.lang.Comparable'), typeArguments=$t->toBoxed());
}

function meta::java::metamodel::factory::javaComparable() : meta::java::metamodel::Type[1]
{
   javaClass('java.lang.Comparable');
}

function meta::java::metamodel::factory::javaComparator(t:meta::java::metamodel::Type[1]) : meta::java::metamodel::Type[1]
{
   ^meta::java::metamodel::ParameterizedType(rawType=javaClass('java.util.Comparator'), typeArguments=$t->toBoxed());
}

function meta::java::metamodel::factory::javaComparator() : meta::java::metamodel::Type[1]
{
   javaClass('java.util.Comparator');
}

function meta::java::metamodel::factory::javaFunction(t:meta::java::metamodel::Type[1], r:meta::java::metamodel::Type[1]) : meta::java::metamodel::Type[1]
{
   ^meta::java::metamodel::ParameterizedType(rawType=javaClass('java.util.function.Function'), typeArguments=[$t->toBoxed(), $r->toBoxed()]);
}

function meta::java::metamodel::factory::javaBiFunction(t:meta::java::metamodel::Type[1], u:meta::java::metamodel::Type[1], r:meta::java::metamodel::Type[1]) : meta::java::metamodel::Type[1]
{
   ^meta::java::metamodel::ParameterizedType(rawType=javaClass('java.util.function.BiFunction'), typeArguments=[$t->toBoxed(), $u->toBoxed(), $r->toBoxed()]);
}

function meta::java::metamodel::factory::javaBinaryOperator(t:meta::java::metamodel::Type[1]) : meta::java::metamodel::Type[1]
{
   ^meta::java::metamodel::ParameterizedType(rawType=javaClass('java.util.function.BinaryOperator'), typeArguments=[$t->toBoxed()]);
}

function meta::java::metamodel::factory::javaInputStream() : meta::java::metamodel::Class[1]
{
   javaClass('java.io.InputStream');
}

function meta::java::metamodel::factory::javaClass(t:meta::java::metamodel::Type[1]) : meta::java::metamodel::Type[1]
{
   ^meta::java::metamodel::ParameterizedType(rawType=javaClass('java.lang.Class'), typeArguments=$t->toBoxed());
}

function meta::java::metamodel::factory::javaBufferedReader() : meta::java::metamodel::Class[1]
{
   ^meta::java::metamodel::Class(simpleName = 'BufferedReader', package = ^meta::java::metamodel::Package(name = 'io', parent = ^meta::java::metamodel::Package(name = 'java')));
}

function meta::java::metamodel::factory::javaException() : meta::java::metamodel::Class[1]
{
   javaClass('java.lang.Exception');
}

function meta::java::metamodel::factory::javaString() : meta::java::metamodel::Class[1]
{
   ^meta::java::metamodel::Class(simpleName = 'String', package = ^meta::java::metamodel::Package(name = 'lang', parent = ^meta::java::metamodel::Package(name = 'java')));
}

function meta::java::metamodel::factory::javaVoid() : meta::java::metamodel::Class[1]
{
   ^meta::java::metamodel::Class(simpleName = 'Void', package = ^meta::java::metamodel::Package(name = 'lang', parent = ^meta::java::metamodel::Package(name = 'java')));
}

function meta::java::metamodel::factory::javaByteClass() : meta::java::metamodel::Class[1]
{
   ^meta::java::metamodel::Class(simpleName = 'Byte', package = ^meta::java::metamodel::Package(name = 'lang', parent = ^meta::java::metamodel::Package(name = 'java')));
}

function meta::java::metamodel::factory::javaByte() : meta::java::metamodel::PrimitiveType[1]
{
   ^meta::java::metamodel::PrimitiveType(simpleName = 'byte');
}

function meta::java::metamodel::factory::javaShort() : meta::java::metamodel::PrimitiveType[1]
{
   ^meta::java::metamodel::PrimitiveType(simpleName = 'short');
}

function meta::java::metamodel::factory::javaInt() : meta::java::metamodel::PrimitiveType[1]
{
   ^meta::java::metamodel::PrimitiveType(simpleName = 'int');
}

function meta::java::metamodel::factory::javaLong() : meta::java::metamodel::PrimitiveType[1]
{
   ^meta::java::metamodel::PrimitiveType(simpleName = 'long');
}

function meta::java::metamodel::factory::javaFloat() : meta::java::metamodel::PrimitiveType[1]
{
   ^meta::java::metamodel::PrimitiveType(simpleName = 'float');
}

function meta::java::metamodel::factory::javaDouble() : meta::java::metamodel::PrimitiveType[1]
{
   ^meta::java::metamodel::PrimitiveType(simpleName = 'double');
}

function meta::java::metamodel::factory::javaBoolean() : meta::java::metamodel::PrimitiveType[1]
{
   ^meta::java::metamodel::PrimitiveType(simpleName = 'boolean');
}

function meta::java::metamodel::factory::javaChar() : meta::java::metamodel::PrimitiveType[1]
{
   ^meta::java::metamodel::PrimitiveType(simpleName = 'char');
}

function meta::java::metamodel::factory::toBoxed(type:meta::java::metamodel::Type[1]) : meta::java::metamodel::Type[1]
{
   if($type == javaBoolean(),
      | javaClass('java.lang.Boolean'),
      |
   if($type == javaByte(),
      | javaClass('java.lang.Byte'),
      |
   if($type == javaChar(),
      | javaClass('java.lang.Character'),
      |
   if($type == javaFloat(),
      | javaClass('java.lang.Float'),
      |
   if($type == javaDouble(),
      | javaClass('java.lang.Double'),
      |
   if($type == javaInt(),
      | javaClass('java.lang.Integer'),
      |
   if($type == javaLong(),
      | javaClass('java.lang.Long'),
      |
   if($type == javaShort(),
      | javaClass('java.lang.Short'),
      | $type
   ))))))));
}

function meta::java::metamodel::factory::toUnboxed(type:meta::java::metamodel::Type[1]) : meta::java::metamodel::Type[1]
{
   if($type == javaClass('java.lang.Boolean'),
      | javaBoolean(),
      |
   if($type == javaClass('java.lang.Byte'),
      | javaByte(),
      |
   if($type == javaClass('java.lang.Character'),
      | javaChar(),
      |
   if($type == javaClass('java.lang.Float'),
      | javaFloat(),
      |
   if($type == javaClass('java.lang.Double'),
      | javaDouble(),
      |
   if($type == javaClass('java.lang.Integer'),
      | javaInt(),
      |
   if($type == javaClass('java.lang.Long'),
      | javaLong(),
      |
   if($type == javaClass('java.lang.Short'),
      | javaShort(),
      | $type
   ))))))));
}

function meta::java::metamodel::factory::javaBooleanBoxed() : meta::java::metamodel::Class[1] { javaBoolean()->toBoxed()->cast(@meta::java::metamodel::Class); }
function meta::java::metamodel::factory::javaByteBoxed()    : meta::java::metamodel::Class[1] { javaByte()   ->toBoxed()->cast(@meta::java::metamodel::Class); }
function meta::java::metamodel::factory::javaCharBoxed()    : meta::java::metamodel::Class[1] { javaChar()   ->toBoxed()->cast(@meta::java::metamodel::Class); }
function meta::java::metamodel::factory::javaIntBoxed()     : meta::java::metamodel::Class[1] { javaInt()    ->toBoxed()->cast(@meta::java::metamodel::Class); }
function meta::java::metamodel::factory::javaLongBoxed()    : meta::java::metamodel::Class[1] { javaLong()   ->toBoxed()->cast(@meta::java::metamodel::Class); }
function meta::java::metamodel::factory::javaShortBoxed()   : meta::java::metamodel::Class[1] { javaShort()  ->toBoxed()->cast(@meta::java::metamodel::Class); }
function meta::java::metamodel::factory::javaFloatBoxed()   : meta::java::metamodel::Class[1] { javaFloat()  ->toBoxed()->cast(@meta::java::metamodel::Class); }
function meta::java::metamodel::factory::javaDoubleBoxed()  : meta::java::metamodel::Class[1] { javaDouble() ->toBoxed()->cast(@meta::java::metamodel::Class); }

function meta::java::metamodel::factory::javaDate() : meta::java::metamodel::Class[1]
{
   javaClass('java.util.Date');
}

function meta::java::metamodel::factory::javaNumber() : meta::java::metamodel::Class[1]
{
   javaClass('java.lang.Number');
}

function meta::java::metamodel::factory::javaBigInteger() : meta::java::metamodel::Class[1]
{
   javaClass('java.math.BigInteger');
}

function meta::java::metamodel::factory::javaBigDecimal() : meta::java::metamodel::Class[1]
{
   javaClass('java.math.BigDecimal');
}

function meta::java::metamodel::factory::javaPackage(package:String[1]):meta::java::metamodel::Package[1]
{
   let dotPos = $package->lastIndexOf('.');
   if($dotPos == -1,
      |^meta::java::metamodel::Package(name=$package),
      |^meta::java::metamodel::Package(name=$package->substring($dotPos+1), parent=$package->substring(0, $dotPos)->javaPackage())
   );
}

function meta::java::metamodel::factory::javaEnum(pkg:meta::java::metamodel::Package[1], name:String[1]):meta::java::metamodel::Class[1]
{
   javaEnum([], $pkg, $name);
}

function meta::java::metamodel::factory::javaEnum(modifiers:String[*], pkg:meta::java::metamodel::Package[1], name:String[1]):meta::java::metamodel::Class[1]
{
   ^meta::java::metamodel::Enumeration(modifiers=$modifiers->javaModifiers(), package=$pkg, simpleName=$name);
}

function meta::java::metamodel::factory::javaClass(fullClassName:String[1]):meta::java::metamodel::Class[1]
{
   javaClass([], $fullClassName);
}

function meta::java::metamodel::factory::javaClass(modifiers:String[*], fullClassName:String[1]):meta::java::metamodel::Class[1]
{
   javaClass($modifiers, [], $fullClassName);
}

function meta::java::metamodel::factory::javaClass(modifiers:String[*], proto:meta::java::metamodel::Class[1]):meta::java::metamodel::Class[1]
{
   javaClass($modifiers, [], $proto->typePathToString(true));
}

function meta::java::metamodel::factory::javaClass(modifiers:String[*], typeParams:meta::java::metamodel::TypeVariable[*], proto:meta::java::metamodel::Class[1]):meta::java::metamodel::Class[1]
{
   javaClass($modifiers, $typeParams, $proto->typePathToString(true));
}

function meta::java::metamodel::factory::javaClass(modifiers:String[*], typeParams:meta::java::metamodel::TypeVariable[*], fullClassName:String[1]):meta::java::metamodel::Class[1]
{
   let dotPos  = $fullClassName->lastIndexOf('.');
   let package = if($dotPos == -1, |^meta::java::metamodel::Package(name=''), |javaPackage($fullClassName->substring(0, $dotPos)));
   let name    = if($dotPos == -1, |$fullClassName,                           |$fullClassName->substring($dotPos+1));

   javaClass($modifiers, $typeParams, $package, $name);
}

function meta::java::metamodel::factory::javaClass(pkg:meta::java::metamodel::Package[1], name:String[1]):meta::java::metamodel::Class[1]
{
   javaClass([], $pkg, $name);
}

function meta::java::metamodel::factory::javaClass(modifiers:String[*], pkg:meta::java::metamodel::Package[1], name:String[1]):meta::java::metamodel::Class[1]
{
   javaClass($modifiers, [], $pkg, $name);
}

function meta::java::metamodel::factory::javaClass(modifiers:String[*], typeParams:meta::java::metamodel::TypeVariable[*], pkg:meta::java::metamodel::Package[1], name:String[1]):meta::java::metamodel::Class[1]
{
   ^meta::java::metamodel::Class(modifiers=$modifiers->javaModifiers(), typeParameters=$typeParams, package=$pkg, simpleName=$name);
}

function meta::java::metamodel::factory::javaClass(proto:meta::java::metamodel::Class[1], methods:Pair<meta::java::metamodel::Method,Code>[*]):meta::java::metamodel::Class[1]
{
   javaClass($proto, [], $methods);
}

function meta::java::metamodel::factory::javaClass(proto:meta::java::metamodel::Class[1], fields:meta::java::metamodel::Field[*], methods:Pair<meta::java::metamodel::Method,Code>[*]):meta::java::metamodel::Class[1]
{
   javaClass([]->cast(@meta::java::metamodel::TypeVariable), $proto, $fields, $methods);
}

function meta::java::metamodel::factory::javaClass(modifiers:String[*], proto:meta::java::metamodel::Class[1], methods:Pair<meta::java::metamodel::Method,Code>[*]):meta::java::metamodel::Class[1]
{
   javaClass($modifiers, $proto, [], $methods);
}

function meta::java::metamodel::factory::javaClass(modifiers:String[*], proto:meta::java::metamodel::Class[1], fields:meta::java::metamodel::Field[*], methods:Pair<meta::java::metamodel::Method,Code>[*]):meta::java::metamodel::Class[1]
{
   javaClass($modifiers, [], $proto->typePathToString(true), $fields, $methods);
}

function meta::java::metamodel::factory::javaClass(modifiers:String[*], fullClassName:String[1], methods:Pair<meta::java::metamodel::Method,Code>[*]):meta::java::metamodel::Class[1]
{
   javaClass($modifiers, [], $fullClassName, [], $methods);
}

function meta::java::metamodel::factory::javaClass(modifiers:String[*], fullClassName:String[1], fields:meta::java::metamodel::Field[*], methods:Pair<meta::java::metamodel::Method,Code>[*]):meta::java::metamodel::Class[1]
{
   javaClass($modifiers, [], $fullClassName, $fields, $methods);
}

function meta::java::metamodel::factory::javaClass(modifiers:String[*], typeParams:meta::java::metamodel::TypeVariable[*], fullClassName:String[1], methods:Pair<meta::java::metamodel::Method,Code>[*]):meta::java::metamodel::Class[1]
{
   javaClass($modifiers, $typeParams, $fullClassName, [], $methods);
}

function meta::java::metamodel::factory::javaClass(modifiers:String[*], typeParams:meta::java::metamodel::TypeVariable[*], fullClassName:String[1], fields:meta::java::metamodel::Field[*], methods:Pair<meta::java::metamodel::Method,Code>[*]):meta::java::metamodel::Class[1]
{
   let dotPos  = $fullClassName->lastIndexOf('.');
   let package = if($dotPos == -1, |^meta::java::metamodel::Package(name=''), |javaPackage($fullClassName->substring(0, $dotPos)));
   let name    = if($dotPos == -1, |$fullClassName,                           |$fullClassName->substring($dotPos+1));

   javaClass($modifiers, $typeParams, $package, $name, $fields, $methods);
}

function meta::java::metamodel::factory::javaClass(modifiers:String[*], typeParams:meta::java::metamodel::TypeVariable[*], pkg:meta::java::metamodel::Package[1], name:String[1], methods:Pair<meta::java::metamodel::Method,Code>[*]):meta::java::metamodel::Class[1]
{
   javaClass($modifiers, $typeParams, $pkg, $name, [], $methods);
}

function meta::java::metamodel::factory::javaClass(modifiers:String[*], typeParams:meta::java::metamodel::TypeVariable[*], pkg:meta::java::metamodel::Package[1], name:String[1], fields:meta::java::metamodel::Field[*], methods:Pair<meta::java::metamodel::Method,Code>[*]):meta::java::metamodel::Class[1]
{
   javaClass($typeParams, javaClass($modifiers, [], $pkg, $name), $fields, $methods);
}

function meta::java::metamodel::factory::javaClass(typeParams:meta::java::metamodel::TypeVariable[*], proto:meta::java::metamodel::Class[1], fields:meta::java::metamodel::Field[*], methods:Pair<meta::java::metamodel::Method,Code>[*]):meta::java::metamodel::Class[1]
{
   javaClass($typeParams, $proto, $fields, [], $methods);
}

function meta::java::metamodel::factory::javaClass(proto:meta::java::metamodel::Class[1], fields:meta::java::metamodel::Field[*], constructors:Pair<meta::java::metamodel::Constructor,Code>[*], methods:Pair<meta::java::metamodel::Method,Code>[*]):meta::java::metamodel::Class[1]
{
   javaClass([], $proto, $fields, $constructors, $methods);
}

function meta::java::metamodel::factory::javaClass(typeParams:meta::java::metamodel::TypeVariable[*], proto:meta::java::metamodel::Class[1], fields:meta::java::metamodel::Field[*], constructors:Pair<meta::java::metamodel::Constructor,Code>[*], methods:Pair<meta::java::metamodel::Method,Code>[*]):meta::java::metamodel::Class[1]
{
   let interfaces       = $proto.interfaces->typesToClasses();
   let fieldClasses     = $fields.type->typesToClasses();
   let signatureClasses = $methods.first->typesUsed()->typesToClasses();
   let codeClasses      = $constructors.second->concatenate($methods.second)->classesUsed();
   let classesUsed      = $interfaces->concatenate($fieldClasses)->concatenate($signatureClasses)->concatenate($codeClasses)->removeDuplicates();

   let withFields = $fields->fold({f, cl | $cl->addField($f)}, $proto->imports($classesUsed));
   
   let withConstructors = $constructors->fold(
      {c, cl | 
         let constuctor = $c.first;
         let bodyCode   = $c.second;
         $cl->addConstructor(^$constuctor(body=$bodyCode->codeToStringAsMethodBody($cl)));
      }, 
      $withFields
   );

   $methods->fold(
      {m, cl | 
         let method   = $m.first;
         let bodyCode = $m.second;
         $cl->addMethod(^$method(body=$bodyCode->codeToStringAsMethodBody($cl)));
      },
      $withConstructors
   );
}

function meta::java::metamodel::factory::javaType(name:String[1]):meta::java::metamodel::Type[1]
{
   if($name->in(['boolean', 'byte', 'char', 'short', 'int', 'long', 'float', 'double', 'void']),
      | ^meta::java::metamodel::PrimitiveType(simpleName=$name),
      |  javaClass($name)
   );
}

function meta::java::metamodel::factory::javaFunctionType(parameterTypes:meta::java::metamodel::Type[*], returnType:meta::java::metamodel::Type[1]):meta::java::metamodel::FunctionType[1]
{
   javaFunctionType($parameterTypes, $returnType, []);
}

function meta::java::metamodel::factory::javaFunctionType(parameterTypes:meta::java::metamodel::Type[*], returnType:meta::java::metamodel::Type[1], nullResultPossible:Boolean[0..1]):meta::java::metamodel::FunctionType[1]
{
   ^meta::java::metamodel::FunctionType(parameterTypes=$parameterTypes, returnType=$returnType, nullResultPossible=$nullResultPossible);
}

function meta::java::metamodel::factory::jextends(class:meta::java::metamodel::Class[1], t:meta::java::metamodel::Type[1]):meta::java::metamodel::Class[1]
{
   assert($class.superType->isEmpty(), |'All ready extended');
   ^$class(superType = $t);
}

function meta::java::metamodel::factory::implements(class:meta::java::metamodel::Class[1], t:meta::java::metamodel::Type[*]):meta::java::metamodel::Class[1]
{
   ^$class(interfaces = $class.interfaces->concatenate($t));
}

function meta::java::metamodel::factory::usingKnownPackages(class:meta::java::metamodel::Class[1], knownPackages:Function<{meta::java::metamodel::Package[1]->meta::java::generation::utils::KnownPackage[1]}>[1]):meta::java::metamodel::Class[1]
{
   ^meta::java::metamodel::factory::FactoryClass
   (
      knownPackages        = $knownPackages,
      typeParameters       = $class.typeParameters,
      annotations          = $class.annotations,
      javaDoc              = $class.javaDoc,
      simpleName           = $class.simpleName,
      package              = $class.package,
      modifiers            = $class.modifiers,
      interfaces           = $class.interfaces,
      superType            = $class.superType,
      constructors         = $class.constructors,
      fields               = $class.fields,
      methods              = $class.methods,
      additionalImports    = $class.additionalImports,
      projectionParentName = $class.projectionParentName
   )
}

function meta::java::metamodel::factory::imports(class:meta::java::metamodel::Class[1], imports:meta::java::metamodel::Importable[*]):meta::java::metamodel::Class[1]
{
   let knownPackages = if($class->instanceOf(meta::java::metamodel::factory::FactoryClass),
                          | $class->cast(@meta::java::metamodel::factory::FactoryClass).knownPackages,
                          | meta::java::generation::utils::knownPackage_Package_1__KnownPackage_1_
                       );

   let packages = $imports->filter(imp| $imp->instanceOf(meta::java::metamodel::Package))->cast(@meta::java::metamodel::Package);
   let classes  = $imports->filter(imp| $imp->instanceOf(meta::java::metamodel::Class))->cast(@meta::java::metamodel::Class);

   let existingImports = $class.additionalImports->map(imp| if($imp->endsWith('.*'),
                                                               |javaPackage($imp->substring(0, $imp->length()-2)),
                                                               |javaClass($imp)
                                                            )
                                                      );
   let withNewPackages = $existingImports->concatenate($packages)->removeDuplicates();
   let withoutSubsumed = $withNewPackages->filter(imp| $imp->match([
      pkg: meta::java::metamodel::Package[1] | true,
      cls: meta::java::metamodel::Class[1]   | !$cls.package->in($withNewPackages)
   ]));

   let importedNames = $class.simpleName
      ->concatenate(javaLangPackage().classNames)
      ->concatenate($withoutSubsumed->map(imp| $imp->match([
           pkg: meta::java::metamodel::Package[1] | $knownPackages->eval($pkg).classNames,
           cls: meta::java::metamodel::Class[1]   | $cls.simpleName
        ])));

   let importableClasses = $classes->removeDuplicatesBy(c | $c.simpleName)->filter(cls| !$cls.package->in($withoutSubsumed) && !$cls.simpleName->in($importedNames));
   let newImports        = $withoutSubsumed->concatenate($importableClasses)->removeDuplicates();

   ^$class(
      additionalImports=$newImports
         ->map(imp| $imp->match([
             pkg: meta::java::metamodel::Package[1] | $pkg->packageToString()+'.*',
             cls: meta::java::metamodel::Class[1]   | $cls->typePathToString(true)
           ]))
         ->sort()
   );
}

function meta::java::metamodel::factory::addModifiers(class:meta::java::metamodel::Class[1], modifiers:String[*]):meta::java::metamodel::Class[1]
{
   ^$class(modifiers = $class.modifiers->concatenate(javaModifiers($modifiers))->removeDuplicates());
}

function meta::java::metamodel::factory::addField(class:meta::java::metamodel::Class[1], field:meta::java::metamodel::Field[1]):meta::java::metamodel::Class[1]
{
   ^$class(fields = $class.fields->concatenate($field));
}

function meta::java::metamodel::factory::addFields(class:meta::java::metamodel::Class[1], fields:meta::java::metamodel::Field[*]):meta::java::metamodel::Class[1]
{
   ^$class(fields = $class.fields->concatenate($fields));
}

function meta::java::metamodel::factory::addConstructor(class:meta::java::metamodel::Class[1], constructor:meta::java::metamodel::Constructor[1]):meta::java::metamodel::Class[1]
{
   ^$class(constructors = $class.constructors->concatenate($constructor));
}

// TODO This is only needed by API knowledge so we can eliminate this if we change that to a decision instead of data structure creation (and make it more efficient)
function meta::java::metamodel::factory::addMethodIfMissing(class:meta::java::metamodel::Class[1], method:meta::java::metamodel::Method[1]):meta::java::metamodel::Class[1]
{
   let existing = $class.methods->filter({m| $m.name == $method.name && $m.parameters.type == $method.parameters.type});
   if($existing->isEmpty(),
      | ^$class(methods = $class.methods->concatenate($method->addFunctionType($class))),
      | $class
   );
}

function meta::java::metamodel::factory::addMethod(class:meta::java::metamodel::Class[1], method:meta::java::metamodel::Method[1]):meta::java::metamodel::Class[1]
{
   let existing = $class.methods->filter({m| $m.name == $method.name && $m.parameters.type == $method.parameters.type});
   assert($existing->isEmpty(), |$class->println(); 'Method already exists: '+$method->methodSignature(););
   ^$class(methods = $class.methods->concatenate($method->addFunctionType($class)));
}

function meta::java::metamodel::factory::addMethods(class:meta::java::metamodel::Class[1], methods:meta::java::metamodel::Method[*]):meta::java::metamodel::Class[1]
{
   $methods->fold({m, c|$c->addMethod($m)}, $class);
}

function <<access.private>> meta::java::metamodel::factory::addFunctionType(method:meta::java::metamodel::Method[1], onClass:meta::java::metamodel::Class[1]): meta::java::metamodel::Method[1]
{
   let isStatic   = $method.modifiers->contains(meta::java::metamodel::Modifier.Static);
   let paramTypes = if($isStatic, |[], |$onClass)->concatenate($method.parameters.type);
   ^$method(functionType=javaFunctionType($paramTypes, $method.returnType, $method.nullResultPossible));
}

function meta::java::metamodel::factory::addAnnotation<T>(element: T[1], annotation:meta::java::metamodel::Annotation[1]):T[1]
{
   $element->match([
      ae: meta::java::metamodel::AnnotatedElement[1] | ^$ae(annotations = $ae.annotations->concatenate($annotation))->cast($element),
      a : Any[1] | fail('Can add annotations to only annotated elements'); $element;
   ])
}

// For Interfaces
function meta::java::metamodel::factory::javaMethod(returnType:meta::java::metamodel::Type[1], name:String[1], parameters:Any[*]) : meta::java::metamodel::Method[1]
{
   ^meta::java::metamodel::Method(
      name           = $name,
      returnType     = $returnType,
      parameters     = $parameters->cannonicalParameters()
   )
}

// For Interfaces
function meta::java::metamodel::factory::javaMethod(typeParameters:meta::java::metamodel::TypeVariable[1..*], returnType:meta::java::metamodel::Type[1], name:String[1], parameters:Any[*]) : meta::java::metamodel::Method[1]
{
   ^meta::java::metamodel::Method(
      name           = $name,
      typeParameters = $typeParameters,
      returnType     = $returnType,
      parameters     = $parameters->cannonicalParameters()
   )
}

function meta::java::metamodel::factory::javaMethod(modifiers:String[*], returnType:meta::java::metamodel::Type[1], name:String[1], parameters:Any[*]) : meta::java::metamodel::Method[1]
{
   ^meta::java::metamodel::Method(
      name           = $name,
      modifiers      = $modifiers->javaModifiers(),
      returnType     = $returnType,
      parameters     = $parameters->cannonicalParameters()
   )
}
   
function meta::java::metamodel::factory::javaMethod(modifiers:String[*], typeParameters:meta::java::metamodel::TypeVariable[1..*], returnType:meta::java::metamodel::Type[1], name:String[1], parameters:Any[*]) : meta::java::metamodel::Method[1]
{
   ^meta::java::metamodel::Method(
      name           = $name,
      modifiers      = $modifiers->javaModifiers(),
      typeParameters = $typeParameters,
      returnType     = $returnType,
      parameters     = $parameters->cannonicalParameters()
   )
}

function meta::java::metamodel::factory::javaMethod(modifiers:String[*], returnType:meta::java::metamodel::Type[1], name:String[1], parameters:Any[*], body:String[1]) : meta::java::metamodel::Method[1]
{
   ^meta::java::metamodel::Method(
      name           = $name,
      modifiers      = $modifiers->javaModifiers(),
      returnType     = $returnType,
      parameters     = $parameters->cannonicalParameters(),
      body           = $body
   )
}

function meta::java::metamodel::factory::javaMethod(modifiers:String[*], typeParameters:meta::java::metamodel::TypeVariable[1..*], returnType:meta::java::metamodel::Type[1], name:String[1], parameters:Any[*], body:String[1]) : meta::java::metamodel::Method[1]
{
   ^meta::java::metamodel::Method(
      name           = $name,
      modifiers      = $modifiers->javaModifiers(),
      typeParameters = $typeParameters,
      returnType     = $returnType,
      parameters     = $parameters->cannonicalParameters(),
      body           = $body
   )
}

function <<access.private>> meta::java::metamodel::factory::cannonicalParameters(parameters:Any[*]) : meta::java::metamodel::Parameter[*]
{
   $parameters->map(p | $p->match([
      p: meta::java::metamodel::Parameter[1] | $p,
      c: Code[1]                             | $c->asParameters()
   ]));
}

function meta::java::metamodel::factory::nonNull(method:meta::java::metamodel::Method[1]) : meta::java::metamodel::Method[1]
{
   ^$method(nullResultPossible=false);
}

function meta::java::metamodel::factory::nullable(method:meta::java::metamodel::Method[1]) : meta::java::metamodel::Method[1]
{
   ^$method(nullResultPossible=true);
}

function meta::java::metamodel::factory::nonNull(type:meta::java::metamodel::FunctionType[1]) : meta::java::metamodel::FunctionType[1]
{
   ^$type(nullResultPossible=false);
}

function meta::java::metamodel::factory::nullable(type:meta::java::metamodel::FunctionType[1]) : meta::java::metamodel::FunctionType[1]
{
   ^$type(nullResultPossible=true);
}

function meta::java::metamodel::factory::javaModifiers(modifiers:String[*]): meta::java::metamodel::Modifier[*]
{
   $modifiers->map(m| $m->javaModifier());
}

function meta::java::metamodel::factory::javaModifier(modifier:String[1]): meta::java::metamodel::Modifier[1]
{
   meta::java::metamodel::Modifier->enumValues()->filter(v|$v.name->toLower() == $modifier)->toOne()->cast(@meta::java::metamodel::Modifier);
}

function meta::java::metamodel::factory::javaTypeVar(name:String[1]): meta::java::metamodel::TypeVariable[1]
{
   ^meta::java::metamodel::TypeVariable(name=$name);
}

function meta::java::metamodel::factory::javaParam(type:meta::java::metamodel::Type[1], name:String[1]): meta::java::metamodel::Parameter[1]
{
   ^meta::java::metamodel::Parameter(name=$name, type=$type);
}

function meta::java::metamodel::factory::javaField(modifiers:String[*], type:meta::java::metamodel::Type[1], name:String[1]): meta::java::metamodel::Field[1]
{
   ^meta::java::metamodel::Field(
      modifiers = $modifiers->javaModifiers(),
      name=$name,
      type=$type
   );
}

function meta::java::metamodel::factory::javaField(modifiers:String[*], type:meta::java::metamodel::Type[1], name:String[1], initialiser:String[1]): meta::java::metamodel::Field[1]
{
   let uninited = javaField($modifiers, $type, $name);
   ^$uninited(value=$initialiser);
}

function meta::java::metamodel::factory::javaConstructor(modifiers:String[*], parameters:Any[*]): meta::java::metamodel::Constructor[1]
{
   ^meta::java::metamodel::Constructor(
      modifiers  = $modifiers->javaModifiers(),
      parameters = $parameters->cannonicalParameters()
   );
}

function meta::java::metamodel::factory::javaConstructor(modifiers:String[*], parameters:Any[*], body:String[1]): meta::java::metamodel::Constructor[1]
{
   ^meta::java::metamodel::Constructor(
      modifiers  = $modifiers->javaModifiers(),
      parameters = $parameters->cannonicalParameters(),
      body       = $body
   );
}

Class meta::java::metamodel::factory::FactoryClass extends meta::java::metamodel::Class
{
   knownPackages:Function<{meta::java::metamodel::Package[1]->meta::java::generation::utils::KnownPackage[1]}>[1];
}






// TODO Eliminate this
function meta::java::generation::code::merge(codes: Code[1..*]):Code[1]
{
   let head = $codes->at(0);
   $codes->tail()->fold({c, a|^$a(requires=$a->dependencies()->concatenate($c->dependencies())->removeDuplicates())}, $head);
}

// TODO Remove once all streaming is via j_streamOf...js_resolve
function meta::java::generation::code::canOptimize(code: Code[1]):Boolean[1]
{
   $code->instanceOf(SimpleCode);
}



// --- To dependencies

function meta::java::generation::code::dependencies(codes: Code[*]):CodeDependency[*]
{
   $codes->map(code| $code->match([
      c:InfixExpression[1]          | $c.requires->concatenate($c.left->dependencies())->concatenate($c.right->dependencies()),
      c:PrefixExpression[1]         | $c.requires->concatenate($c.expression->dependencies()),
      c:PostfixExpression[1]        | $c.requires->concatenate($c.expression->dependencies()),
      c:Conditional[1]              | $c.requires->concatenate($c.test->concatenate($c.then)->concatenate($c.else)->map(x|$x->dependencies())),
      c:InstanceOf[1]               | $c.requires->concatenate($c.expression->dependencies()),
      c:ArrayAccess[1]              | $c.requires->concatenate($c.array->dependencies())->concatenate($c.index->dependencies()),
      c:CastProxy[1]                | $c.requires->concatenate($c.expression->concatenate($c.proxy)->dependencies()),
      c:Cast[1]                     | $c.requires->concatenate($c.expression->dependencies()),
      c:LocalVariableDeclaration[1] | $c.requires->concatenate($c.initializer->dependencies()),
      c:MethodCall[1]               | $c.requires->concatenate($c.instance->dependencies())->concatenate($c.arguments->map(a| $a->dependencies())),
      c:FieldAccess[1]              | $c.requires->concatenate($c.instance->dependencies()),
      c:MethodReference[1]          | $c.requires->concatenate($c.instance->dependencies()),
      c:Block[1]                    | $c.requires->concatenate($c.statements->dependencies()),
      c:ExpressionStatement[1]      | $c.requires->concatenate($c.expression->dependencies()),
      c:If[1]                       | $c.requires->concatenate($c.test->concatenate($c.then)->concatenate($c.else)->map(x|$x->dependencies())),
      c:For[1]                      | $c.requires->concatenate($c.init->concatenate($c.test)->concatenate($c.update)->concatenate($c.body)->map(x|$x->dependencies())),
      c:ForEach[1]                  | $c.requires->concatenate($c.parameter->concatenate($c.collection)->concatenate($c.body)->map(x|$x->dependencies())),
      c:While[1]                    | $c.requires->concatenate($c.test->concatenate($c.then)->map(x|$x->dependencies())),
      c:DoWhile[1]                  | $c.requires->concatenate($c.do->concatenate($c.while)->map(x|$x->dependencies())),
      c:Try[1]                      | $c.requires->concatenate($c.try->concatenate($c.catches)->concatenate($c.finally)->map(x|$x->dependencies())),
      c:Catch[1]                    | $c.requires->concatenate($c.clause->dependencies()),
      c:Finally[1]                  | $c.requires->concatenate($c.clause->dependencies()),
      c:Return[1]                   | $c.requires->concatenate($c.expression->dependencies()),
      c:Throw[1]                    | $c.requires->concatenate($c.expression->dependencies()),
      c:NewAnonymous[1]             | $c.requires->concatenate($c.arguments->dependencies())->concatenate($c.methods->dependencies()),
      c:New[1]                      | $c.requires->concatenate($c.arguments->dependencies()),
      c:Method[1]                   | $c.requires->concatenate($c.parameters->map(p|$p->dependencies()))->concatenate($c.body->dependencies()),
      c:StaticMethodCall[1]         | $c.requires->concatenate($c.arguments->map(a| $a->dependencies())),
      c:DeferredStreamResolve[1]    | $c.requires->concatenate($c.stream->dependencies()),
      c:Lambda[1]                   | $c.requires->concatenate($c.expression->dependencies()),
      c:Code[1]                     | $c.requires
   ]))->removeDuplicates();
}

// --- Java coding

function meta::java::generation::code::j_code(code:String[1], type:meta::java::metamodel::Type[1]):Code[1]
{
   j_code($code, $type, []);
}

function meta::java::generation::code::j_code(code:String[1], type:meta::java::metamodel::Type[1], dependencies:CodeDependency[*]):Code[1]
{
   ^SimpleCode(code=$code, type=$type, requires=$dependencies);
}

function meta::java::generation::code::j_null():Code[1]
{
   ^Null(type=javaVoid()); // void to represent bottom (Nil)
}

function meta::java::generation::code::j_null(type:meta::java::metamodel::Type[1]):Code[1]
{
   ^Null(type=$type);
}

/* Used to indicate a nested anonymous class (primarilly for j_this). Nesting level starts at 1:

   class X
   {
      ...
      new Something()
      {
         ...
         new SomethingElse()
         {
            ...
         }
      }
      new Another()
      {
         ...
      }
   }

  Something and Another are anonymousNestedClass(1), SomethingElse is anonymousNestedClass(2)

  This is different than the compiler which will make them: Something->$1, SomethingElse->$2, Another->$3
*/
function meta::java::generation::code::anonymousNestedClass(level:Integer[1]):meta::java::metamodel::Class[1]
{
   ^meta::java::metamodel::Class(simpleName='Level'+$level->toString(), package=anonymousPackage());
}

function <<access.private>> meta::java::generation::code::anonymousPackage():meta::java::metamodel::Package[1]
{
   ^meta::java::metamodel::Package(name='__ANON__');
}

function meta::java::generation::code::j_this(type:meta::java::metamodel::Type[1]):Code[1]
{
   ^This(type=$type);
}

function meta::java::generation::code::j_variable(param:meta::java::metamodel::Parameter[1]):Code[1]
{
   ^Variable(name=$param.name, type=$param.type);
}

function meta::java::generation::code::j_variable(type:meta::java::metamodel::Type[1], name:String[1]):Code[1]
{
   ^Variable(name=$name, type=$type);
}

function meta::java::generation::code::j_parameter(param:meta::java::metamodel::Parameter[1]):Code[1]
{
   ^Parameter(name=$param.name, type=$param.type);
}

function meta::java::generation::code::j_parameter(type:meta::java::metamodel::Type[1], name:String[1]):Code[1]
{
   ^Parameter(name=$name, type=$type);
}

function meta::java::generation::code::j_arrayAccess(array:Code[1], index:Code[1]):Code[1]
{
   ^ArrayAccess(array=$array, index=$index, type=$array.type->elementTypeOfJavaArray());
}

function meta::java::generation::code::j_block(codes:Code[*]):Code[1]
{
   let statements = $codes->toStatements();
   let last       = $statements->last()->toOne().type;
   ^Block(statements=$statements, type=if($last->isEmpty(), |javaVoid(), |$last->toOne()));
}

function meta::java::generation::code::j_expressionStatement(expression:Code[1]):Code[1]
{
   assert($expression->isValidExpressionAsStatement(), |'Not a valid expression to use as a statement');
   ^ExpressionStatement(expression=$expression, type=$expression.type);
}

function meta::java::generation::code::j_if(test:Code[1], then:Code[1..*]):Code[1]
{
   j_if($test, $then, []);
}

function meta::java::generation::code::j_if(test:Code[1], then:Code[1..*], else:Code[*]):Code[1]
{
   let canonicalThen = $then->match([
      c1:Code[1] | $c1->blockIfNot(),
      cs:Code[*] | $cs->j_block()
   ]);
   let canonicalElse = $else->match([
      c0:Code[0] | [],
      c1:Code[1] | if($c1->instanceOf(If), |$c1, |$c1->blockIfNot()),
      cs:Code[*] | $cs->j_block()
   ]);

   ^If(test=$test, then=$canonicalThen, else=$canonicalElse, type=javaVoid());
}

function meta::java::generation::code::j_if(testsAndThens:List<Pair<Code,Code>>[1]):Code[1]
{
   j_if($testsAndThens, []);
}

function meta::java::generation::code::j_if(testsAndThens:List<Pair<Code,Code>>[1], else:Code[0..1]):Code[1]
{
   assert($testsAndThens.values->isNotEmpty(), |'No then clauses');
   $testsAndThens.values->reverse()->fold({tt, a| j_if($tt.first, $tt.second, $a)}, $else)->toOne();
}

function meta::java::generation::code::j_for(init:Code[0..1], test:Code[0..1], update:Code[0..1], body:Code[1..*]):Code[1]
{
   let canonicalBody = $body->match([
      c1:Code[1] | $c1->blockIfNot(),
      cs:Code[*] | $cs->j_block()
   ]);
   ^For(init=$init, test=$test, update=$update, body=$canonicalBody, type=javaVoid());
}

function meta::java::generation::code::j_for(parameter:Code[1], collection:Code[1], body:Code[1..*]):Code[1]
{
   assert($parameter->instanceOf(Parameter), 'Parameter must be properly created (j_parameter)');
   let canonicalBody = $body->match([
      c1:Code[1] | $c1->blockIfNot(),
      cs:Code[*] | $cs->j_block()
   ]);
   ^ForEach(parameter=$parameter, collection=$collection, body=$canonicalBody, type=javaVoid());
}

function meta::java::generation::code::j_while(test:Code[1], then:Code[1..*]):Code[1]
{
   let canonicalThen = $then->match([
      c1:Code[1] | $c1->blockIfNot(),
      cs:Code[*] | $cs->j_block()
   ]);
   ^While(test=$test, then=$canonicalThen, type=javaVoid());
}

function meta::java::generation::code::j_doWhile(do:Code[1..*], while:Code[1]):Code[1]
{
   let canonicalDo = $do->match([
      c1:Code[1] | $c1->blockIfNot(),
      cs:Code[*] | $cs->j_block()
   ]);
   ^DoWhile(do=$canonicalDo, while=$while, type=javaVoid());
}

function meta::java::generation::code::j_catch(parameter:meta::java::metamodel::Parameter[1], clause:Code[1..*]):Code[1]
{
   j_catch($parameter->j_parameter(), $clause);
}

function meta::java::generation::code::j_catch(parameter:Code[1], clause:Code[1..*]):Code[1]
{
   assert($parameter->instanceOf(Parameter), 'Parameter must be properly created (j_parameter)');
   let canonicalClause = $clause->match([
      c1:Code[1] | $c1->blockIfNot(),
      cs:Code[*] | $cs->j_block()
   ]);
   ^Catch(parameter=$parameter->cast(@Parameter), clause=$canonicalClause, type=javaVoid());
}

function meta::java::generation::code::j_finally(clause:Code[1..*]):Code[1]
{
   let canonicalClause = $clause->match([
      c1:Code[1] | $c1->blockIfNot(),
      cs:Code[*] | $cs->j_block()
   ]);
   ^Finally(clause=$canonicalClause, type=javaVoid());
}

function meta::java::generation::code::j_try(try:Code[1..*], c1:Code[1]):Code[1]
{
   if($c1->instanceOf(Catch),
      |j_tryInternal($try, [$c1], []),
      |j_tryInternal($try, [],    $c1)
   );
}

function meta::java::generation::code::j_try(try:Code[1..*], c1:Code[1], c2:Code[1]):Code[1]
{
   if($c2->instanceOf(Catch),
      |j_tryInternal($try, [$c1, $c2], []),
      |j_tryInternal($try, [$c1],      $c2)
   );
}

function meta::java::generation::code::j_try(try:Code[1..*], c1:Code[1], c2:Code[1], c3:Code[1]):Code[1]
{
   if($c3->instanceOf(Catch),
      |j_tryInternal($try, [$c1, $c2, $c3], []),
      |j_tryInternal($try, [$c1, $c2],      $c3)
   );
}

function meta::java::generation::code::j_try(try:Code[1..*], c1:Code[1], c2:Code[1], c3:Code[1], c4:Code[1]):Code[1]
{
   if($c4->instanceOf(Catch),
      |j_tryInternal($try, [$c1, $c2, $c3, $c4], []),
      |j_tryInternal($try, [$c1, $c2, $c3],      $c4)
   );
}

function meta::java::generation::code::j_try(try:Code[1..*], c1:Code[1], c2:Code[1], c3:Code[1], c4:Code[1], c5:Code[1]):Code[1]
{
   if($c4->instanceOf(Catch),
      |j_tryInternal($try, [$c1, $c2, $c3, $c4, $c5], []),
      |j_tryInternal($try, [$c1, $c2, $c3, $c4],      $c5)
   );
}

function meta::java::generation::code::j_try(try:Code[1..*], catches:Code[*], finally:Code[0..1]):Code[1]
{
   j_tryInternal($try, $catches, $finally);
}

function <<access.private>> meta::java::generation::code::j_tryInternal(try:Code[1..*], catches:Code[*], finally:Code[0..1]):Code[1]
{
   assert($catches->forAll(c| $c->instanceOf(Catch)), 'catch clauses must be properly created (j_catch)');
   assert($finally->forAll(f| $f->instanceOf(Finally)), 'finally clause must be properly created (j_finally)');
   let canonicalTry = $try->match([
      c1:Code[1] | $c1->blockIfNot(),
      cs:Code[*] | $cs->j_block()
   ]);
   ^Try(try=$canonicalTry, catches=$catches->cast(@Catch), finally=$finally->cast(@Finally), type=javaVoid());
}

function meta::java::generation::code::j_return():Code[1]
{
   ^Return(type=javaVoid());
}

function meta::java::generation::code::j_return(expression:Code[1]):Code[1]
{
   ^Return(expression=$expression, type=$expression.type);
}

function meta::java::generation::code::j_throw(expression:Code[1]):Code[1]
{
   ^Throw(expression=$expression, type=$expression.type);
}

function meta::java::generation::code::j_cast(expression:Code[1], castTo:meta::java::metamodel::Type[1]):Code[1]
{
   if($expression.type == $castTo,
     | $expression,
     |
   if($expression.type->isPrimitiveNumber() && ($castTo == javaNumber() || $castTo == javaObject()),
     | ^CastProxy(expression=$expression, proxy=$expression->j_box()->j_cast($castTo), type=$castTo),
     |
   if($expression->instanceOf(Cast),
     | $expression->cast(@Cast).expression->j_cast($castTo),
     |
   if($castTo == javaInt() && $expression.type->isBoxedNumberType(),
     | ^CastProxy(expression=$expression, proxy=$expression->j_invoke('intValue', [], javaInt()), type=$castTo),
     |
   if($castTo == javaLong() && $expression.type->isBoxedNumberType(),
     | ^CastProxy(expression=$expression, proxy=$expression->j_invoke('longValue', [], javaLong()), type=$castTo),
     |
   if($castTo == javaShort() && $expression.type->isBoxedNumberType(),
     | ^CastProxy(expression=$expression, proxy=$expression->j_invoke('shortValue', [], javaShort()), type=$castTo),
     |
   if($castTo == javaByte() && $expression.type->isBoxedNumberType(),
     | ^CastProxy(expression=$expression, proxy=$expression->j_invoke('byteValue', [], javaByte()), type=$castTo),
     |
   if($castTo == javaFloat() && $expression.type->isBoxedNumberType(),
     | ^CastProxy(expression=$expression, proxy=$expression->j_invoke('floatValue', [], javaFloat()), type=$castTo),
     |
   if($castTo == javaDouble() && $expression.type->isBoxedNumberType(),
     | ^CastProxy(expression=$expression, proxy=$expression->j_invoke('doubleValue', [], javaDouble()), type=$castTo),
     |
   if($expression.type->toBoxed() == $castTo || $expression.type == $castTo->toBoxed(),
     | ^CastProxy(expression=$expression, proxy=$expression, type=$castTo),
     |
   if($expression->isCollectionsEmptyList() && !$castTo->isJavaList(),
     | ^CastProxy(expression=$expression, proxy=j_null()->j_cast($castTo), type=$castTo),
     |
   if($expression.type->instanceOf(meta::java::metamodel::FunctionType) && $castTo->instanceOf(meta::java::metamodel::FunctionType),
      {|
         let ft = $expression.type->cast(@meta::java::metamodel::FunctionType);
         let ct = $castTo->cast(@meta::java::metamodel::FunctionType);
         assert($ft.parameterTypes->size() == $ct.parameterTypes->size(), 'Cannot cast to a differnt number of parameters');
         assert($expression->instanceOf(Lambda), 'Cannot cast other type to lambda of function type');
         
         let exp = $expression->cast(@Lambda);
         ^Lambda(
            parameters = range($exp.parameters->size())->map(n|j_parameter($ct.parameterTypes->at($n), $exp.parameters->at($n).name))->cast(@Parameter),
            expression = $exp.expression->j_cast($ct.returnType),
            type       = $castTo
         );
      },
      |
   if($expression.type->instanceOf(meta::java::metamodel::FunctionType),
      {|
         let ft = $expression.type->cast(@meta::java::metamodel::FunctionType);
         assert($castTo->isJavaSupplier() || $castTo->isJavaFunction(), 'Cannot cast \''+$expression.type->typePathToString(true)+'\' to: ' + $castTo->typePathToString(true));

         let funcResult = $ft.returnType;
         if ($castTo->isJavaFunction(), 
             | 
                let castResult       = $castTo->returnTypeOfJavaFunction();
                let inputType        = $castTo->inputTypeOfJavaFunction();
                let inputParameter   = $expression->cast(@Lambda).parameters->at(0);
             
                if($castResult->isJavaList() && !$funcResult->isJavaList(),
                  {|
                     let fResult = j_variable($funcResult, '_fResult');
                     let makeList = j_lambda($inputParameter, j_block([
                        $fResult->j_declare($expression->j_cast(javaFunction($inputType, $funcResult))->j_invoke('apply', [$inputParameter], $funcResult)),
                        $fResult->j_listOf(javaList($funcResult))->j_return()
                     ]));
                     ^Cast(expression=$makeList, type=$castTo);
                  },
               | ^Cast(expression=$expression, type=$castTo);
               );,| 
         if ($castTo->isJavaSupplier(), |             
               let castResult = $castTo->suppliedTypeOfJavaSupplier();

               if($castResult->isJavaList() && !$funcResult->isJavaList(),
                  {|
                     let fResult = j_variable($funcResult, '_fResult');
                     let makeList = j_lambda([]->cast(@Code), j_block([
                        $fResult->j_declare($expression->j_cast(javaSupplier($funcResult))->j_invoke('get', [], $funcResult)),
                        $fResult->j_listOf(javaList($funcResult))->j_return()
                     ]));
                     ^Cast(expression=$makeList, type=$castTo);
                  },
                  |
               if($funcResult->isJavaList() && !$castResult->isJavaList(),
                  {|
                     assert($expression->isLambdaReturningCollectionsEmptyList(), |'Should only happen for empty list');
                     ^Cast(expression=j_lambda([]->cast(@Code), j_null()->j_return()), type=$castTo);
                  },
                  | ^Cast(expression=$expression, type=$castTo);
               ));,
         |^Cast(expression=$expression, type=$castTo)););
      },
      |
   if($expression.type->isJavaStream() && $castTo->isJavaStream(),
      {|
         let fromStreamOf = $expression.type->elementTypeOfJavaStream();
         if ($castTo->elementTypeOfJavaStream()->instanceOf(meta::java::metamodel::Class),
            |  let toStreamOf   = $castTo->elementTypeOfJavaStream()->cast(@meta::java::metamodel::Class);
               $expression->j_invoke('map', j_methodReference(j_field($toStreamOf, 'class', javaClassType($toStreamOf)), 'cast', javaFunctionType($fromStreamOf, $toStreamOf)), $castTo);,
            |     if ($castTo->elementTypeOfJavaStream()->instanceOf(meta::java::metamodel::TypeVariable),|  
                      let toStreamOf   = $castTo->elementTypeOfJavaStream()->cast(@meta::java::metamodel::TypeVariable);
                      let x = j_parameter(if($fromStreamOf->isJavaList(),|$fromStreamOf->elementType();,|$fromStreamOf;), 'x'); 
                     $expression->j_invoke('map', j_lambda($x, $x->j_cast($toStreamOf)), $castTo);,
                   | $expression));
      },
      |
   if($expression->instanceOf(DeferredStreamResolve) && $castTo->isJavaList(),
     {|
        let deferred = $expression->cast(@DeferredStreamResolve);
        ^$deferred(stream=$deferred.stream->j_cast(javaStream($castTo->elementTypeOfJavaList())), type=$castTo);
     },
     |^Cast(expression=$expression, type=$castTo)
   )))))))))))))));
}

function <<access.private>> meta::java::generation::code::isLambdaReturningCollectionsEmptyList(c:Code[1]):Boolean[1]
{
   $c->match([
      {l:Lambda[1] |
         $l.expression->match([
            b:Block[1]     | $b.statements->match([
               r:Return[1] | $r.expression->isNotEmpty() && $r.expression->toOne()->isCollectionsEmptyList(),
               c:Code[*]   | false
            ]),
            r:Return[1] | $r.expression->isNotEmpty() && $r.expression->toOne()->isCollectionsEmptyList(),
            c:Code[1]   | false
         ])         
      },
      c:Code[1] | false
   ])
}


function meta::java::generation::code::j_string(s:String[1]):Code[1]
{
   ^Literal(literal=escapedString($s), type=javaString());
}

function meta::java::generation::code::j_char(s:String[1]):Code[1]
{
   assert($s->length() == 1, 'char must be a single character');
   let esc = escapedString($s);
   ^Literal(literal='\''+$esc->substring(1, $esc->length()-1)+'\'', type=javaChar());
}

function meta::java::generation::code::j_false():Code[1]
{
   j_boolean('false');
}

function meta::java::generation::code::j_true():Code[1]
{
   j_boolean('true');
}

function meta::java::generation::code::j_boolean(b:Boolean[1]):Code[1]
{
   j_boolean($b->toString());
}

function meta::java::generation::code::j_boolean(literal:String[1]):Code[1]
{
   ^Literal(literal=$literal, type=javaBoolean());
}

function meta::java::generation::code::j_short(literal:String[1]):Code[1]
{
   ^Literal(literal=$literal, type=javaShort());
}

function meta::java::generation::code::j_int(i:Integer[1]):Code[1]
{
   ^Literal(literal=$i->toString(), type=javaInt());
}

function meta::java::generation::code::j_int(literal:String[1]):Code[1]
{
   ^Literal(literal=$literal, type=javaInt());
}

function meta::java::generation::code::j_long(i:Integer[1]):Code[1]
{
   ^Literal(literal=$i->toString()+'L', type=javaLong());
}

function meta::java::generation::code::j_long(literal:String[1]):Code[1]
{
   ^Literal(literal=$literal, type=javaLong());
}

function meta::java::generation::code::j_float(i:Integer[1]):Code[1]
{
   ^Literal(literal=$i->toString()+'.0F', type=javaFloat());
}

function meta::java::generation::code::j_float(f:Float[1]):Code[1]
{
   ^Literal(literal=$f->toString()+'F', type=javaFloat());
}

function meta::java::generation::code::j_float(literal:String[1]):Code[1]
{
   ^Literal(literal=$literal, type=javaFloat());
}

function meta::java::generation::code::j_double(i:Integer[1]):Code[1]
{
   ^Literal(literal=$i->toString()+'.0', type=javaDouble());
}

function meta::java::generation::code::j_double(f:Float[1]):Code[1]
{
   ^Literal(literal=$f->toString(), type=javaDouble());
}

function meta::java::generation::code::j_double(literal:String[1]):Code[1]
{
   ^Literal(literal=$literal, type=javaDouble());
}

function meta::java::generation::code::j_box(expression:Code[1]):Code[1]
{
   if($expression.type == javaBoolean(),
      | j_new(javaClass('java.lang.Boolean'), $expression),
      |
   if($expression.type == javaShort(),
      | j_new(javaClass('java.lang.Short'), $expression),
      |
   if($expression.type == javaInt(),
      | j_new(javaClass('java.lang.Integer'), $expression),
      |
   if($expression.type == javaLong(),
      | j_new(javaClass('java.lang.Long'), $expression),
      |
   if($expression.type == javaFloat(),
      | j_new(javaClass('java.lang.Float'), $expression),
      |
   if($expression.type == javaDouble(),
      | j_new(javaClass('java.lang.Double'), $expression),
      | $expression
   ))))));
}

function meta::java::generation::code::j_assign(variable:Code[1], expression:Code[1]):Code[1]
{
   ^InfixExpression(left=$variable, op='=', right=$expression, type=$variable.type);
}

function meta::java::generation::code::j_lt(left:Code[1], right:Code[1]):Code[1]
{
   ^InfixExpression(left=$left, op='<', right=$right, type=javaBoolean());
}

function meta::java::generation::code::j_le(left:Code[1], right:Code[1]):Code[1]
{
   ^InfixExpression(left=$left, op='<=', right=$right, type=javaBoolean());
}

function meta::java::generation::code::j_eq(left:Code[1], right:Code[1]):Code[1]
{
   if($left->instanceOf(Null) || $right->instanceOf(Null),
      | ^InfixExpression(left=$left, op='==', right=$right, type=javaBoolean()),
      {|
         let compatibility = bestCompatibility(castCompatibility($left.type, $right.type), castCompatibility($right.type, $left.type));
         if($compatibility == CastCompatibility.Disallowed,
            | j_false(),
            |
         if($compatibility == CastCompatibility.Unknown,
            | ^InfixExpression(left=$left->j_cast(javaObject()), op='==', right=$right, type=javaBoolean()),
            | ^InfixExpression(left=$left, op='==', right=$right, type=javaBoolean())
         ));
      }
   );
}

function meta::java::generation::code::j_ne(left:Code[1], right:Code[1]):Code[1]
{
   if($left->instanceOf(Null) || $right->instanceOf(Null),
      | ^InfixExpression(left=$left, op='!=', right=$right, type=javaBoolean()),
      {|
         let compatibility = bestCompatibility(castCompatibility($left.type, $right.type), castCompatibility($right.type, $left.type));
         if($compatibility == CastCompatibility.Disallowed,
            | j_true(),
            |
         if($compatibility == CastCompatibility.Unknown,
            | ^InfixExpression(left=$left->j_cast(javaObject()), op='!=', right=$right, type=javaBoolean()),
            | ^InfixExpression(left=$left, op='!=', right=$right, type=javaBoolean())
         ));
      }
   );
}

function meta::java::generation::code::j_ge(left:Code[1], right:Code[1]):Code[1]
{
   ^InfixExpression(left=$left, op='>=', right=$right, type=javaBoolean());
}

function meta::java::generation::code::j_gt(left:Code[1], right:Code[1]):Code[1]
{
   ^InfixExpression(left=$left, op='>', right=$right, type=javaBoolean());
}

function meta::java::generation::code::j_or(left:Code[1], right:Code[1]):Code[1]
{
   ^InfixExpression(left=$left, op='||', right=$right, type=javaBoolean());
}

function meta::java::generation::code::j_and(left:Code[1], right:Code[1]):Code[1]
{
   ^InfixExpression(left=$left, op='&&', right=$right, type=javaBoolean());
}

function meta::java::generation::code::j_not(expression:Code[1]):Code[1]
{
   ^PrefixExpression(op='!', expression=$expression, type=javaBoolean());
}

function meta::java::generation::code::j_plus(left:Code[1], right:Code[1]):Code[1]
{
   ^InfixExpression(left=$left, op='+', right=$right, type=$left.type);
}

function meta::java::generation::code::j_minus(left:Code[1], right:Code[1]):Code[1]
{
   ^InfixExpression(left=$left, op='-', right=$right, type=$left.type);
}

function meta::java::generation::code::j_minus(expression:Code[1]):Code[1]
{
   ^PrefixExpression(op='-', expression=$expression, type=$expression.type);
}

function meta::java::generation::code::j_multiply(left:Code[1], right:Code[1]):Code[1]
{
   ^InfixExpression(left=$left, op='*', right=$right, type=$left.type);
}

function meta::java::generation::code::j_divide(left:Code[1], right:Code[1]):Code[1]
{
   ^InfixExpression(left=$left, op='/', right=$right, type=$left.type);
}

function meta::java::generation::code::j_remainder(left:Code[1], right:Code[1]):Code[1]
{
   ^InfixExpression(left=$left, op='%', right=$right, type=$left.type);
}

function meta::java::generation::code::j_inc(expression:Code[1]):Code[1]
{
   ^PostfixExpression(expression=$expression, op='++', type=$expression.type);
}

function meta::java::generation::code::j_dec(expression:Code[1]):Code[1]
{
   ^PostfixExpression(expression=$expression, op='--', type=$expression.type);
}

function meta::java::generation::code::j_preInc(expression:Code[1]):Code[1]
{
   ^PrefixExpression(expression=$expression, op='++', type=$expression.type);
}

function meta::java::generation::code::j_preDec(expression:Code[1]):Code[1]
{
   ^PrefixExpression(expression=$expression, op='--', type=$expression.type);
}

function meta::java::generation::code::j_instanceof(expression:Code[1], type:meta::java::metamodel::Type[1]):Code[1]
{
   let class = $type->match([
      cl:meta::java::metamodel::Class[1]             | $cl,
      pt:meta::java::metamodel::ParameterizedType[1] | $pt.rawType->cast(@meta::java::metamodel::Class)
   ]);
   ^InstanceOf(expression=$expression->j_box(), class=$class, type=javaBoolean());
}

function meta::java::generation::code::j_conditional(test:Code[1], then:Code[1], else:Code[1]):Code[1]
{
   // TODO common interface inference
   let thenType = if($then->instanceOf(Null) && $then.type == javaVoid(), |$else.type, |$then.type);
   let elseType = if($else->instanceOf(Null) && $else.type == javaVoid(), |$then.type, |$else.type);
   assert($thenType == $elseType, 'Type not inferred: then: '+$thenType->typePathToString(true)+' else: '+$elseType->typePathToString(true));
   
   if($test->instanceOf(InfixExpression),
      | optimizeEqualityComparison($test->cast(@InfixExpression), $then, $else, $thenType),
      | ^Conditional(test=$test, then=$then, else=$else, type=$thenType)
   );
   
}

function meta::java::generation::code::optimizeEqualityComparison(expr:InfixExpression[1], then:Code[1], else:Code[1], type:meta::java::metamodel::Type[1]): Code[1]
{
   if($expr.left->instanceOf(Null) && $expr.right->instanceOf(Null) && $expr.op == '==',
   | $then,
   |
   if($expr.left->instanceOf(Null) && $expr.right->instanceOf(Null) && $expr.op == '!=',
   | $else,
   |
   if($expr.left->isSameLiteral($expr.right) && $expr.op == '==',
   | $then,
   |
   if($expr.left->isSameLiteral($expr.right) && $expr.op == '!=',
   | $else,
   | ^Conditional(test=$expr, then=$then, else=$else, type=$type)
   ))))
}

function meta::java::generation::code::j_conditional(test:Code[1], then:Code[1], else:Code[1], type:meta::java::metamodel::Type[1]):Code[1]
{
   ^Conditional(test=$test, then=$then, else=$else, type=$type);
}

function meta::java::generation::code::j_declare(variable:Code[1]):Code[1]
{
   j_declare([], $variable, []);
}

function meta::java::generation::code::j_declare(variable:Code[1], initializer:Code[1]):Code[1]
{
   j_declare([], $variable, $initializer);
}

function meta::java::generation::code::j_declare(modifiers:String[*], variable:Code[1]):Code[1]
{
   j_declare($modifiers, $variable, []);
}

function meta::java::generation::code::j_declare(modifiers:String[*], variable:Code[1], initializer:Code[0..1]):Code[1]
{
   let v = $variable->cast(@Variable);
   j_declare($modifiers, $v.type, $v.name, $initializer);
}

function meta::java::generation::code::j_declare(type:meta::java::metamodel::Type[1], variableName:String[1]):Code[1]
{
   j_declare([], $type, $variableName, []);
}

function meta::java::generation::code::j_declare(type:meta::java::metamodel::Type[1], variableName:String[1], initializer:Code[1]):Code[1]
{
   j_declare([], $type, $variableName, $initializer);
}

function meta::java::generation::code::j_declare(modifiers:String[*], type:meta::java::metamodel::Type[1], variableName:String[1]):Code[1]
{
   j_declare($modifiers, $type, $variableName, []);
}

function meta::java::generation::code::j_declare(modifiers:String[*], type:meta::java::metamodel::Type[1], variableName:String[1], initializer:Code[0..1]):Code[1]
{
   ^LocalVariableDeclaration(modifiers=$modifiers->javaModifiers(), type=$type, variableName=$variableName, initializer=$initializer);
}

function meta::java::generation::code::j_new(type:meta::java::metamodel::Type[1], args:Code[*]):Code[1]
{
   $type->match([
      pt:meta::java::metamodel::ParameterizedType[1] | ^New(type=$pt.rawType, typeArguments=$pt.typeArguments, arguments=$args),
      cl:meta::java::metamodel::Class[1]             | ^New(type=$cl, arguments=$args)
   ]);
}

function meta::java::generation::code::j_newAnon(type:meta::java::metamodel::Type[1], args:Code[*], methods:Code[*]):Code[1]
{
   assert($methods->forAll(m| $m->instanceOf(Method)), 'Methods must be properly created (j_method)');
   $type->match([
      pt:meta::java::metamodel::ParameterizedType[1] | ^NewAnonymous(type=$pt.rawType, typeArguments=$pt.typeArguments, arguments=$args, methods=$methods->cast(@Method)),
      cl:meta::java::metamodel::Class[1]             | ^NewAnonymous(type=$cl, arguments=$args, methods=$methods->cast(@Method))
   ]);
}

// TODO modifiers
function meta::java::generation::code::j_method(modifiers:String[*], returnType:meta::java::metamodel::Type[1], name:String[1], parameters:Code[*], body:Code[1]):Code[1]
{
   assert($parameters->forAll(p| $p->instanceOf(Parameter)), 'Parameters must be properly created (j_parameter)');
   ^Method(modifiers=$modifiers->javaModifiers(), type=$returnType, name=$name, parameters=$parameters->cast(@Parameter), body=$body->blockIfNot());
}

function meta::java::generation::code::j_invoke(instance:Code[1], method:meta::java::metamodel::Method[1], args:Code[*]):Code[1]
{
   j_invoke($instance, [], $method.name, $args, $method.returnType);
}

function meta::java::generation::code::j_invoke(instance:Code[1], methodName:String[1], args:Code[*]):Code[1]
{
   j_invoke($instance, [], $methodName, $args);
}

function meta::java::generation::code::j_invoke(instance:Code[1], typeArguments:meta::java::metamodel::Type[*], methodName:String[1], args:Code[*]):Code[1]
{
   j_invoke($instance, $typeArguments, $methodName, $args, $instance.type->methodReturnType($methodName));
}

function meta::java::generation::code::j_invoke(instance:Code[1], methodName:String[1], args:Code[*], type:meta::java::metamodel::Type[1]):Code[1]
{
   j_invoke($instance, [], $methodName, $args, $type);
}

function meta::java::generation::code::j_invoke(instance:Code[1], typeArguments:meta::java::metamodel::Type[*], methodName:String[1], args:Code[*], type:meta::java::metamodel::Type[1]):Code[1]
{
   ^MethodCall(instance=$instance, typeArguments=$typeArguments, methodName=$methodName, arguments=$args, type=$type);
}

function meta::java::generation::code::j_field(instance:Code[1], field:meta::java::metamodel::Field[1]):Code[1]
{
   j_field($instance, $field.name, $field.type);
}

function meta::java::generation::code::j_field(instance:Code[1], fieldName:String[1]):Code[1]
{
   j_field($instance, $fieldName, $instance.type->typeForField($fieldName));
}

function meta::java::generation::code::j_field(instance:Code[1], fieldName:String[1], type:meta::java::metamodel::Type[1]):Code[1]
{
   ^FieldAccess(instance=$instance, fieldName=$fieldName, type=$type);
}

function meta::java::generation::code::j_methodReference(instance:Code[1], methodName:String[1], type:meta::java::metamodel::Type[1]):Code[1]
{
   assert($type->instanceOf(meta::java::metamodel::FunctionType));
   ^MethodReference(instance=$instance, methodName=$methodName, type=$type);
}

function meta::java::generation::code::j_invoke(class:meta::java::metamodel::Type[1], methodName:String[1], args:Code[*]):Code[1]
{
   j_invoke($class, [], $methodName, $args);
}

function meta::java::generation::code::j_invoke(class:meta::java::metamodel::Type[1], typeArguments:meta::java::metamodel::Type[*], methodName:String[1], args:Code[*]):Code[1]
{
   j_invoke($class, $typeArguments, $methodName, $args, $class->methodReturnType($methodName));
}

function meta::java::generation::code::j_invoke(class:meta::java::metamodel::Type[1], methodName:String[1], args:Code[*], type:meta::java::metamodel::Type[1]):Code[1]
{
   j_invoke($class, [], $methodName, $args, $type);
}

function meta::java::generation::code::j_invoke(class:meta::java::metamodel::Type[1], typeArguments:meta::java::metamodel::Type[*], methodName:String[1], args:Code[*], type:meta::java::metamodel::Type[1]):Code[1]
{
   assert($class->instanceOf(meta::java::metamodel::Class) || $class->instanceOf(meta::java::metamodel::Array), |'Cannot use static method on type: ' + $class->typePathToString(true));
   ^StaticMethodCall(class=$class, typeArguments=$typeArguments, methodName=$methodName, arguments=$args, type=$type);
}

function meta::java::generation::code::j_field(class:meta::java::metamodel::Type[1], field:meta::java::metamodel::Field[1]):Code[1]
{
   j_field($class, $field.name, $field.type);
}

function meta::java::generation::code::j_field(class:meta::java::metamodel::Type[1], fieldName:String[1]):Code[1]
{
   j_field($class, $fieldName, $class->typeForField($fieldName));
}

function meta::java::generation::code::j_field(class:meta::java::metamodel::Type[1], fieldName:String[1], type:meta::java::metamodel::Type[1]):Code[1]
{
   assert($class->instanceOf(meta::java::metamodel::Class) || $class->instanceOf(meta::java::metamodel::Array), |'Cannot use static field on type: ' + $class->typePathToString(true));
   ^StaticFieldAccess(class=$class, fieldName=$fieldName, type=$type);
}

function meta::java::generation::code::j_classField(type:meta::java::metamodel::Type[1]):Code[1]
{
   ^StaticFieldAccess(class=$type, fieldName='class', type=javaClassType());
}

function meta::java::generation::code::j_methodReference(class:meta::java::metamodel::Type[1], methodName:String[1]):Code[1]
{
   let refTo = $class->findMethod($methodName);
   j_methodReference($class, $methodName, $refTo.functionType->toOne());
}

function meta::java::generation::code::j_methodReference(class:meta::java::metamodel::Type[1], methodName:String[1], type:meta::java::metamodel::Type[1]):Code[1]
{
   assert($class->instanceOf(meta::java::metamodel::Class) || $class->instanceOf(meta::java::metamodel::Array), |'Cannot use static method on type: ' + $class->typePathToString(true));
   assert($type->instanceOf(meta::java::metamodel::FunctionType));
   ^StaticMethodReference(class=$class, methodName=$methodName, type=$type);
}

function meta::java::generation::code::j_lambda(parameters:meta::java::metamodel::Parameter[*], expression:Code[1]):Code[1]
{
   j_lambda($parameters->map(p| $p->j_parameter()), $expression);
}

function meta::java::generation::code::j_lambda(parameters:meta::java::metamodel::Parameter[*], expression:Code[1], type:meta::java::metamodel::Type[1]):Code[1]
{
   j_lambda($parameters->map(p| $p->j_parameter()), $expression, $type);
}

function meta::java::generation::code::j_lambda(parameters:Code[*], expression:Code[1]):Code[1]
{
   j_lambda($parameters, $expression, javaFunctionType($parameters.type, $expression.type));
}

function meta::java::generation::code::j_lambda(parameters:Code[*], expression:Code[1], type:meta::java::metamodel::Type[1]):Code[1]
{
   assert($parameters->forAll(p| $p->instanceOf(Parameter)), 'Parameters must be properly created (j_parameter)');
   ^Lambda(parameters=$parameters->cast(@Parameter), expression=$expression, type=$type);
}

function meta::java::generation::code::j_identity(type:meta::java::metamodel::Type[1]):Code[1]
{
   j_identity('x', $type);
}

function meta::java::generation::code::j_identity(varName:String[1], type:meta::java::metamodel::Type[1]):Code[1]
{
   let p = j_parameter($type, $varName);
   j_lambda($p, $p);
}

function meta::java::generation::code::j_emptyList(listType:meta::java::metamodel::Type[1]):Code[1]
{
   if($listType->elementType()->instanceOf(meta::java::metamodel::WildcardType),
      | javaCollections()->j_invoke('emptyList', [], $listType),
      | javaCollections()->j_invoke($listType->elementType(), 'emptyList', [], $listType)
   );
}

function meta::java::generation::code::j_listOf(of: Code[1], listType:meta::java::metamodel::Type[1]):Code[1]
{
   if($of.type == $listType,
      | $of,
      |
   if($of.type->isJavaList() && $of->isCollectionsEmptyList(),
      | j_emptyList($listType),
      |
   if($of.type->isJavaList(),
      | $of->j_streamOf()->j_cast(javaStream($listType->elementType()))->js_resolve($listType),
      |
   if($of.type->isJavaPrimitive(),
      | javaCollections()->j_invoke($listType->elementType(), 'singletonList', $of, $listType),
      | javaOptional()
           ->j_invoke('ofNullable', $of->j_cast($listType->elementType()), javaOptional($of.type))
           ->j_invoke('map', javaCollections()->j_methodReference('singletonList', javaFunctionType($of.type, $listType)), $listType)
           ->j_invoke('orElseGet', javaCollections()->j_methodReference('emptyList', javaFunctionType([], $listType)), $listType)
           ->j_cast($listType)
   ))));
}

function meta::java::generation::code::j_streamOf(of: Code[1]):Code[1]
{
   $of->match([
      {dsr:DeferredStreamResolve[1]| $dsr.stream; },
      {c:Code[1] |
         let streamType = if($c.type->isJavaList(), |javaStream($c.type->elementTypeOfJavaList()), |javaStream($c.type));
         if($of.type->isJavaStream(),
            | $of,
            |
         if($of.type->isJavaList(),
            | $of->j_invoke('stream', [], javaStream($c.type->elementType())),
            |
         if($of.type->isJavaPrimitive(),
            | javaStream()->j_invoke($of.type->toBoxed(), 'of', $of, javaStream($c.type->toBoxed())),
            | javaOptional()
                 ->j_invoke('ofNullable', $of, javaOptional($of.type))
                 ->j_invoke('map', javaStream()->j_methodReference('of', javaFunctionType($of.type, javaStream($of.type))), javaStream($of.type))
                 ->j_invoke('orElseGet', javaStream()->j_methodReference('empty', javaFunctionType([], javaStream($of.type))), javaStream($of.type))
         )));
      }
   ]);
}

function meta::java::generation::code::js_map(stream: Code[1], func: Code[1]):Code[1]
{
   let funcType   = $func.type->cast(@meta::java::metamodel::FunctionType);
   let funcReturn = $funcType.returnType;
   let map        = $stream->prepareStreamForCallWithLambda($func)->j_invoke('map', $func, javaStream($funcReturn));

   if($funcReturn->isJavaList(),
      | $map->js_flatMap(j_methodReference(javaClass('java.util.Collection'), 'stream', javaFunctionType($funcReturn, javaStream($funcReturn->elementTypeOfJavaList())))),
      {|
         let cannotBeNull = $funcType.nullResultPossible->isFalse() || $funcReturn->isJavaPrimitive();
         let x = j_parameter($funcReturn, 'x');
         if($cannotBeNull, | $map, |$map->js_filter(j_lambda($x, $x->j_ne(j_null()))));
      }
   );
}

function meta::java::generation::code::js_mapAllowingNullValues(stream: Code[1], func: Code[1]):Code[1]
{
   let funcType    = $func.type->cast(@meta::java::metamodel::FunctionType);
   let funcReturn  = $funcType.returnType;
   let updatedFunc = if($func->instanceOf(Lambda) && $func->cast(@Lambda).parameters->size() == 1
                        ,| let orgFunc       = $func->cast(@Lambda);
                           let newExpression = j_if($orgFunc.parameters->toOne()->j_eq(j_null()), j_null()->j_return(), $orgFunc.expression)->j_block();
                           ^$orgFunc(expression = $newExpression);
                        ,| $func);
   let map         = $stream->prepareStreamForCallWithLambda($updatedFunc)->j_invoke('map', $updatedFunc, javaStream($funcReturn));

   if($funcReturn->isJavaList(),
      | $map->js_flatMap(j_methodReference(javaClass('java.util.Collection'), 'stream', javaFunctionType($funcReturn, javaStream($funcReturn->elementTypeOfJavaList())))),
      | $map
   );
}

function meta::java::generation::code::js_flatMap(stream: Code[1], func: Code[1]):Code[1]
{
   let funcType   = $func.type->cast(@meta::java::metamodel::FunctionType);
   let funcReturn = $funcType.returnType;
   assert($funcReturn->isJavaStream(), 'Function should return streams');
   
   $stream->prepareStreamForCallWithLambda($func)->j_invoke('flatMap', $func, javaStream($funcReturn->elementType()));
}

function meta::java::generation::code::js_filter(stream:Code[1], func:Code[1]):Code[1]
{
   let s = $stream->prepareStreamForCallWithLambda($func);
   $s->j_invoke('filter', $func, $s.type);
}

function meta::java::generation::code::js_distinct(stream:Code[1]):Code[1]
{
   assert($stream.type->isJavaStream(), 'Should apply to a stream');
   $stream->j_invoke('distinct', [], $stream.type);
}

function meta::java::generation::code::js_skip(stream:Code[1], limit:Code[1]):Code[1]
{
   assert($stream.type->isJavaStream(), 'Should apply to a stream');
   $stream->j_invoke('skip', $limit, $stream.type);
}

function meta::java::generation::code::js_limit(stream:Code[1], limit:Code[1]):Code[1]
{
   assert($stream.type->isJavaStream(), 'Should apply to a stream');
   $stream->j_invoke('limit', $limit, $stream.type);
}

function meta::java::generation::code::js_max(stream:Code[1], func:Code[1]):Code[1]
{
   $stream->prepareStreamForCallWithLambda($func)->j_invoke('max', $func, javaOptional($stream.type->elementTypeOfJavaStream()));
}

function meta::java::generation::code::js_reduce(stream:Code[1], func:Code[1]):Code[1]
{
   $stream->prepareStreamForCallWithLambda($func)->j_invoke('reduce', $func, javaOptional($stream.type->elementTypeOfJavaStream()));
}

function meta::java::generation::code::js_reduce(stream:Code[1], identity:Code[1], func:Code[1]):Code[1]
{
   $stream->prepareStreamForCallWithLambda($func)->j_invoke('reduce', [$identity, $func], $identity.type->toBoxed());
}

function meta::java::generation::code::js_findFirst(stream:Code[1]):Code[1]
{
   assert($stream.type->isJavaStream(), 'Should apply to a stream');
   $stream->j_invoke('findFirst', [], javaOptional($stream.type->elementTypeOfJavaStream()));
}

function meta::java::generation::code::js_count(stream:Code[1]):Code[1]
{
   assert($stream.type->isJavaStream(), 'Should apply to a stream');
   $stream->j_invoke('count', [], javaLong());
}

function meta::java::generation::code::js_forEach(stream:Code[1], func:Code[1]):Code[1]
{
   $stream->prepareStreamForCallWithLambda($func)->j_invoke('forEach', $func, javaVoid());
}

function meta::java::generation::code::js_anyMatch(stream:Code[1], func:Code[1]):Code[1]
{
   $stream->prepareStreamForCallWithLambda($func)->j_invoke('anyMatch', $func, javaBoolean());
}

function meta::java::generation::code::js_noneMatch(stream:Code[1], func:Code[1]):Code[1]
{
   $stream->prepareStreamForCallWithLambda($func)->j_invoke('noneMatch', $func, javaBoolean());
}

function meta::java::generation::code::js_allMatch(stream:Code[1], func:Code[1]):Code[1]
{
   $stream->prepareStreamForCallWithLambda($func)->j_invoke('allMatch', $func, javaBoolean());
}

function meta::java::generation::code::j_toString(c:Code[1]): Code[1]
{
   $c->j_invoke('toString', [], javaString());
}


function meta::java::generation::code::j_println(s:String[1]): Code[1]
{
   j_println(j_string($s));
}

function meta::java::generation::code::j_println(msg:Code[1]): Code[1]
{
   javaSystem()->j_field('out', javaPrintStream())->j_invoke('println', $msg, javaVoid());
}

function <<access.private>> meta::java::generation::code::prepareStreamForCallWithLambda(stream: Code[1], func: Code[1]):Code[1]
{
   
   assert($stream.type->isJavaStream(), 'Should apply to a stream');
   assert($func->instanceOf(StaticMethodCall) || $func->instanceOf(StaticMethodReference) || $func.type->instanceOf(meta::java::metamodel::FunctionType), 'Should apply a function');

   if ($func->instanceOf(StaticMethodCall),| $stream->j_cast(javaStream($func.type->cast(@meta::java::metamodel::ParameterizedType).typeArguments->at(0)));,
       | $stream->j_cast(javaStream($func.type->cast(@meta::java::metamodel::FunctionType).parameterTypes->at(0))););
}

function meta::java::generation::code::js_joining(stream: Code[1]):Code[1]
{
   $stream->js_joining(j_string(''));
}

function meta::java::generation::code::js_joining(stream: Code[1], delimiter: Code[1]):Code[1]
{
   assert($stream.type->isJavaStream(), 'Should apply to a stream');
   $stream->j_invoke('collect', j_invoke(javaCollectors(), 'joining', $delimiter, javaCollector()), javaString());
}

function meta::java::generation::code::js_resolve(stream: Code[1], type: meta::java::metamodel::Type[1]):Code[1]
{
   assert($stream.type->isJavaStream(), 'Should apply to a stream');
   assert($type->instanceOf(meta::java::metamodel::ParameterizedType) || $type->instanceOf(meta::java::metamodel::Class), |'Not yet handled: ' + $type->typePathToString(true));
   ^DeferredStreamResolve(stream=$stream, type=$type);
}

function meta::java::generation::code::jo_orElse(optional: Code[1], else:Code[1]):Code[1]
{
   assert($optional.type->isJavaOptional(), 'Should apply to an Optional');
   $optional->j_invoke('orElse', $else, $optional.type->elementTypeOfJavaOptional());
}

function meta::java::generation::code::jo_orElseNull(optional: Code[1]):Code[1]
{
   assert($optional.type->isJavaOptional(), 'Should apply to an Optional');
   $optional->jo_orElse(j_null($optional.type->elementTypeOfJavaOptional()));
}

function meta::java::generation::code::j_sysout():Code[1]
{
   javaSystem()->j_field('out', javaPrintStream());
}

function meta::java::generation::code::j_syserr():Code[1]
{
   javaSystem()->j_field('out', javaPrintStream());
}

function meta::java::generation::code::j_exTryCatch(toTry:Code[1..*]): Code[1]
{ 
   let ex   = j_parameter(javaException(), 'e');
   let rtEx = j_parameter(javaRuntimeException(), 'e');

   j_try(
      $toTry,
      j_catch($rtEx, $rtEx->j_throw()),
      j_catch($ex, javaRuntimeException()->j_new($ex)->j_throw())
   );
}

function meta::java::generation::code::j_ioExTryCatch(toTry:Code[1..*]): Code[1]
{ 
   let ioEx = j_parameter(javaIOException(), 'e');

   j_try(
      $toTry,
      j_catch($ioEx, javaRuntimeException()->j_new($ioEx)->j_throw())
   );
}

function meta::java::metamodel::factory::nonNull(code:Code[1]) : Code[1]
{
   assert($code.type->instanceOf(meta::java::metamodel::FunctionType), 'Expected function type');
   ^$code(type=$code.type->cast(@meta::java::metamodel::FunctionType)->nonNull());
}

function meta::java::metamodel::factory::nullable(code:Code[1]) : Code[1]
{
   assert($code.type->instanceOf(meta::java::metamodel::FunctionType), 'Expected function type');
   ^$code(type=$code.type->cast(@meta::java::metamodel::FunctionType)->nullable());
}

// Utilities

function meta::java::generation::code::asParameters(parameters:Code[*]):meta::java::metamodel::Parameter[*]
{
   assert($parameters->forAll(p |$p->instanceOf(Parameter)), 'Parameters must be properly created (j_parameter)');
   $parameters->cast(@meta::java::metamodel::Parameter);
}

function meta::java::generation::code::classesUsed(codes: Code[*]):meta::java::metamodel::Class[*]
{
   $codes->typesUsed()->typesToClasses();
}

function meta::java::generation::code::typesUsed(codes: Code[*]):meta::java::metamodel::Type[*]
{
   $codes->map(code| $code->match([
      c:InfixExpression[1]          | $c.type->concatenate($c.left->typesUsed())->concatenate($c.right->typesUsed()),
      c:PrefixExpression[1]         | $c.type->concatenate($c.expression->typesUsed()),
      c:PostfixExpression[1]        | $c.type->concatenate($c.expression->typesUsed()),
      c:Conditional[1]              | $c.type->concatenate($c.test->concatenate($c.then)->concatenate($c.else)->typesUsed()),
      c:InstanceOf[1]               | $c.type->concatenate($c.class)->concatenate($c.expression->typesUsed()),
      c:ArrayAccess[1]              | $c.type->concatenate($c.array->typesUsed())->concatenate($c.index->typesUsed()),      
      c:CastProxy[1]                | $c.type->concatenate($c.expression->concatenate($c.proxy)->typesUsed()),
      c:Cast[1]                     | $c.type->concatenate($c.expression->typesUsed()),
      c:LocalVariableDeclaration[1] | $c.type->concatenate($c.initializer->typesUsed()),
      c:MethodCall[1]               | $c.type->concatenate($c.typeArguments)->concatenate($c.instance->typesUsed())->concatenate($c.arguments->map(a| $a->typesUsed())),
      c:FieldAccess[1]              | $c.type->concatenate($c.instance->typesUsed()),
      c:MethodReference[1]          | $c.type->concatenate($c.instance->typesUsed()),
      c:Block[1]                    | $c.type->concatenate($c.statements->typesUsed()),
      c:ExpressionStatement[1]      | $c.type->concatenate($c.expression->typesUsed()),
      c:If[1]                       | $c.type->concatenate($c.test->concatenate($c.then)->concatenate($c.else)->map(x|$x->typesUsed())),
      c:For[1]                      | $c.type->concatenate($c.init->concatenate($c.test)->concatenate($c.update)->concatenate($c.body)->map(x|$x->typesUsed())),
      c:ForEach[1]                  | $c.type->concatenate($c.parameter->concatenate($c.collection)->concatenate($c.body)->map(x|$x->typesUsed())),
      c:While[1]                    | $c.type->concatenate($c.test->concatenate($c.then)->map(x|$x->typesUsed())),
      c:DoWhile[1]                  | $c.type->concatenate($c.do->concatenate($c.while)->map(x|$x->typesUsed())),
      c:Try[1]                      | $c.type->concatenate($c.try->concatenate($c.catches)->concatenate($c.finally)->map(x|$x->typesUsed())),
      c:Catch[1]                    | $c.type->concatenate($c.clause->typesUsed()),
      c:Finally[1]                  | $c.type->concatenate($c.clause->typesUsed()),
      c:Return[1]                   | $c.type->concatenate($c.expression->typesUsed()),
      c:Throw[1]                    | $c.type->concatenate($c.expression->typesUsed()),      
      c:NewAnonymous[1]             | $c.type->concatenate($c.typeArguments)->concatenate($c.arguments->typesUsed())->concatenate($c.methods->typesUsed()),
      c:New[1]                      | $c.type->concatenate($c.typeArguments)->concatenate($c.arguments->typesUsed()),
      c:Method[1]                   | $c.type->concatenate($c.parameters->map(p|$p->typesUsed()))->concatenate($c.body->typesUsed()),
      c:StaticMethodCall[1]         | $c.type->concatenate($c.class)->concatenate($c.typeArguments)->concatenate($c.arguments->map(a| $a->typesUsed())),
      c:StaticFieldAccess[1]        | $c.type->concatenate($c.class),
      c:StaticMethodReference[1]    | $c.type->concatenate($c.class),
      c:DeferredStreamResolve[1]    | $c.type->concatenate($c.stream->typesUsed()),
      c:Lambda[1]                   | $c.type->concatenate($c.expression->typesUsed()),
      c:Code[1]                     | $c.type
   ]))->removeDuplicates();
}


//TODO Still required?
function meta::java::generation::code::methodReturnType(from:meta::java::metamodel::Type[1], methodName:String[1]):meta::java::metamodel::Type[1]
{
   let types = $from->apiKnowledge().methods->filter(m|$m.name == $methodName).returnType->removeDuplicates();
   assert($types->size() > 0,  |'Type not found for method ' + $methodName + ' from ' + $from->typePathToString(true));
   assert($types->size() == 1, |'Type ambiguous for method ' + $methodName + ' from ' + $from->typePathToString(true));
   assert(!$types->at(0)->instanceOf(meta::java::metamodel::TypeVariable), |'Type unresolved for method ' + $methodName + ' from ' + $from->typePathToString(true));
   $types->toOne();
}

function <<access.private>> meta::java::generation::code::findMethod(from:meta::java::metamodel::Type[1], methodName:String[1]):meta::java::metamodel::Method[1]
{
   let methods = $from->apiKnowledge().methods
      ->filter(m|$m.name == $methodName);
   assert($methods->size() > 0,  |'Method details not found for inference ' + $methodName + ' from ' + $from->typePathToString(true));
   assert($methods->size() == 1, |'Ambiguous details found for method ' + $methodName + ' from ' + $from->typePathToString(true));
   assert($methods.functionType->size() == 1, |'Method found does not have function type ' + $methodName + ' from ' + $from->typePathToString(true));
   $methods->toOne();
}

function meta::java::generation::code::typeForField(from:meta::java::metamodel::Type[1], fieldName:String[1]):meta::java::metamodel::Type[1]
{
   if($from->instanceOf(meta::java::metamodel::Enumeration),
      | $from,
      {|
         let types = $from->apiKnowledge().fields->filter(f|$f.name == $fieldName).type->removeDuplicates();
         assert($types->size() > 0,  |'Type not found for field ' + $fieldName + ' from ' + $from->typePathToString(true));
         assert($types->size() == 1, |'Type ambiguous for field ' + $fieldName + ' from ' + $from->typePathToString(true));
         assert(!$types->at(0)->instanceOf(meta::java::metamodel::TypeVariable), |'Type unresolved for field ' + $fieldName + ' from ' + $from->typePathToString(true));
         $types->toOne();
      }
   );
}

function meta::java::generation::code::isStatement(code: Code[1]):Boolean[1]
{
   $code->match([
      c:SimpleCode[1] | true,   // Since unkmown we rely on caller to ensure it's in the right form
      c:Statement[1]  | true,
      c:Code[1]       | false
   ]);
}

Enum meta::java::generation::code::CastCompatibility
{
   Identity, Widening, WideningAndNarrowing, Boxing, BoxingAndWidening, Unboxing, UnboxingAndWidening, Narrowing, UnboxingAndNarrowing, Disallowed, Unknown
}

function <<access.private>> meta::java::generation::code::bestCompatibility(c1:CastCompatibility[1], c2:CastCompatibility[1]):CastCompatibility[1]
{
   let compatibilities = CastCompatibility->enumValues();
   let i1 = $compatibilities->indexOf($c1);
   let i2 = $compatibilities->indexOf($c2);
   $compatibilities->at(min($i1, $i2));
}

function <<access.private>> meta::java::generation::code::castCompatibility(from:meta::java::metamodel::Type[1], to:meta::java::metamodel::Type[1]):CastCompatibility[1]
{
   $from->match([
      {fromP:meta::java::metamodel::PrimitiveType[1] |
         $to->match([
            {toP:meta::java::metamodel::PrimitiveType[1] | 
               if($fromP.simpleName == $toP.simpleName,
                  | CastCompatibility.Identity,
                  |
               if($fromP.simpleName == 'byte' && $toP.simpleName == 'char',
                  | CastCompatibility.WideningAndNarrowing,
                  |
               if($fromP.simpleName == 'byte' && $toP.simpleName->in(['short', 'int', 'long', 'float', 'double']),
                  | CastCompatibility.Widening,
                  |
               if($fromP.simpleName == 'short' && $toP.simpleName->in(['byte', 'char']),
                  | CastCompatibility.Narrowing,
                  |
               if($fromP.simpleName == 'short' && $toP.simpleName->in(['int', 'long', 'float', 'double']),
                  | CastCompatibility.Widening,
                  |
               if($fromP.simpleName == 'char' && $toP.simpleName->in(['byte', 'short']),
                  | CastCompatibility.Narrowing,
                  |
               if($fromP.simpleName == 'char' && $toP.simpleName->in(['int', 'long', 'float', 'double']),
                  | CastCompatibility.Widening,
                  |
               if($fromP.simpleName == 'int' && $toP.simpleName->in(['byte', 'short', 'char']),
                  | CastCompatibility.Narrowing,
                  |
               if($fromP.simpleName == 'int' && $toP.simpleName->in(['long', 'float', 'double']),
                  | CastCompatibility.Widening,
                  |
               if($fromP.simpleName == 'long' && $toP.simpleName->in(['byte', 'short', 'char', 'int']),
                  | CastCompatibility.Narrowing,
                  |
               if($fromP.simpleName == 'long' && $toP.simpleName->in(['float', 'double']),
                  | CastCompatibility.Widening,
                  |
               if($fromP.simpleName == 'float' && $toP.simpleName->in(['byte', 'short', 'char', 'int', 'long']),
                  | CastCompatibility.Narrowing,
                  |
               if($fromP.simpleName == 'float' && $toP.simpleName->in(['double']),
                  | CastCompatibility.Widening,
                  |
               if($fromP.simpleName == 'double' && $toP.simpleName->in(['byte', 'short', 'char', 'int', 'long', 'float']),
                  | CastCompatibility.Narrowing,
                  | CastCompatibility.Disallowed
               ))))))))))))));
            },
            {toC:meta::java::metamodel::Class[1] |
               if($fromP.simpleName == 'byte' && $toC->isClass('java.lang', 'Byte'),
                  | CastCompatibility.Boxing,
                  |
               if($fromP.simpleName == 'byte' && $toC->isClass('java.lang', ['Short', 'Character', 'Integer', 'Long', 'Float', 'Double', 'Number', 'Object']),
                  | CastCompatibility.BoxingAndWidening,
                  |
               if($fromP.simpleName == 'short' && $toC->isClass('java.lang', 'Short'),
                  | CastCompatibility.Boxing,
                  |
               if($fromP.simpleName == 'short' && $toC->isClass('java.lang', ['Integer', 'Long', 'Float', 'Double', 'Number', 'Object']),
                  | CastCompatibility.BoxingAndWidening,
                  |
               if($fromP.simpleName == 'char' && $toC->isClass('java.lang', 'Character'),
                  | CastCompatibility.Boxing,
                  |
               if($fromP.simpleName == 'char' && $toC->isClass('java.lang', ['Integer', 'Long', 'Float', 'Double', 'Number', 'Object']),
                  | CastCompatibility.BoxingAndWidening,
                  |
               if($fromP.simpleName == 'int' && $toC->isClass('java.lang', 'Integer'),
                  | CastCompatibility.Boxing,
                  |
               if($fromP.simpleName == 'int' && $toC->isClass('java.lang', ['Long', 'Float', 'Double', 'Number', 'Object']),
                  | CastCompatibility.BoxingAndWidening,
                  |
               if($fromP.simpleName == 'long' && $toC->isClass('java.lang', 'Long'),
                  | CastCompatibility.Boxing,
                  |
               if($fromP.simpleName == 'long' && $toC->isClass('java.lang', ['Float', 'Double', 'Number', 'Object']),
                  | CastCompatibility.BoxingAndWidening,
                  |
               if($fromP.simpleName == 'float' && $toC->isClass('java.lang', 'Float'),
                  | CastCompatibility.Boxing,
                  |
               if($fromP.simpleName == 'float' && $toC->isClass('java.lang', ['Double', 'Number', 'Object']),
                  | CastCompatibility.BoxingAndWidening,
                  |
               if($fromP.simpleName == 'double' && $toC->isClass('java.lang', 'Double'),
                  | CastCompatibility.Boxing,
                  |
               if($fromP.simpleName == 'double' && $toC->isClass('java.lang', ['Number', 'Object']),
                  | CastCompatibility.BoxingAndWidening,
                  |
               if($fromP.simpleName == 'boolean' && $toC->isClass('java.lang', 'Boolean'),
                  | CastCompatibility.Boxing,
                  |
               if($fromP.simpleName == 'boolean' && $toC->isClass('java.lang', 'Object'),
                  | CastCompatibility.BoxingAndWidening,
                  | CastCompatibility.Disallowed
               ))))))))))))))));
            },
            {a:Any[1] | CastCompatibility.Disallowed }
         ])
      },
      {fromC:meta::java::metamodel::Class[1] |
         $to->match([
            {toP:meta::java::metamodel::PrimitiveType[1] | 
               if($fromC->isInPackage('java.lang'),
                  {| 
                     if($fromC.simpleName == 'Byte' && $toP.simpleName == 'byte',
                        | CastCompatibility.Unboxing,
                        |
                     if($fromC.simpleName == 'Byte' && $toP.simpleName->in(['short', 'int', 'long', 'float', 'double']),
                        | CastCompatibility.UnboxingAndWidening,
                        |
                     if($fromC.simpleName == 'Short' && $toP.simpleName == 'short',
                        | CastCompatibility.Unboxing,
                        |
                     if($fromC.simpleName == 'Short' && $toP.simpleName->in(['int', 'long', 'float', 'double']),
                        | CastCompatibility.UnboxingAndWidening,
                        |
                     if($fromC.simpleName == 'Character' && $toP.simpleName == 'char',
                        | CastCompatibility.Unboxing,
                        |
                     if($fromC.simpleName == 'Character' && $toP.simpleName->in(['int', 'long', 'float', 'double']),
                        | CastCompatibility.UnboxingAndWidening,
                        |
                     if($fromC.simpleName == 'Integer' && $toP.simpleName == 'int',
                        | CastCompatibility.Unboxing,
                        |
                     if($fromC.simpleName == 'Integer' && $toP.simpleName->in(['long', 'float', 'double']),
                        | CastCompatibility.UnboxingAndWidening,
                        |
                     if($fromC.simpleName == 'Long' && $toP.simpleName == 'long',
                        | CastCompatibility.Unboxing,
                        |
                     if($fromC.simpleName == 'Long' && $toP.simpleName->in(['float', 'double']),
                        | CastCompatibility.UnboxingAndWidening,
                        |
                     if($fromC.simpleName == 'Float' && $toP.simpleName == 'float',
                        | CastCompatibility.Unboxing,
                        |
                     if($fromC.simpleName == 'Float' && $toP.simpleName->in(['double']),
                        | CastCompatibility.UnboxingAndWidening,
                        |
                     if($fromC.simpleName == 'Double' && $toP.simpleName == 'double',
                        | CastCompatibility.Unboxing,
                        |
                     if($fromC.simpleName == 'Boolean' && $toP.simpleName == 'boolean',
                        | CastCompatibility.Unboxing,
                        |
                     if($fromC.simpleName == 'Number' && $toP.simpleName->in(['byte', 'short', 'char', 'int', 'long', 'float', 'double']),
                        | CastCompatibility.UnboxingAndNarrowing,
                        |
                     if($fromC.simpleName == 'Object',
                        | CastCompatibility.UnboxingAndNarrowing,
                        | CastCompatibility.Disallowed
                     ))))))))))))))));
                  },
                  |  CastCompatibility.Disallowed
               );
            },
            {toC:meta::java::metamodel::Class[1] |
               if($fromC == $toC,
                  | CastCompatibility.Identity,
                  | 
               if($fromC->isSubclassOf($toC),
                  | CastCompatibility.Narrowing,
                  | 
               if($toC->isSubclassOf($fromC),
                  | CastCompatibility.Widening,
                  | CastCompatibility.Unknown    // If further sitauations can be reliably identified they can be added here but JLS (SE 8) 5.5.1 is difficult to implement with the criteria known here
               )));
            },
            {a:Any[1] | CastCompatibility.Unknown }
         ])
      },
      {a:Any[1] | CastCompatibility.Unknown }
   ]);
}

function <<access.private>> meta::java::generation::code::isClass(c:meta::java::metamodel::Class[1], pkg:String[1], names:String[*]):Boolean[1]
{
   $c->isInPackage($pkg) && $c.simpleName->in($names);   
}

function <<access.private>> meta::java::generation::code::isSubclassOf(c1:meta::java::metamodel::Class[1], c2:meta::java::metamodel::Class[1]):Boolean[1]
{
   if($c1 == $c2 || $c2 == javaObject(),
      | true,
      | 
   if($c1.superType->isNotEmpty(),
      | $c1.superType->cast(@meta::java::metamodel::Class)->toOne()->isSubclassOf($c2),
      |
   if($c1->isClass('java.lang', 'Byte'),
      | $c2->isClass('java.lang', ['Short', 'Character', 'Integer', 'Long', 'Float', 'Double', 'Number']),
      |
   if($c1->isClass('java.lang', 'Short'),
      | $c2->isClass('java.lang', ['Character', 'Integer', 'Long', 'Float', 'Double', 'Number']),
      |
   if($c1->isClass('java.lang', 'Character'),
      | $c2->isClass('java.lang', ['Integer', 'Long', 'Float', 'Double', 'Number']),
      |
   if($c1->isClass('java.lang', 'Integer'),
      | $c2->isClass('java.lang', ['Long', 'Float', 'Double', 'Number']),
      |
   if($c1->isClass('java.lang', 'Long'),
      | $c2->isClass('java.lang', ['Float', 'Double', 'Number']),
      |
   if($c1->isClass('java.lang', 'Float'),
      | $c2->isClass('java.lang', ['Double', 'Number']),
      |
   if($c1->isClass('java.lang', 'Double'),
      | $c2->isClass('java.lang', 'Number'),
      | false
   )))))))));
}

function <<access.private>> meta::java::generation::code::blockIfNot(code: Code[1]):Code[1]
{
   if($code->instanceOf(Block), |$code, |j_block($code));
}

function meta::java::generation::code::toStatements(codes: Code[*]):Code[*]
{
   $codes->fold(
      {c, a|
         let l = $a.first;
         let n = $a.second;

         if($c->isStatement() || $c->instanceOf(Method),
            | pair(list($l.values->add($c)), $n),
            |
         if($c->isValidExpressionAsStatement(),
            | pair(list($l.values->add($c->j_expressionStatement())), $n),
            |
         if($c.type == javaVoid(),
            | $a,
            | pair(list($l.values->add(j_variable($c.type, '_dummy_'+$n->toString())->j_declare($c))), $n+1)
         )));
      },
      pair(^List<Code>(), 1)
   ).first.values;
}

function meta::java::generation::code::isNull(expression:Code[1]):Boolean[1]
{
   if($expression->instanceOf(Null),
      | true,
      | false
   )
}


function meta::java::generation::code::isSameLiteral(left:Code[1], right:Code[1]):Boolean[1]
{
   if($left->instanceOf(Literal) && $right->instanceOf(Literal)
                                 && $left->cast(@Literal).type == $right->cast(@Literal).type
                                 && $left->cast(@Literal).literal == $right->cast(@Literal).literal,
   | true;,
   | false;
   );
}


function meta::java::generation::code::isValidExpressionAsStatement(expression:Code[1]):Boolean[1]
{
   $expression->match([
      pre : PrefixExpression[1]  | $pre.op->in(['++', '--']),
      post: PostfixExpression[1] | $post.op->in(['++', '--']),
      inf : InfixExpression[1]   | $inf.op->in(assignmentOperators()),
      mc  : MethodCall[1]        | true,
      smc : StaticMethodCall[1]  | true,
      new : New[1]               | true,
      c   : Code[1]              | false
   ])
}

function meta::java::generation::code::isAssignment(c:Code[1]):Boolean[1]
{
   $c->match([
      inf : InfixExpression[1] | $inf.op->in(assignmentOperators()),
      c   : Code[1]            | false
   ])
}

function meta::java::generation::code::variableAssigned(c:Code[1]):Code[1]
{
   assert($c->isAssignment(), 'Not an assignment');
   $c->cast(@InfixExpression).left;
}

function meta::java::generation::code::expressionAssigned(c:Code[1]):Code[1]
{
   assert($c->isAssignment() || $c->isDeclarationWithAssignment(), 'Does not contain as assigned expression');
   $c->match([
      inf : InfixExpression[1]          | $inf.right,
      lvd : LocalVariableDeclaration[1] | $lvd.initializer->toOne()
   ]);
}

function meta::java::generation::code::isDeclaration(c:Code[1]):Boolean[1]
{
   $c->match([
      lvd : LocalVariableDeclaration[1] | true,
      c   : Code[1]                     | false
   ]);
}

function meta::java::generation::code::isDeclarationWithAssignment(c:Code[1]):Boolean[1]
{
   $c->match([
      lvd : LocalVariableDeclaration[1] | !$lvd.initializer->isEmpty(),
      c   : Code[1]                     | false
   ]);
}

function meta::java::generation::code::isCollectionsEmptyList(c:Code[1]):Boolean[1]
{
   $c->match([
      smc:StaticMethodCall[1] | $smc.class == javaCollections() && $smc.methodName == 'emptyList',
      c  :Code[1]             | false
   ]);
}

function meta::java::generation::code::variableDeclared(c:Code[1]):Code[1]
{
   assert($c->isDeclaration(), 'Not a declaration');
   j_variable($c.type, $c->cast(@LocalVariableDeclaration).variableName);
}

function meta::java::generation::code::isDeprecated(c:Code[1]):Boolean[1]
{
   $c->instanceOf(SimpleCode);
}

function meta::java::generation::code::isParameter(c:Code[1]):Boolean[1]
{
   $c->instanceOf(Parameter);   
}

function meta::java::generation::code::parameterName(c:Code[1]):String[1]
{
   $c->cast(@Parameter).name;   
}

function meta::java::generation::code::isVariable(c:Code[1]):Boolean[1]
{
   $c->instanceOf(Variable);   
}

function meta::java::generation::code::variableName(c:Code[1]):String[1]
{
   $c->cast(@Variable).name;   
}

// Dependencies
function meta::java::generation::code::dependsOn(code:Code[1], dependencies:CodeDependency[*]):Code[1]
{
   ^$code(requires=$code.requires->concatenate($dependencies)->removeDuplicates());
}

function meta::java::generation::code::methodsDependency(class:meta::java::metamodel::Class[1], methodNames:String[*]):CodeDependency[1]
{
   let depClass = ^$class(methods=$class.methods->filter(m| $m.name->in($methodNames)));

   newDependency($class->typePathToString(true)+$methodNames->joinStrings('[', '&', ']'), $depClass);
}

function meta::java::generation::code::newDependency(name:String[1], classes:meta::java::metamodel::Class[*]):CodeDependency[1]
{
   newDependency($name, newProject()->addClasses($classes));
}

function meta::java::generation::code::newDependency(name:String[1], project:Project[1]):CodeDependency[1]
{
   newDependency($name, {state| $state->addProjectIfMissing($name, {|$project})});
}

function meta::java::generation::code::newDependency(name:String[1], stateUpdater:Function<{CodeDependencyResolutionState[1]->CodeDependencyResolutionState[1]}>[1]):CodeDependency[1]
{
   ^CodeDependency(name=$name, stateUpdater=$stateUpdater);
}

function meta::java::generation::code::addProjectIfMissing(state:CodeDependencyResolutionState[1], name:String[1], projectSupplier:Function<{->Project[1]}>[1]):CodeDependencyResolutionState[1]
{
   if($state.projectsByDependency->keys()->contains($name),
      | $state,
      | $state->addDependencyProject($name, $projectSupplier->eval())
   );
}

function meta::java::generation::code::addDependencyProject(state:CodeDependencyResolutionState[1], name:String[1], project:Project[1]):CodeDependencyResolutionState[1]
{
   ^$state(projectsByDependency=$state.projectsByDependency->put($name, $project));
}

function meta::java::generation::code::resolveProjects(dependencies:CodeDependency[*]):CodeDependencyResolutionState[1]
{
   $dependencies->resolveProjects(^CodeDependencyResolutionState(projectsByDependency=^Map<String, Project>()));
}

function meta::java::generation::code::resolveProjects(dependencies:CodeDependency[*], state:CodeDependencyResolutionState[1]):CodeDependencyResolutionState[1]
{
   $dependencies->fold({d, s| $d.stateUpdater->eval($s)}, $state);
}

function meta::java::generation::code::getProjects(state:CodeDependencyResolutionState[1], dependencies:CodeDependency[*]):Project[*]
{
   $state.projectsByDependency->keyValues()->filter({kv|$kv.first->in($dependencies.name)}).second;
}

function meta::java::generation::code::getProjects(state:CodeDependencyResolutionState[1]):Project[*]
{
   $state.projectsByDependency->keyValues().second;
}

function meta::java::generation::code::resolveAndGetProjects(dependencies:CodeDependency[*]):Project[*]
{
   $dependencies->resolveProjects()->getProjects();
}




function meta::java::metamodel::project::newProject(): Project[1]
{
   newProject('dummy', 'dummy', 'dummy');
}

function meta::java::metamodel::project::newProject(group:String[1], artifact:String[1], version:String[1]): Project[1]
{
   newProject(^MavenReference(group=$group, artifact=$artifact, version=$version));
}

function meta::java::metamodel::project::newProject(id: MavenReference[1]): Project[1]
{
   ^Project(id=$id, root=^ProjectDirectory(name='ROOT'));
}

function meta::java::metamodel::project::addClasses(project: Project[1], classes: meta::java::metamodel::Class[*]): Project[1]
{
   $classes->fold({c,p| $p->addClass($c)}, $project);
}

function meta::java::metamodel::project::addClass(project: Project[1], class: meta::java::metamodel::Class[1]): Project[1]
{
   $project->addClass('src/main/java', $class);
}

function meta::java::metamodel::project::addFile(project: Project[1], path:String[1], file:File[1]): Project[1]
{
   ^$project(root=$project.root->ensurePathAndDo($path->split('/'), {d|$d->addToProjectDirectory($file)}));
}

function meta::java::metamodel::project::addMavenDependency(project:Project[1], group:String[1], artifact:String[1], version:String[1]): Project[1]
{
   ^$project(
      mainDependencies = $project.mainDependencies->concatenate(^MavenReference(group=$group, artifact=$artifact, version=$version))->removeDuplicates()
   )
}

function meta::java::metamodel::project::replaceClass(project: Project[1], class: meta::java::metamodel::Class[1]): Project[1]
{
   $project->replaceClass('src/main/java', $class);
}

function meta::java::metamodel::project::addClass(project: Project[1], path:String[1], class: meta::java::metamodel::Class[1]): Project[1]
{
   ^$project(root=$project.root->ensurePathAndDo($path->split('/'), {d|$d->addToProjectDirectory($class)}));
}

function meta::java::metamodel::project::replaceClass(project: Project[1], path:String[1], class: meta::java::metamodel::Class[1]): Project[1]
{
   ^$project(root=$project.root->ensurePathAndDo($path->split('/'), {d|$d->replaceInProjectDirectory($class)}));
}

function meta::java::metamodel::project::containsClass(project:Project[1], class:meta::java::metamodel::Class[1]): Boolean[1]
{
   $project->containsClass($class->typePathToString(true));
}

function meta::java::metamodel::project::containsClass(project:Project[1], fullClassName:String[1]): Boolean[1]
{
   $project->containsClass('src/main/java', $fullClassName);
}

function meta::java::metamodel::project::containsClass(project:Project[1], path:String[1], fullClassName:String[1]): Boolean[1]
{
   $project->getClass($path, $fullClassName)->isNotEmpty();
}

function meta::java::metamodel::project::resolve(project: Project[1], class:meta::java::metamodel::Class[1]): meta::java::metamodel::Class[1]
{
   let resolved = $project->getClass($class);
   if($resolved->isEmpty(), |$class, |$resolved->toOne());
}

function meta::java::metamodel::project::getClass(project: Project[1], class:meta::java::metamodel::Class[1]): meta::java::metamodel::Class[0..1]
{
   $project->getClass('src/main/java', $class->typePathToString(true));
}

function meta::java::metamodel::project::getClass(project: Project[1], path:String[1], className: String[1]): meta::java::metamodel::Class[0..1]
{
   let pathNames = $path->split('/');
   let baseDir   = $pathNames->fold({name:String[1],d:ProjectDirectory[*]| if($d->isEmpty(), |[], |$d.subdirectories->filter(sd|$sd.name == $name))}, $project.root);

   let dotPos    = $className->lastIndexOf('.');
   let clsName   = $className->substring($dotPos+1);
   let pkgNames  = $className->substring(0, $dotPos)->split('.');
   let dir       = $pkgNames->fold({name:String[1],d:ProjectDirectory[*]| if($d->isEmpty(), |[], |$d.subdirectories->filter(sd|$sd.name == $name))}, $baseDir);
   let classes   = $dir->map(d|$d.classes->filter(c|$c.simpleName == $clsName));

   assert($classes->size() < 2, |'Unexpectedly found duplicate class ' + $className);
   $classes->first();
}

function meta::java::metamodel::project::allClasses(project: Project[1]): meta::java::metamodel::Class[*]
{
   $project->allDirectories().classes;
}

function meta::java::metamodel::project::allDirectories(project: Project[1]): ProjectDirectory[*]
{
   $project.root->allSubDirectories();
}

function meta::java::metamodel::project::mergeProjects(projects: Project[1..*]): Project[1]
{
   let base = $projects->at(0);
   $projects->tail()->fold({p, b|$b->mergeProject($p)}, $base);
}

function meta::java::metamodel::project::mergeProjectsNullable(projects: Project[*]): Project[0..1]
{
   $projects->match([
      p : Project[0..1] | $p,
      ps: Project[1..*] | mergeProjects($ps)
   ]);
}

function <<access.private>> meta::java::metamodel::project::mergeProject(base: Project[1], addition: Project[1]): Project[1]
{
   let withDirsAdded = $addition->allDirectories()->fold({d, p|$p->mergeDirectory($d)}, $base);
   ^$withDirsAdded(mainDependencies=$base.mainDependencies->concatenate($addition.mainDependencies)->removeDuplicates());
}

function <<access.private>> meta::java::metamodel::project::mergeDirectory(base: Project[1], dir: ProjectDirectory[1]): Project[1]
{
   $dir.classes->fold({c, p|$p->mergeClass($dir, $c)}, $base);
}

function <<access.private>> meta::java::metamodel::project::mergeClass(base: Project[1], dir: ProjectDirectory[1], class: meta::java::metamodel::Class[1]): Project[1]
{
   let srcDirPath = findSrcDir($dir, $class.package).fullPath();
   let classFullName = $class.package->packageToString() + '.' + $class.simpleName;
   if(!$base->containsClass($srcDirPath, $classFullName),
      {| $base->addClass($srcDirPath, $class)},
      {|
         let existing = $base->getClass($srcDirPath, $classFullName)->toOne();

         let superType = if($existing.superType->isEmpty(),
                            {|$class.superType},
                            |
                         if($class.superType->isEmpty(),
                            {|$existing.superType},
                            {|
                               assert($existing.superType == $class.superType, |'Cannot change superType from ' + $existing.superType->toOne()->typePathToString(true) + ' to ' + $class.superType->toOne()->typePathToString(true));
                               $existing.superType;
                            }
                         ));

         let interfaces = $existing.interfaces->concatenate($class.interfaces)->map(i|$i->typePathToString(true))->removeDuplicates()->map(i|$i->javaType());
         
         let newlyDefined = $class.methods->filter({newMethod|
            let existingMethod = $existing.methods->filter({m| $m.name == $newMethod.name && $m.parameters.type == $newMethod.parameters.type});
            assert($existingMethod->isEmpty() || $existingMethod->toOne().body == $newMethod.body, | 'Cannot merge implementations of ' + $newMethod->methodSignature() + ' in ' + $classFullName);
            $existingMethod->isEmpty();
         });
         
         let methods = $existing.methods->concatenate($newlyDefined);

         $base->replaceClass(^$existing(superType=$superType, interfaces=$interfaces, methods=$methods));
      }
   );
}

function <<access.private>> meta::java::metamodel::project::findSrcDir(dir: ProjectDirectory[1], pkg: meta::java::metamodel::Package[1]): ProjectDirectory[1]
{
   assert($dir.name == $pkg.name);
   $pkg.parent->match([
      p0: meta::java::metamodel::Package[0] | $dir.parent->toOne(),
      p : meta::java::metamodel::Package[1] | findSrcDir($dir.parent->toOne(), $p)
   ]);
}

function <<access.private>> meta::java::metamodel::project::addToProjectDirectory(dir: ProjectDirectory[1], class: meta::java::metamodel::Class[1]): ProjectDirectory[1]
{
   let dirNames = $class.package->packageToDirectoryNames();
   $dir->ensurePathAndDo($dirNames, d|^$d(classes=$d.classes->concatenate($class)->sortBy(c|$c.simpleName)));
}

function <<access.private>> meta::java::metamodel::project::addToProjectDirectory(dir: ProjectDirectory[1], file:File[1]): ProjectDirectory[1]
{
   assert(!$dir.files->exists(f| $f.name == $file.name), |$dir.fullPath() + ' already contains a file named ' + $file.name);
   ^$dir(files=$dir.files->concatenate($file)->sortBy(f|$f.name));
}

function <<access.private>> meta::java::metamodel::project::replaceInProjectDirectory(dir: ProjectDirectory[1], class: meta::java::metamodel::Class[1]): ProjectDirectory[1]
{
   let dirNames = $class.package->packageToDirectoryNames();
   $dir->ensurePathAndDo($dirNames, d|^$d(classes=$d.classes->filter(c|$c.simpleName != $class.simpleName)->concatenate($class)->sortBy(c|$c.simpleName)));
}

function <<access.private>> meta::java::metamodel::project::allSubDirectories(dir: ProjectDirectory[1]): ProjectDirectory[*]
{
   $dir.subdirectories->fold({d, acc|$acc->concatenate($d)->concatenate($d->allSubDirectories())}, []);
}

function <<access.private>> meta::java::metamodel::project::ensurePathAndDo(dir: ProjectDirectory[1], dirNames: String[*], action: Function<{ProjectDirectory[1]->ProjectDirectory[1]}>[1]): ProjectDirectory[1]
{
   let nextName = $dirNames->at(0);
   let tail     = $dirNames->tail();

   let nextDir = $dir.subdirectories->filter(sd|$sd.name == $nextName)->match([
      d0: ProjectDirectory[0] | ^ProjectDirectory(name=$nextName, parent=$dir),
      d : ProjectDirectory[1] | $d,
      ds: ProjectDirectory[*] | fail('Unexpectedly found duplicate dir: ' + $ds.name->makeString('[', ',' ,']')); $ds->at(0);
   ]);

   let newNextDir = $tail->match([
      n : String[0] | $action->eval($nextDir),
      ns: String[*] | $nextDir->ensurePathAndDo($ns, $action)
   ]);

   let newSubdirs = $dir.subdirectories->filter(sd|$sd.name != $nextName)->concatenate($newNextDir)->sortBy(d|$d.name);
   ^$dir(subdirectories=$newSubdirs);
}

function <<access.private>> meta::java::metamodel::project::packageToDirectoryNames(pkg: meta::java::metamodel::Package[1]): String[*]
{
   if($pkg.parent->isEmpty(), |[], |$pkg.parent->toOne()->packageToDirectoryNames())
      ->concatenate([$pkg.name]);
}
