// Copyright 2020 Goldman Sachs
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import meta::json::schema::tests::*;
import meta::java::codeGeneration::convention::*;
import meta::java::codeGeneration::utils::*;
import meta::json::schema::fromSchema::tests::*;
import meta::json::schema::fromSchema::*;
import meta::pure::metamodel::serialization::grammar::*;
import meta::json::*;
import meta::json::schema::*;


Class meta::json::schema::fromSchema::SchemaTransformRequest
{
   
   jsonSchemas:meta::json::schema::fromSchema::SchemaInput[*];
   packagePrefix:String[0..1];
}


Class meta::json::schema::fromSchema::SchemaInput
{
   fileName:String[1];
   schema:String[1];
   pathPrefix:String[0..1];
   
}

function meta::json::schema::fromSchema::JSONSchemaToPure(schemas:SchemaInput[*]):PackageableElement[*]
{
   
   let processed = $schemas->map(s|$s->processSchema());  
   let processedWithSuperType = $processed->JSONSchemaSuperTypes();
   let pathSchemas = $processedWithSuperType->map(s | pair($s.fileName,$s);)->newMap();
   $pathSchemas->values()->map(s |if( JSONSchemaIsObject($s.parsedSchema),
                                               |JSONSchemaToClass($s.fileName,$s,$pathSchemas,$s.pathPrefix),
                                               | if(JSONSchemaIsEnum($s.parsedSchema),
                                                    |JSONSchemaToEnum($s.fileName,$s.parsedSchema,$s.pathPrefix),
                                                    |fragmentToFunction($s.fileName,$s.parsedSchema,$s.pathPrefix)
                                                    )
                                     );
                                  );
   
} 

function meta::json::schema::fromSchema::JSONSchemaRemoveRef(schemas:SchemaInput[*]):SchemaInput[*]
{
   let schemaMap =  $schemas->map(s | pair($s.fileName,$s->processSchema()))->newMap();
   $schemaMap->values()->filter(s|$s.schemaType!=SchemaType.fragment)->map(s |  ^SchemaInput(fileName = $s.fileName,schema =  $s.parsedSchema->  deReferenceElement($s.fileName,$schemaMap,[])->toCompactJSONString()));
}

 
function <<access.private>> meta::json::schema::fromSchema::deReferenceElement(element:JSONElement[1],parentFile:String[1], schemas:Map<String,ProcessedSchema>[1],key:String[0..1]):JSONElement[1]
{
   //this matches how schema fragments are handled on josn generation. A ref to a fragment will get dissolved into whatever is callling it . 
   let filteredKeys = ['description','title','$schema'];
   
   $element->match([o:JSONObject[1]|^$o(keyValuePairs = $o.keyValuePairs->filter(kv| !($key=='$ref'  && $kv.key.value->in($filteredKeys)) )  
                                                                         ->map(k| let newValue = $k.value->deReferenceElement($parentFile,$schemas,$k.key.value);   
                                                                                  if($k.key.value=='$ref' && $newValue->instanceOf(JSONObject),
                                                                                           |$newValue->cast(@JSONObject).keyValuePairs,
                                                                                            |^$k(value=$k.value->deReferenceElement($parentFile,$schemas,$k.key.value))
                                                                                    );
                                                                              ));,
                    a:JSONArray[1]| ^$a(values = $a.values->map(v|$v->deReferenceElement($parentFile,$schemas,$key)) ),
                    s:JSONString[1]| if($key=='$ref',
                                           |let refschema = $schemas->get( $s.value->refToFullPath($parentFile));
                                            if($refschema->isNotEmpty() && $refschema.schemaType ==SchemaType.fragment,
                                                   | $refschema.parsedSchema->toOne()->deReferenceElement($refschema.fileName->toOne(),$schemas,$key),
                                                   |$s);,
                                          |$s),            
                    n:JSONNumber[1]| $n,
                    b:JSONBoolean[1]| $b,     
                    e:JSONElement[1]| $e]);
    
}


function <<access.private>> meta::json::schema::fromSchema::processSchema(schema:SchemaInput[1]):ProcessedSchema[1]
{
    let parsedSchema = $schema.schema->meta::json::parseJSON()->cast(@JSONObject);
    let schemaType = if( JSONSchemaIsObject($parsedSchema),
                          |SchemaType.object,
                          |  if( JSONSchemaIsEnum($parsedSchema),
                               | SchemaType.enum,
                               |SchemaType.fragment
                               )
                        ); 
                         
    let anyOf=  $parsedSchema.keyValuePairs->getValueForKey('anyOf');
    let subTypes = if($anyOf->isNotEmpty() && $anyOf->toOne()->instanceOf(JSONArray),
                      | let refs = $anyOf->cast(@JSONArray).values->map(v |$v->cast(@JSONObject).keyValuePairs->getValueForKey('$ref'));
                        if($refs->isNotEmpty(),
                           |$refs->map(r|$r->cast(@JSONString).value->refToFullPath($schema.fileName));,
                           |[]);,
                       | [] );
                  
   
   ^ProcessedSchema(fileName=$schema.fileName,
                     schema=$schema.schema,
                     pathPrefix=$schema.pathPrefix,
                     parsedSchema=$parsedSchema,
                     subTypes = $subTypes,
                    schemaType = $schemaType
                    );  
                                       

}


function <<access.private>> meta::json::schema::fromSchema::JSONSchemaIsObject(schema:JSONObject[1]):Boolean[1]
{
   
   let type = $schema.keyValuePairs->getValueForKey('type');
   $type->isNotEmpty() && ( $type->cast(@JSONString).value->toOne() == 'object');
}

function <<access.private>> meta::json::schema::fromSchema::JSONSchemaSuperTypes(schemas:ProcessedSchema[*]):ProcessedSchema[*]
{
   let subTypetoSuperType = $schemas->map(s| $s.subTypes->map( st | pair($st,$s.fileName)));
   let grouped = $subTypetoSuperType->groupBy( s |$s.first);
   $schemas->map(s | ^$s(superTypes =$grouped->get($s.fileName).values.second ););
}


function <<access.private>> meta::json::schema::fromSchema::JSONSchemaIsEnum(schema:JSONObject[1]):Boolean[1]
{
   
   let type = $schema.keyValuePairs->getValueForKey('enum');
   $type->isNotEmpty();
}

function <<access.private>> meta::json::schema::fromSchema::JSONSchemaToEnum(path:String[1],schema:JSONObject[1],pathPrefix:String[0..1]):Enumeration<Any>[1]
{
   
   let name = $path->refToFileName();
   let javaType = $schema.keyValuePairs->getValueForKey('javaType')->cast(@JSONString).value->first();
   let description = $schema.keyValuePairs->getValueForKey('description')->cast(@JSONString).value->first();

   let defaultValue = $schema.keyValuePairs->getValueForKey('default');
    let default =  if($defaultValue->isNotEmpty(),
                     | $defaultValue->toOne()->  match([s:JSONString[1]|$s.value,
                                                        n:JSONNumber[1] |$n.value])->makeString();,
                       |[]);
   
   let package = $path->packageFromPath($pathPrefix);

   let values = $schema.keyValuePairs->getValueForKey('enum')->cast(@JSONArray).values->cast(@JSONString).value->filter(v|$v!='');
   
   let santizedValues = $values->map(v| let sanitized = $v-> sanitizeValue(); 
                                                    if($sanitized == $v ,
                                                       | $v,
                                                       |$sanitized );) ;//add tag for v if we can
  let valuesMap = $santizedValues->zip($values)->newMap();
  let enum =  newEnumeration($package+$name,$santizedValues);
  let enumValues = $enum->enumValues()->map( v:Enum[1]   | 
                                                    let original = $valuesMap->get($v->id())->toOne();
                                                   if($original!=$v->id(),
                                                      |let e = $v->cast(@ElementWithTaggedValues)->addTag(meta::java::enumValue,'name',$original)->cast(@Enum);
                                                        ^$e(name=$v->id()); ,
                                                      |^$v(name=$v->id()));
                                    )->toOneMany();   
   
  
   let result = ^$enum(values=$enumValues)->cast(@ElementWithTaggedValues)->addTag(doc,'doc',$description)->addTag(JSONSchemaGeneration,'javaType',$javaType)->addTag(JSONSchemaGeneration,'defaultValue',$default)->cast(@Enumeration<Any>);
}


function  <<access.private>> meta::json::schema::fromSchema::sanitizeValue(value:String[1]):String[1]
{
  //TODO: This may not be good enough if two different enums santize to the same value
   let alphaNumeric = $value->chunk(1)->map(s|if($s->matches('[A-Za-z0-9]'),|$s,|'_'))->joinStrings();
    if( ['0','1','2','3','4','5','6','7','8','9']->contains($alphaNumeric->substring(0, 1)),|'_'+$alphaNumeric,|$alphaNumeric);

}

function  <<access.private>> meta::json::schema::fromSchema::createConstraintFunctionExpression(fileName:String[1],functionName:String[1],valueType:Type[1],pathPrefix:String[0..1],property:Property<Nil, Any|*>[1]):SimpleFunctionExpression[1]
{
               let propertyParam = propertyParameter($property);
             let func = createConstraintFunctionDefinition($fileName,$functionName,$valueType,$pathPrefix)->evaluateAndDeactivate();
               let result = ^SimpleFunctionExpression(func = $func, 
                   importGroup = system::imports::coreImport,
                    genericType = $func->toOne()->functionReturnType(),
                    multiplicity = $func->toOne()->functionReturnMultiplicity(),
                     functionName = $func.functionName,
                      parametersValues =$propertyParam
                  );
 }

function <<access.private>> meta::json::schema::fromSchema::propertyParameter(property:Property<Nil, Any|*>[1]):SimpleFunctionExpression[1]
{
   ^SimpleFunctionExpression(func=$property,
                            genericType=$property.genericType,
                            multiplicity=$property.multiplicity,
                            importGroup = system::imports::coreImport,
                            parametersValues= ^VariableExpression(name='this',multiplicity=PureOne,genericType=^GenericType(rawType=Any)),
                            propertyName=^InstanceValue(values=$property.name->toOne(),multiplicity=PureOne,genericType=^GenericType(rawType=String))
                            )
   
   
}


function  <<access.private>> meta::json::schema::fromSchema::createConstraintFunctionDefinition(fileName:String[1],functionName:String[1],valueType:Type[1],pathPrefix:String[0..1]):ConcreteFunctionDefinition<Any>[1]
{
     let functionDef = meta::json::schema::fromSchema::fragmentPlaceHolder_String_$0_1$__Boolean_1_;
     let ft =$functionDef->functionType();
     let ftparam =$ft.parameters->at(0);
     let updatedFT = ^$ft(parameters=^$ftparam(genericType=^GenericType(rawType=$valueType)));
     let result = ^$functionDef(functionName=$functionName,classifierGenericType=^GenericType(typeArguments=^GenericType(rawType=$updatedFT),rawType=ConcreteFunctionDefinition))-> updatePackagableElementWithPackage($fileName->packageFromPath($pathPrefix)+$functionName)->cast(@ConcreteFunctionDefinition<Any>);
     $result;
}

function  <<access.private>> meta::json::schema::fromSchema::fragmentToFunction(fileName:String[1],value:JSONObject[1],pathPrefix:String[0..1]):PackageableElement[1]
{
  
  let types = $value->getTypesFromFragment(); 
   
  let name = $fileName->refToFileName();
  let type = ^GenericType(rawType=$value->fragmentType());
  let functionDef = meta::json::schema::fromSchema::fragmentPlaceHolder_String_$0_1$__Boolean_1_;
  let ft =$functionDef->functionType();
  let ftparam =$ft.parameters->at(0);
  let updatedFT = ^$ft(parameters=^$ftparam(genericType=$type));

  let expressionSequence = $value->fragmentToValueSpecifcation([],$fileName,$pathPrefix,$ftparam,[],[])->toOneMany()->cast(@SimpleFunctionExpression)->wrapWithIF($ftparam,false)->evaluateAndDeactivate();

  let result = ^$functionDef(expressionSequence=$expressionSequence,functionName=$name,classifierGenericType=^GenericType(typeArguments=^GenericType(rawType=$updatedFT),rawType=ConcreteFunctionDefinition))-> updatePackagableElementWithPackage($fileName->packageFromPath($pathPrefix)+$name);
      $result;
}


function <<access.private>> meta::json::schema::fromSchema::functionConstraintMap(addToOne:Boolean[1]):Map<String,LambdaFunction<Any>>[1]
{
 let shared   =newMap([pair('anyOf', {value :Boolean[1],value2:Boolean[1]| $value ->or($value2)}),
                         pair('$ref', {value:Any[0..1]| $value }),
                         pair('oneOf', {value :Boolean[*]| oneOf($value)}),
                         pair('and', {value:Boolean[1],value2:Boolean[1]| $value ->and($value2)})
                        ]);
   
   
 let zeroOne=  newMap([ pair('pattern', {value:Any[0..1]| $value->makeString()->matches('placeholder')}),
                         pair('type', {value:Any[0..1],value2:Type[1]| $value->toOne()->instanceOf($value2)}),
                         pair('minLength', {value:Any[0..1],value2:Integer[1]| $value ->makeString()->isNoShorterThan($value2)}),
                         pair('maxLength', {value:Any[0..1],value2:Integer[1]| $value->makeString()->isNoLongerThan($value2)}),
                         pair('maximum', {value:Number[0..1],value2:Number[1]| $value->toOne()->cast(@Number)->lessThanEqual($value2)}),
                         pair('minimum', {value:Number[0..1],value2:Number[1]| $value->toOne()->cast(@Number)->greaterThanEqual($value2)}),
                         pair('exclusiveMaximum', {value:Number[0..1],value2:Number[1]| $value->toOne()->cast(@Number)->lessThan($value2)}),
                         pair('exclusiveMinimum', {value:Number[0..1],value2:Number[1]| $value->toOne()->cast(@Number)->greaterThan($value2)}),
                         pair('enum', {value:Any[0..1]|$value ->toOne()->in(['placeholder'])  } )          
                        ])->putAll($shared);
   
 let one=  newMap([ pair('pattern', {value:Any[1]| $value->makeString()->matches('placeholder')}),
                   pair('type', {value:Any[1],value2:Type[1]| $value->instanceOf($value2)}),
                   pair('minLength', {value:Any[1],value2:Integer[1]| $value ->makeString()->isNoShorterThan($value2)}),
                   pair('maxLength', {value:Any[1],value2:Integer[1]| $value->makeString()->isNoLongerThan($value2)}),
                   pair('maximum', {value:Number[1],value2:Number[1]| $value->cast(@Number)->lessThanEqual($value2)}),
                   pair('minimum', {value:Number[1],value2:Number[1]| $value->cast(@Number)->greaterThanEqual($value2)}),
                   pair('exclusiveMaximum', {value:Number[1],value2:Number[1]| $value->cast(@Number)->lessThan($value2)}),
                   pair('exclusiveMinimum', {value:Number[1],value2:Number[1]| $value->cast(@Number)->greaterThan($value2)}),
                   pair('enum', {value:Any[1]|$value ->in(['placeholder'])  } )          
                        ])->putAll($shared);
assertSameElements($zeroOne->keys(),$one->keys()); //sainity check

   if($addToOne,|$zeroOne,|$one);
}   




function   meta::json::schema::fromSchema::wrapWithIF(vs:SimpleFunctionExpression[1..*],property:ValueSpecification[1],required:Boolean[1]):ValueSpecification[1..*]
{
  let lambda =  {this :Any[0..1] |if($this ->isNotEmpty(),|$this,|true)};
   let lambdsES = $lambda.expressionSequence->evaluateAndDeactivate()->cast(@SimpleFunctionExpression)->toOne();
  if($required,
      |  $vs; ,   
      | let isNotEmpty =   $lambdsES.parametersValues->at(0)->cast(@SimpleFunctionExpression);
        let updatedNotEmpty= ^$isNotEmpty(parametersValues=$property)->toOne();
        
        let firsParam = $lambdsES.parametersValues->at(1)->cast(@InstanceValue);
        let firsParamValue = $firsParam.values->toOne()->cast(@LambdaFunction<Any>);
        let updatedFirstParam= ^$firsParam(values=^$firsParamValue(expressionSequence=$vs));
     
        let result =  ^$lambdsES(parametersValues=[$updatedNotEmpty,$updatedFirstParam,$lambdsES.parametersValues->at(2)]);
        $result;
   );
   
   

}


function  <<access.private>> meta::json::schema::fromSchema::fragmentToValueSpecifcation(value:JSONElement[*],key:String[0..1],ownerFileName:String[1],pathPrefix:String[0..1],property:ValueSpecification[1],genInstanceOf:Boolean[0..1],format:JSONElement[0..1]):ValueSpecification[*]
{
    let generateInstance = if($genInstanceOf->isEmpty(),|$value->fragmentType()==Any,|$genInstanceOf->toOne());
   
   let  FunctionConstraintMap = functionConstraintMap($property->evaluateAndDeactivate().multiplicity.lowerBound.value==0 );
   let res = if($value->isNotEmpty(),
                 |$value->map(f|$f->match([a:JSONArray[1]|  
                                                              let lambdaParams = $a.values->map( v |$v-> fragmentToValueSpecifcation($key,$ownerFileName,$pathPrefix,$property,$generateInstance,$format))->evaluateAndDeactivate();
                                                            if($key=='oneOf' ,
                                                                           |let lambda = $FunctionConstraintMap->get($key->toOne()).expressionSequence->toOne()->evaluateAndDeactivate()->cast(@FunctionExpression);
                                                                              ^$lambda(parametersValues=^InstanceValue(values=$lambdaParams,genericType=$lambdaParams.genericType->at(0),multiplicity=PureOne));,
                                                                           |if( $key =='enum',
                                                                                |  let lambda = $FunctionConstraintMap->get($key->toOne()).expressionSequence->toOne()->evaluateAndDeactivate()->cast(@FunctionExpression); 
                                                                                     let initialParam = replaceFirstParameter($lambda.parametersValues->at(0),$property);
                                                                                  ^$lambda(parametersValues=[$initialParam->concatenate(^InstanceValue(values=$a.values->cast(@JSONString).value,genericType=$lambdaParams.genericType->at(0),multiplicity=OneMany))]);             ,
                                                                                |$lambdaParams));
                                                                  ,            
                                           o:JSONObject[1]|
                                                            let filteredKVPInit = $o.keyValuePairs->filter(k|$k.key.value->in($FunctionConstraintMap->keys()->remove('type')->remove('format') ) || ( $generateInstance && $k.key.value=='type'  ));// filter out what we don't handle here
                                                            let filteredKVP  = if($filteredKVPInit.key.value->containsAll(['type','anyOf']) &&   $filteredKVPInit->filter(k|$k.key.value=='anyOf').value->fragmentType()==Any ,|$filteredKVPInit->filter(k|$k.key.value=='anyOf') ,|$filteredKVPInit  );
                                                            let formatElement = $o.keyValuePairs->filter(o|$o.key.value=='format').value->first(); 
                                                         
                                                            if($filteredKVP->isNotEmpty(),
                                                                       | if($filteredKVP->size()>1,   //to do: clean this up for more scenarios
                                                                            |
                                                                              let lastKVP= $o.keyValuePairs->last();
                                                                              let lambdaES = $FunctionConstraintMap->get('and').expressionSequence->toOne()->evaluateAndDeactivate()->cast(@FunctionExpression);
                                                                              let processedKVP = $filteredKVP->map( kvp | $kvp.value->fragmentToValueSpecifcation($kvp.key.value,$ownerFileName,$pathPrefix,$property,$generateInstance,$formatElement)->evaluateAndDeactivate()->cast(@ValueSpecification));
                                                                               $processedKVP->init()->fold({ lhs,a:ValueSpecification[1]| let params = $lhs->concatenate($a->toOne());
                                                                                                                                           ^$lambdaES(parametersValues=$params); 
                                                                                                             },$processedKVP->last());,   


                                                                            |  

                                                                               let kvp = $filteredKVP->toOne();
                                                                                if($kvp.key.value=='$ref',
                                                                                      |$kvp.value->fragmentToValueSpecifcation($kvp.key.value,$ownerFileName,$pathPrefix,$property,$generateInstance,$formatElement);,
                                                                                      |let lambda = $FunctionConstraintMap->get($kvp.key.value->toOne());
                                                                                      let lambdaEs = $lambda.expressionSequence->toOne()->evaluateAndDeactivate()->cast(@FunctionExpression);
                                                                                      let lambdaParam = $kvp.value->fragmentToValueSpecifcation($kvp.key.value,$ownerFileName,$pathPrefix,$property,$generateInstance,$formatElement);
                                                                                      if($lambdaParam->size()>1,
                                                                                         |  $lambdaParam->init()->fold({ fn,rhs|let lhs = $fn;
                                                                                                                               ^$lambdaEs(parametersValues=$lhs->cast(@ValueSpecification)->concatenate($rhs));
                                                                                                                        },$lambdaParam->last()->cast(@ValueSpecification) );,
                                                                                         | $lambdaParam;
                                                                                       );
                                                                                  );      
                                                                          );,
                                                                 |[]
                                                               )  ;     ,                   
                                           s:JSONString[1]| if($key=='$ref',
                                                                 | let fullPath = $s.value->toOne()->refToFullPath($ownerFileName); 
                                                                   let lambda =$FunctionConstraintMap->get($key->toOne());
                                                                   let name = $s.value->toOne()->refToFileName();
                                                                   let func = createConstraintFunctionDefinition($fullPath,$name,Any,$pathPrefix)->evaluateAndDeactivate();
                                                                   let result = ^SimpleFunctionExpression(func = $func, 
                                                                                                           importGroup = system::imports::coreImport,
                                                                                                           genericType = $func->toOne()->functionReturnType(),
                                                                                                           multiplicity = $func->toOne()->functionReturnMultiplicity(),
                                                                                                           functionName = $func.functionName,
                                                                                                           parametersValues =  $lambda.expressionSequence->at(0));
                                                                     $result;,
                                                                 |   let IV =  if($key=='type',
                                                                                |if($format->isNotEmpty(),
                                                                                    |^InstanceValue(genericType=^GenericType(rawType=Type),values=$format->toOne()->JSONToPUREType(),multiplicity=PureOne),
                                                                                    |^InstanceValue(genericType=^GenericType(rawType=Type),values=$s->JSONToPUREType(),multiplicity=PureOne)
                                                                                   ),
                                                                                |^InstanceValue(genericType=^GenericType(rawType=String),values=$s.value,multiplicity=PureOne)
                                                                              );
                                                                   
                                                                  if($key->isNotEmpty(),
                                                                          |   let lambdaES = $FunctionConstraintMap->get($key->toOne()).expressionSequence->evaluateAndDeactivate()->toOne()->cast(@FunctionExpression); 
                                                                              let initialParam = replaceFirstParameter($lambdaES.parametersValues->at(0),$property);
                                                                              ^$lambdaES(parametersValues=[$initialParam->concatenate($IV)]);,
                                                                         |   $IV
                                                                     );
                                                               );,
                                           s:JSONNumber[1]| let IV = ^InstanceValue(genericType=^GenericType(rawType=Float),values=$s.value,multiplicity=PureOne);
                                                               if($key->isNotEmpty(),
                                                                  |   let lambdaES = $FunctionConstraintMap->get($key->toOne()).expressionSequence->evaluateAndDeactivate()->toOne()->cast(@FunctionExpression);  
                                                                      let initialParam = replaceFirstParameter($lambdaES.parametersValues->at(0),$property);
                                                                       ^$lambdaES(parametersValues=[$initialParam->concatenate($IV)]);,
                                                                  |   $IV);,
                                           a:Any[1]|$a->println();^InstanceValue(genericType=^GenericType(rawType=String),values='any',multiplicity=PureOne);
                                     
                                  ])

                              );,
                 | ^InstanceValue(genericType=^GenericType(rawType=String),values='blank',multiplicity=PureOne));  
   
  
}

function  <<access.private>> meta::json::schema::fromSchema::replaceFirstParameter(expression:ValueSpecification[1],property:ValueSpecification[0..1]):ValueSpecification[1]
{
   if($property->isNotEmpty(),
      |$expression->match([s:SimpleFunctionExpression[1]|^$s(parametersValues=$s.parametersValues->at(0)->replaceFirstParameter($property)->concatenate($s.parametersValues->tail())),
                           a:ValueSpecification[1]|$property->toOne() ]),
      |$expression);
}

function <<access.private>> meta::json::schema::fromSchema::fragmentPlaceHolder(value:String[0..1]):Boolean[1]
{
  true;   
}

function <<access.private>> meta::json::schema::fromSchema::packageFromPath(path:String[1],pathPrefix:String[0..1]):String[1]
{
  let slash ='/';
  let updatedPath = if( $path->startsWith($slash),|$path->substringAfter($slash),|if($path->startsWith('..'),|$path->substringAfter('..'+$slash),|$path));
  let hasFileName = if($path ->matches('^.*\.(json|JSON)$'),|1,|0);
  let splitPath= $updatedPath->split($slash);
  let prefix = if($pathPrefix->isNotEmpty(),|$pathPrefix->toOne()+'::',|''); 
  let pathParts = $splitPath->take($splitPath->size()-$hasFileName);   
  $prefix+ if($pathParts->isNotEmpty(),|$pathParts->joinStrings('::')+'::',|'');
}

function <<access.private>> meta::json::schema::fromSchema::typeFullPath(fileName:String[1],pathPrefix:String[0..1]):String[1]
{
   let package = $fileName->packageFromPath($pathPrefix); 
   let name =  $fileName->refToFileName();
   $package+$name;
}


function <<access.private>> meta::json::schema::fromSchema::JSONSchemaToClass(fileName:String[1],processedSchema:ProcessedSchema[1],pathSchemas:Map<String,ProcessedSchema>[1],pathPrefix:String[0..1]):Class<Any>[1]
{
   //TODO
   //in line enum
   //restricted values
   //array
    let parsed = $processedSchema.parsedSchema;
   // let package = $fileName->packageFromPath($pathPrefix); 
   // let name =  $fileName->refToFileName();
    let javaType = $parsed.keyValuePairs->getValueForKey('javaType')->cast(@JSONString).value->first();
    let description = $parsed.keyValuePairs->getValueForKey('description')->cast(@JSONString).value->first();
    let noadditionalProps = $parsed.keyValuePairs->getValueForKey('additionalProperties')->cast(@JSONBoolean).value->first();
    let properties = $parsed.keyValuePairs->getValueForKey('properties')->cast(@JSONObject).keyValuePairs;
    let required =  $parsed.keyValuePairs->getValueForKey('required')->cast(@JSONArray).values->cast(@JSONString).value;
    let class = newClass($fileName->typeFullPath($pathPrefix));
    let generalizations = $processedSchema.superTypes->map(g |^Generalization(general = ^GenericType(rawType=newClass($g->packageFromPath($pathPrefix)+$g->refToFileName() )),specific= $class));
    let classProperties = $properties->map(p|$p->JSONSchemaToProperty($class,$fileName,$pathSchemas,$pathPrefix,$p.key.value->in($required)));
    let zippedPropertes = $properties->zip($classProperties);
   
    let constraints =$zippedPropertes->map( zipped| let p = $zipped.first;
                                                            if( $p.value->instanceOf(JSONObject) && $p.value->cast(@JSONObject).keyValuePairs->getValueForKey('$ref')->isNotEmpty() ,
                                            |let refSchema = $pathSchemas->get($p.value->cast(@JSONObject).keyValuePairs->getValueForKey('$ref')->cast(@JSONString).value->toOne()->refToFullPath($fileName));
                                             if($refSchema->isNotEmpty() && $refSchema.schemaType== SchemaType.fragment,
                                                 | let lambda = newLambdaFunction( ^FunctionType(returnMultiplicity = PureOne, 
                                                                                                 returnType = ^GenericType(rawType = Boolean)));                                                                                               
                                                  let lambdaWithDef= ^$lambda(expressionSequence=createConstraintFunctionExpression($refSchema.fileName->toOne(),$refSchema.fileName->toOne()->refToFileName()  ,Any,$pathPrefix,$zipped.second));
                                                   ^meta::pure::metamodel::constraint::Constraint(functionDefinition=$lambdaWithDef,
                                                                                                  name =$p.key.value);,
                                                 |[]                   
                                               );  
                                          ,|[]
                                      );
                                       );// any property that is a ref to a fragment  // create $this.propertyName->constraint();
     let keysForInLine = functionConstraintMap(true)->keys()->filter(f|!$f->in(['$ref','type']));

      let inLineConstraints = $zippedPropertes->filter(f| $f.first.value->cast(@JSONObject).keyValuePairs.key.value->containsAny($keysForInLine))
                                                ->map(p|let lambda = newLambdaFunction( ^FunctionType(returnMultiplicity = PureOne, 
                                                                                          returnType = ^GenericType(rawType = Boolean)));  
                                                         let lambdaWithDef= ^$lambda(expressionSequence=$p.first.value-> fragmentToValueSpecifcation([],$fileName,$pathPrefix,$p.second->propertyParameter(),[],[])->toOneMany()->cast(@SimpleFunctionExpression)->wrapWithIF($p.second->propertyParameter(),$p.first.key.value->in($required))->evaluateAndDeactivate()->toOneMany());
                                                         ^meta::pure::metamodel::constraint::Constraint(functionDefinition=$lambdaWithDef,
                                                                                                        name=$p.first.key.value+'_inLine' ););

    let classWithTags = ^$class(constraints=$constraints->concatenate($inLineConstraints),generalizations=$generalizations,properties=$classProperties)->cast(@ElementWithTaggedValues)->addTag(doc,'doc',$description)->addTag(JSONSchemaGeneration,'javaType',$javaType);
    if($noadditionalProps->isNotEmpty() && !$noadditionalProps->toOne(),
        |$classWithTags->cast(@ElementWithStereotypes)->addStereoType(JSONSchemaGeneration,'noAdditionalProperties'),
        |$classWithTags
       )->cast(@Class<Any>);
   
   
}
function <<access.private>> meta::json::schema::fromSchema::JSONSchemaToProperty(property:JSONKeyValue[1],ownerClass:Class<Any>[1],ownerPath:String[1],pathSchemas:Map<String,ProcessedSchema>[1],pathPrefix:String[0..1],required:Boolean[1]):Property<Nil,Any|*>[1]
{
   //TODO FORMATS  date,date=time
    let propertyName = $property.key.value;
    let propertyKVP = $property.value->cast(@JSONObject).keyValuePairs;
    let typeValue = $propertyKVP->getValueForKey('type')->cast(@JSONString).value;

    let typeorRef = if ($typeValue=='array', 
                            | let items = $propertyKVP->getValueForKey('items');
                              assert($items->isNotEmpty(),'found array with out item on property ' +$propertyName +' for '+ $ownerClass->elementToPath());
                              $items->cast(@JSONObject).keyValuePairs;,
                            |$propertyKVP
                       )->cast(@JSONKeyValue);
   
     
    let ref = $typeorRef->getValueForKey('$ref');

     let type = if($ref->isNotEmpty(),
                     | $ref->cast(@JSONString).value->toOne()->refToPath($ownerPath,$pathSchemas,$pathPrefix),
                     | $typeorRef->getValueForKey('type')->JSONToPUREType(); 

                  );
    let description = $propertyKVP->getValueForKey('description')->cast(@JSONString).value->first();
    let defaultValue = $propertyKVP->getValueForKey('default');
    let default =  if($defaultValue->isNotEmpty(),
                     | $defaultValue->toOne()->  match([s:JSONString[1]|$s.value,
                                                        n:JSONNumber[1] |$n.value,
                                                        b:JSONBoolean[1]|$b.value ])->makeString();,
                       |[]);
   let multiplicty =  if($typeValue=='array' && $required,
                            |OneMany,
                            |if($typeValue=='array' &&  !$required,
                                |ZeroMany,
                                |if($typeValue!='array' &&  $required, 
                                    |PureOne,
                                    |ZeroOne)));
    
    newProperty($propertyName, ^GenericType(rawType=$ownerClass), ^GenericType(rawType=$type),$multiplicty)->cast(@ElementWithTaggedValues)->addTag(doc,'doc',$description) ->addTag(JSONSchemaGeneration,'defaultValue',$default) ->cast(@Property<Nil,Any|*>);
   
}

function <<access.private>> meta::json::schema::fromSchema::getValueForKey(pairs:JSONKeyValue[*],key:String[1]):JSONElement[*]
{
  
       $pairs->filter(k|$k.key.value==$key).value;
}

function <<access.private>> meta::json::schema::fromSchema::fragmentType(fragment:JSONElement[*]):Type[1]
{
      let types = $fragment->getTypesFromFragment() ->distinct();
     if($types->size()>1||$types->isEmpty(),|Any,|$types->toOne());

}

function <<access.private>> meta::json::schema::fromSchema::getTypesFromFragment(fragment:JSONElement[*]):Type[*]
{
 let res = if($fragment->isNotEmpty(),
              |$fragment->map(f|$f->match([a:JSONArray[1]|$a.values->map( v |$v-> getTypesFromFragment()),
                                           o:JSONObject[1]| $o.keyValuePairs->map( p| if($p.value->instanceOf(JSONObject) || $p.value->instanceOf(JSONArray),
                                                                            |$p.value-> getTypesFromFragment(),
                                                                            |   let type = $p->getValueForKey('type');
                                                                                let format =  $p->getValueForKey('format');         
                                                                                 if($format->isNotEmpty(),
                                                                                    |$format->JSONToPUREType(),
                                                                                    |if($type->isNotEmpty(),
                                                                                           |$type->JSONToPUREType(),
                                                                                             |[] )
                                                                                     ) ;
                                                                          )
                                                                      );,
                                          a:Any[1]|[] ;]));,
              | []);  
   $res->cast(@Type);
}


function <<access.private>> meta::json::schema::fromSchema::refToPath(ref:String[1],parentPath:String[1],pathSchemas:Map<String,ProcessedSchema>[1],pathPrefix:String[0..1]):Type[1]
{ 
   let fullPath = $ref->refToFullPath($parentPath);
   let schemaForPath= $pathSchemas->get($fullPath);
   if($schemaForPath->isEmpty(),
      |Any,
      | let parsed = $schemaForPath.parsedSchema->toOne();
          if($parsed->JSONSchemaIsEnum(),
              |JSONSchemaToEnum($fullPath,$parsed,$pathPrefix),
              | if($parsed->JSONSchemaIsObject(),
                   | newClass( $fullPath->typeFullPath($pathPrefix));,
                   |$parsed->fragmentType();
                  );
    ););
   
}


function <<access.private>> meta::json::schema::fromSchema::refToFileName(ref:String[1]):String[1]
{ 
      $ref->split('/')->last()->toOne()->split('.')->first()->toOne();
   
}

function <<access.protected>> meta::json::schema::fromSchema::refToFullPath(ref:String[1],parentPath:String[1]):String[1]
{ 
     //TODO: make this work with /../../ . 
   //count the dots and  drop 1 level end of  from parent for each dot
     let   refWithSlash = if($ref->startsWith('/'),|$ref,| '/'+$ref);
     let splitRef = $refWithSlash->split('/');
     let rootDots = if($splitRef->size()==1,|0,|$refWithSlash->split('/')->at(0)->chunk(1)->filter(d|$d=='.')->size());
  
      let parentFolder =  $rootDots==2;
     let refNoDots = $refWithSlash->substring($rootDots+1);
     let cleanRef =  if($refNoDots->startsWith('/'),|$refNoDots,|'/'+$refNoDots);
     let parentPathElements = $parentPath->split('/')->init();
   
     let refPathElements = $cleanRef->split('/');
     let parentOffset = if($parentFolder,|1,|0);
     let fullRefelments =  $parentPathElements->take($parentPathElements->size()-$parentOffset);
     if($fullRefelments->isEmpty(),
         |$cleanRef,
         |'/'+$fullRefelments->joinStrings('/')+$cleanRef
       );     
   
}

function <<access.private>> meta::json::schema::fromSchema::updatePackagableElementWithPackage(pack:PackageableElement[1],path:String[1]):PackageableElement[1]
{
   let pathParts = $path->split('::'); 
   let elementName = if($pack.name->isNotEmpty(),|' for element ' +$pack.name->toOne(),|'');
   assert($pathParts->size()>0,'your path must have both a package and a name specified as MyPackage::name found ' +$path +$elementName);
   
   let package = $pathParts->init()->fold({str:String[1], pkg:Package[1] |^Package(name = $str, package = $pkg);},^Package());
  ^$pack(package=$package, name = $pathParts->last());

}

function <<access.private>> meta::json::schema::fromSchema::JSONToPUREType(type:JSONElement[*]):Type[1]
{
      if($type->isEmpty(),
            |Any,
            | let name = $type->cast(@JSONString).value->toOne();
               if ($name == 'string',| String,
                   | if ($name == 'integer',| Integer,
                   | if ($name == 'number',| Float,
                   | if ($name == 'boolean',| Boolean,
                   | if ($name == 'date',|StrictDate,
                   | if ($name == 'date-time',|DateTime,            
                         |Any)))))););
}
          


function <<access.private>> meta::json::schema::fromSchema::addTag(e:ElementWithTaggedValues[1],profile:Profile[1],tag:String[1],value:String[0..1]):ElementWithTaggedValues[1]
{
   if($value->isNotEmpty(),
      |^$e(taggedValues+=^TaggedValue(tag=tag($profile,$tag),value = $value->toOne()));,
      | $e);
  
 }

function <<access.private>> meta::json::schema::fromSchema::addStereoType(e:ElementWithStereotypes[1],profile:Profile[1],stereoType:String[1]):ElementWithStereotypes[1]
{
   ^$e(stereotypes+=stereotype($profile,$stereoType));
}

function meta::json::schema::fromSchema::tests::schemaInput(fileName:String[1],schema:String[1],pathPrefix:String[0..1]):SchemaInput[1]
{
      ^SchemaInput(fileName=$fileName,schema=$schema,pathPrefix=$pathPrefix);
}



Class <<access.private>> meta::json::schema::fromSchema::ProcessedSchema
{
   fileName:String[1];
   schema:String[1];
   pathPrefix:String[0..1];
   parsedSchema:JSONObject[1];
   subTypes:String[*];
   superTypes:String[*];
   schemaType:SchemaType[1];
   
}


Enum meta::json::schema::fromSchema::SchemaType
{
   enum,
   object,
   fragment
}
