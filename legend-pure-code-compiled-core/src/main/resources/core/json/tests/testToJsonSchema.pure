// Copyright 2020 Goldman Sachs
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import meta::pure::profiles::*;
import meta::pure::executionPlan::profiles::*;
import meta::pure::generation::metamodel::*;
import meta::json::schema::generation::*;
import meta::json::*;
import meta::json::schema::*;
import meta::json::schema::tests::*;


Class <<typemodifiers.abstract>> 
{doc.doc = 'The Being Class'}
meta::json::schema::tests::Being
{
   omg:String[1];
}

Class 
{doc.doc = 'The Foo Class'}
meta::json::schema::tests::Foo
{

   beings:Being[2];
}


Class 
{doc.doc = 'The Animal Class'}
meta::json::schema::tests::Animal extends Being
{

   name:String[1];
   age:Integer[1];
   type:AnimalType[0..1];
   aliases:String[*];
   extra:OtherInfo[4]; 
}

Class 
{doc.doc = 'The Cat Class'}
meta::json::schema::tests::Cat extends Animal
{
   {doc.doc = 'Is the animal a vegetarian?'}
   vegetarian:Boolean[1];
}

Class 
{doc.doc = 'The OtherInfo Class'}
meta::json::schema::tests::OtherInfo
{
   info:String[1];
}

Enum 
{doc.doc = 'The AnimalType Enum'}
meta::json::schema::tests::AnimalType
{
     CAT, DOG, BIRD, FISH, HUMAN
}

Class
{doc.doc = 'A Recursive Test Class'}
meta::json::schema::tests::RecursiveTestClass
{
   name:String[1];
   children:RecursiveTestClass[*];   // Direct Recursion
   others:SomeOtherClass[*];         // InDirect Recursion
}

Class
{doc.doc = 'Some Other Class'}
meta::json::schema::tests::SomeOtherClass
{
   items:RecursiveTestClass[*];
}

Class
{doc.doc = 'No Required Fields Class'}
meta::json::schema::tests::NoRequiredFieldsClass
{
   a:String[0..1];
   b:String[0..1];
   c:String[0..1];
}


Class meta::json::schema::tests::PrimitiveTypeDomain
{
   {doc.doc = 'String Field'}
   stringField : String[1];
   
   {doc.doc = 'Float Field'}
   floatField: Float[1];
   
   {doc.doc = 'Integer Field'}
   integerField: Integer[1];
   
   {doc.doc = 'Date Field'}
   dateField: Date[1];

   {doc.doc = 'DateTime Field'}
   dateTimeField: DateTime[1];

   {doc.doc = 'StrictDate Field'}
   strictDateField: StrictDate[1];

   {doc.doc = 'Boolean Field'}
   booleanField: Boolean[1];
   
   
   stringNoDescriptionField : String[1];
   
   {doc.doc = 'String Field- multiple'}
   srtingMultipleField: String[*];
   
   {doc.doc = 'Float Field - multiple'}
   floatMultipleField: Float[*];
   
   {doc.doc = 'Integer Field - multiple'}
   integerMultipleField: Integer[*];
   
   {doc.doc = 'Date Field-multiple'}
   dateMultipleField: Date[*];

   {doc.doc = 'DateTime Field-multiple'}
   dateTimeMultipleField: DateTime[*];

   {doc.doc = 'StrictDate Field-multiple'}
   strictDateMultipleField: StrictDate[*];

   {doc.doc = 'Field String - Range 1..3'}
   stringRangeField: String[1..3];
   
   {doc.doc = 'Field String - Range 0..3'}
   stringRangeZeroField: String[0..3];
   
   {doc.doc = 'Field Integer - Range 1..3'}
   integerRangeField: Integer[1..3];
   
   {doc.doc = 'Field Integer - Range 0..3'}
   integerRangeZeroField: Integer[0..3];
   
   {doc.doc = 'Field Float - range 1..3'}
   floatRangeField: Float[1..3];
   
   {doc.doc = 'Field Float - range 0..3'}
   floatRangeZeroField: Float[0..3];
   
   {doc.doc = 'Date Field-multiple 1..3'}
   dateRangeField: Date[1..3];
   
   {doc.doc = 'Date Field-multiple 0..3'}
   dateRangeZeroField: Date[0..3];

   {doc.doc = 'DateTime Field-multiple 1..3'}
   dateTimeRangeField: DateTime[1..3];
   
   {doc.doc = 'DateTime Field-multiple 0..3'}
   dateTimeRangeZeroField: DateTime[0..3];

   {doc.doc = 'StrictDate Field-multiple 1..3'}
   strictDateRangeField: StrictDate[1..3];
   
   {doc.doc = 'StrictDate Field-multiple 0..3'}
   strictDateRangeZeroField: StrictDate[0..3];

}

function <<access.private>>  meta::json::schema::tests::matchString():String[1]
{
 'abcd';
}

function <<access.private>>  meta::json::schema::tests::constraintFunctionComplex(value:Any[0..1]):Boolean[1]
{
oneOf([((($value->makeString()->isNoLongerThan(32) && $value->makeString()->isNoShorterThan(4) && $value->makeString()->matches(matchString()) ) 
          || $value->makeString()->isNoShorterThan(7) 
          || $value->makeString()->isNoShorterThan(2))  && $value->toOne()->instanceOf(String))  
       , $value->toOne()->constraintFunctionSimpleNumber() ])
}



function <<access.private>> meta::json::schema::tests::constraintFunctionSimpleNumber(valueNumber:Any[0..1]):Boolean[1]
{
    $valueNumber->toOne()->instanceOf(Number) ;
}

Class 
{doc.doc = 'Class With Constraints'}
  meta::json::schema::tests::ClassWithConstraints 
[
    simple: $this.simple->constraintFunctionSimpleNumber(),
    complex: $this.complex->constraintFunctionComplex() && $this.complex->makeString()->isNoShorterThan(4),
 //  invalid: $this.invalid->isEmpty(),
 //  invalidMixedProperties: $this.invalidMixedProperties->constraintFunctionSimpleNumber() &&   $this.invalid->toOne() ->instanceOf(String) ,
 //  duplicateConstraint: $this.duplicateConstraint->toOne() ->instanceOf(String),
   inLine : $this.inLine->toOne()->instanceOf(String) || $this.inLine->toOne()->instanceOf(Number),
   constant: $this.constant=='constantValue',
   number:( ($this.number>10) && ($this.number < 15)) || (( $this.number >= 0 )&& ( $this.number <=2)),
   dateOrString: if( $this.dateOrString->isNotEmpty(),| $this.dateOrString->toOne()->instanceOf(String) || $this.dateOrString->toOne()->instanceOf(StrictDate),|true)

]
{
   constant:String[0..1];
   simple:Any[0..1];
   complex:Any[0..1];
   invalid:String[0..1];
   invalidMixedProperties:String[0..1];
   duplicateConstraint:String[0..1];
   inLine: Any[0..1];
   number:Number[1];
   dateOrString:Any[0..1];
   
}

Class  meta::json::schema::tests::parent::parentClass
{
   childClass:meta::json::schema::tests::parent::level1::childClass[1];
   childClass2:meta::json::schema::tests::parent2::level1::level2::childClass2[1];
   
}

Class  meta::json::schema::tests::parent::level1::childClass
{

}

Class  meta::json::schema::tests::parent2::level1::level2::childClass2
{

}
Class 
<<JSONSchemaGeneration.noAdditionalProperties>> {JSONSchemaGeneration.javaType = 'org.finos.Instrument' }
  meta::json::schema::tests::ClassWithProfileInterface
{
   
}

Class 
<<JSONSchemaGeneration.noAdditionalProperties>> {doc.doc = 'Class With Profile' }
  meta::json::schema::tests::ClassWithProfile  extends meta::json::schema::tests::ClassWithProfileInterface
{
   
   {JSONSchemaGeneration.defaultValue='0',doc.doc='number defaulted to zero'}size:Number[0..1];
   {JSONSchemaGeneration.defaultValue='test'}name:String[0..1];
    {JSONSchemaGeneration.defaultValue='true'}bool:Boolean[1];


   pets:jsonSchemaEnum[1];
}

Enum 
{doc.doc = 'Enum with Profile' ,JSONSchemaGeneration.defaultValue='Guinea Pig'}

  meta::json::schema::tests::jsonSchemaEnum 
{
   Dog,
   Cat,
   {meta::java::metamodel::profiles::enumValue.name='Guinea Pig'}Guinea_Pig
   
}

function meta::json::schema::tests::testSuite():Boolean[1]
{
	println('++++Starting JSON Schema Tests++++');
	newJSONKeyStringValueAsObjectTest();
	newJSONKeyStringValueTest();
	newJsonRefTest();
	titleTest();
	descriptionTest();
	schemaTest();
	propertiesTest();
	allOfGeneralizationsTest();
	extendsGeneralizationsTest();
	convertPrimitiveTypeTest();
	allGeneralizationsTest();
	allNonPrimitivePropertiesOfClassTest();
	allReferencedElementsTest();
	isEnumTest();
	createObjectPropertyTest();
	enumTest();
	requiredTest();
	requiredEmptyTest();
	recursiveTest();
	definitionsTest();
	toJSONSchemaTest();
    arrayMinMaxItemKeyValue();
    allPrimitivePropertiesOfClass();
    dateAndDateTimeJSONFormatTest();
	println('++++Finishing JSON Schema Tests++++');
	assert(true);
}


function <<test.Test>> meta::json::schema::tests::arrayMinMaxItemKeyValue():Boolean[1]
{
   let property = PrimitiveTypeDomain.properties->get('stringRangeField')->toOne()->cast(@Property<Nil,Any|*>);
   let stringRangeJSONKeyValue= meta::json::schema::arrayMinMaxItemKeyValue($property);
   assertEq('minItems', $stringRangeJSONKeyValue->first()->cast(@JSONKeyValue).key->cast(@JSONString).value->toOne());
   assertEq(1, $stringRangeJSONKeyValue->first()->cast(@JSONKeyValue).value->cast(@JSONNumber).value->toOne());
   assertEq('maxItems', $stringRangeJSONKeyValue->last()->cast(@JSONKeyValue).key->cast(@JSONString).value->toOne());
   assertEq(3, $stringRangeJSONKeyValue->last()->cast(@JSONKeyValue).value->cast(@JSONNumber).value->toOne());
}

function <<test.Test>> meta::json::schema::tests::allPrimitivePropertiesOfClass():Boolean[1]
{
   println('-->Testing String Primitive type');
   let propertyString = PrimitiveTypeDomain.properties->get('stringField')->cast(@Property<Nil,Any|*>)->toOne();
   let stringJSONKeyValue= $propertyString->propertyTypeValue(PrimitiveTypeDomain);
   assert(confirmPrimitiveProperty($stringJSONKeyValue, 'string'));

   let propertyInteger = PrimitiveTypeDomain.properties->get('integerField')->cast(@Property<Nil,Any|*>)->toOne();
   let integerJSONKeyValue= $propertyInteger->propertyTypeValue(PrimitiveTypeDomain);
   assert(confirmPrimitiveProperty($integerJSONKeyValue, 'integer'));

   let propertyFloat = PrimitiveTypeDomain.properties->get('floatField')->toOne()->cast(@Property<Nil,Any|*>)->toOne();
   let floatJSONKeyValue= $propertyFloat->propertyTypeValue(PrimitiveTypeDomain);
   assert(confirmPrimitiveProperty($floatJSONKeyValue, 'number'));

   let propertyDate = PrimitiveTypeDomain.properties->get('dateField')->toOne()->cast(@Property<Nil,Any|*>)->toOne();
   let dateJSONKeyValue= $propertyDate->propertyTypeValue(PrimitiveTypeDomain);
   assert(confirmPrimitiveProperty($dateJSONKeyValue, 'string'));

   let propertyDateTime = PrimitiveTypeDomain.properties->get('dateTimeField')->toOne()->cast(@Property<Nil,Any|*>)->toOne();
   let dateTimeJSONKeyValue= $propertyDateTime->propertyTypeValue(PrimitiveTypeDomain);
   assert(confirmPrimitiveProperty($dateTimeJSONKeyValue, 'string'));

   let propertyStrictDate = PrimitiveTypeDomain.properties->get('strictDateField')->toOne()->cast(@Property<Nil,Any|*>)->toOne();
   let strictDateJSONKeyValue= $propertyStrictDate->propertyTypeValue(PrimitiveTypeDomain);
   assert(confirmPrimitiveProperty($dateTimeJSONKeyValue, 'string'));

   let propertyBoolean = PrimitiveTypeDomain.properties->get('booleanField')->toOne()->cast(@Property<Nil,Any|*>)->toOne();
   let booleanJSONKeyValue= $propertyBoolean->propertyTypeValue(PrimitiveTypeDomain);
   assert(confirmPrimitiveProperty($booleanJSONKeyValue, 'boolean'));
}

function <<test.Test>> meta::json::schema::tests::dateAndDateTimeJSONFormatTest():Boolean[1]
{
   let strictDateFields = [
      'strictDateField', 'strictDateMultipleField', 'strictDateRangeField', 'strictDateRangeZeroField'
   ];
   $strictDateFields->map(f|
      let prop = PrimitiveTypeDomain.properties->get($f)->toOne()->cast(@Property<Nil,Any|*>)->toOne();
      let keyValue = $prop->propertyFormatValue();

      assertEquals('format', $keyValue.key->cast(@JSONString).value);
      assertEquals('date', $keyValue.value->cast(@JSONString).value);
   );
   
   let dateAndDateTimeFields = [
      'dateField', 'dateMultipleField', 'dateRangeField', 'dateRangeZeroField',
      'dateTimeField', 'dateTimeMultipleField', 'dateTimeRangeField', 'dateTimeRangeZeroField'
   ];
   $dateAndDateTimeFields->map(f|
      let prop = PrimitiveTypeDomain.properties->get($f)->toOne()->cast(@Property<Nil,Any|*>)->toOne();
      let keyValue = $prop->propertyFormatValue();

      assertEquals('format', $keyValue.key->cast(@JSONString).value);
      assertEquals('date-time', $keyValue.value->cast(@JSONString).value);
   );

   // non Date/DateTime/StrictDate fields should have empty format value
   PrimitiveTypeDomain.properties->filter(p| $p.genericType.rawType->toOne() != Date && $p.genericType.rawType->toOne() != DateTime && $p.genericType.rawType->toOne() != StrictDate)
    -> map(p|
      let prop = $p->cast(@Property<Nil,Any|*>)->toOne();
      assertEmpty($prop->propertyFormatValue()); 
    );
   
   true;
}

function meta::json::schema::tests::confirmPrimitiveProperty(jsonKeyValue:JSONKeyValue[1], expectedType:String[1]):Boolean[1]
{
   assertEq('type', $jsonKeyValue->cast(@JSONKeyValue).key->cast(@JSONString).value);
   assertEq($expectedType, $jsonKeyValue->cast(@JSONKeyValue).value->cast(@JSONString).value);
}


function <<test.Test>> meta::json::schema::tests::newJSONKeyStringValueAsObjectTest():Boolean[1]
{
   let expectedJSON = ^JSONObject( keyValuePairs = [ 
         ^JSONKeyValue( key   = ^JSONString( value = 'foo' ), 
                        value = ^JSONString( value = 'bar' ) ) ] );
   
   assertJSONEquals( $expectedJSON, newJSONKeyStringValueAsObject( 'foo', 'bar') );
}

function <<test.Test>> meta::json::schema::tests::newJSONKeyStringValueTest():Boolean[1]
{
  let expectedJSON = ^JSONKeyValue( key   = ^JSONString( value = 'foo' ), 
                                    value = ^JSONString( value = 'bar' ) );

  assertJSONEquals( $expectedJSON, newJSONKeyStringValue( 'foo', 'bar') );
  
}

function <<test.Test>>  meta::json::schema::tests::newJsonRefTest():Boolean[1]
{
   assertJSONEquals(
      newJSONKeyStringValue( '$ref', '#/definitions/meta::json::schema::tests::Animal'),
      Animal -> newJsonRef() );  

   assertJSONEquals(
      newJSONKeyStringValue( '$ref', '#/definitions/meta::json::schema::tests::Cat'),
      Cat -> newJsonRef() );  
      
    assertJSONEquals(
      newJSONKeyStringValue( '$ref', '#/definitions/meta::json::schema::tests::Being'),
      Being -> newJsonRef() );  
      
      
   assertJSONEquals(
      newJSONKeyStringValue( '$ref', '#/definitions/meta::json::schema::tests::AnimalType'),
      AnimalType -> newJsonRef() );  
}


function <<test.Test>>  meta::json::schema::tests::titleTest():Boolean[1]
{
 assertJSONEquals(
       newJSONKeyStringValue('title', 'meta::json::schema::tests::Animal'),                      
       Animal -> title() );  
 
 assertJSONEquals(
       newJSONKeyStringValue('title', 'meta::json::schema::tests::Cat'),                      
       Cat -> title() );  
 
 
 assertJSONEquals(
       newJSONKeyStringValue('title', 'meta::json::schema::tests::AnimalType'),                      
       AnimalType -> title() );  
}

function <<test.Test>>   meta::json::schema::tests::descriptionTest():Boolean[1]
{
 assertJSONEquals(
       newJSONKeyStringValue('description', 'The Being Class'),                     
       Being -> description() );  
  
 assertJSONEquals(
       newJSONKeyStringValue('description', 'The OtherInfo Class'),                     
       OtherInfo -> description() ); 
       
 assertJSONEquals(
       newJSONKeyStringValue('description', 'The Animal Class'),                     
       Animal -> description() );  
 
 assertJSONEquals(
       newJSONKeyStringValue('description', 'The Cat Class'),                  
       Cat -> description() );  

 assertEquals(
       newJSONKeyStringValue('description', 'The AnimalType Enum'),                          
       AnimalType -> description() );  
}

            
function <<test.Test>>  meta::json::schema::tests::schemaTest():Boolean[1]
{
 assertJSONEquals(
       newJSONKeyStringValue('$schema', 'http://json-schema.org/draft-07/schema#'),                      
       Animal -> schema() );  
 
  assertJSONEquals(
       newJSONKeyStringValue('$schema', 'http://json-schema.org/draft-07/schema#'),                      
       Being -> schema() );  
 
 
 assertJSONEquals(
       newJSONKeyStringValue('$schema', 'http://json-schema.org/draft-07/schema#'),                      
       OtherInfo -> schema() ); 

 assertJSONEquals(
       newJSONKeyStringValue('$schema', 'http://json-schema.org/draft-07/schema#'),                      
       Cat -> schema() );  
 

 assertJSONEquals(
        newJSONKeyStringValue('$schema', 'http://json-schema.org/draft-07/schema#'),                                     
       AnimalType -> schema() );  
}

function <<test.Test>> meta::json::schema::tests::propertiesTest():Boolean[1]
{
  let expectedJSON = 
     newJSONKeyValue( 'properties',
            newJSONObject( [ 
               newJSONKeyValue( 'vegetarian', newJSONObject( [
                  newJSONKeyStringValue( 'type', 'boolean' ),
                  newJSONKeyStringValue( 'description', 'Is the animal a vegetarian?' )
               ] ) )               
            ] ) );

   assertJSONEquals(
       $expectedJSON,                
       Cat -> properties() );
}

function <<test.Test>> meta::json::schema::tests::allOfGeneralizationsTest():Boolean[1]
{
   let expectedJSON = 
     newJSONKeyValue( 'allOf', ^JSONArray( values = [
            newJSONObject( [ newJSONKeyStringValue( '$ref', '#/definitions/meta::json::schema::tests::Animal' ) ] )       
     ] ) ); 
               
   assertJSONEquals(
       $expectedJSON,                
       Cat -> allOfGeneralizations() );       
}

function <<test.Test>> meta::json::schema::tests::extendsGeneralizationsTest():Boolean[1]
{
   let expectedJSON = 
     newJSONKeyValue( 'extends', ^JSONArray( values = [
            newJSONObject( [ newJSONKeyStringValue( '$ref', '#/definitions/meta::json::schema::tests::Animal' ) ] )       
     ] ) ); 
               
   assertJSONEquals(
       $expectedJSON,                
       Cat -> extendsGeneralizations() );       
}

function <<test.Test>> meta::json::schema::tests::convertPrimitiveTypeTest():Boolean[1]
{
   assertEquals( 'string', String->convertPrimitiveType() );
   assertEquals( 'string', Date->convertPrimitiveType() );
   assertEquals( 'string', DateTime->convertPrimitiveType() );
   assertEquals( 'string', StrictDate->convertPrimitiveType() );
   assertEquals( 'integer', Integer->convertPrimitiveType() );
   assertEquals( 'number', Float->convertPrimitiveType() );
   assertEquals( 'boolean', Boolean->convertPrimitiveType() );  
}

function <<test.Test>> meta::json::schema::tests::allGeneralizationsTest():Boolean[1]
{
   assertEquals( [ Animal, Being ]   , Cat->allGeneralizations() );
   assertEquals( [ Being ]           , Animal->allGeneralizations() );     
}




function <<test.Test>> meta::json::schema::tests::allNonPrimitivePropertiesOfClassTest():Boolean[1]
{
   assertEquals( [ AnimalType, OtherInfo ], Cat->allNonPrimitivePropertiesOfClass() );
}

function <<test.Test>> meta::json::schema::tests::allReferencedElementsTest():Boolean[1]
{ 
    assertEquals( [ Animal, AnimalType , Cat ,  OtherInfo ], Being->allReferencedElements() );
    assertEquals( [ AnimalType, Being,  Cat,   OtherInfo ], Animal->allReferencedElements() );
    assertEquals( [ AnimalType, Animal, Being, OtherInfo ], Cat->allReferencedElements() );
}


function <<test.Test>> meta::json::schema::tests::isEnumTest() : Boolean[1]
{
   assert( AnimalType->isEnum() );
   assertFalse( Being->isEnum() );
   assertFalse( Animal->isEnum() );
   assertFalse( Cat->isEnum() );
   assertFalse( OtherInfo->isEnum() );
}

function <<test.Test>> meta::json::schema::tests::createObjectPropertyTest() : Boolean[1]
{
  assertJSONEquals(
      newJSONKeyStringValue( '$ref', '#/definitions/meta::json::schema::tests::Cat'),
      Cat -> createObjectProperty() ); 
 
 
 
  assertJSONEquals(
      newJSONKeyValue( 'oneOf',
         ^JSONArray( values = [
            newJSONKeyStringValueAsObject( '$ref', '#/definitions/meta::json::schema::tests::Animal'),
            newJSONKeyStringValueAsObject( '$ref', '#/definitions/meta::json::schema::tests::Cat')
         ] ) ), 
      Being -> createObjectProperty() );
 

  assertJSONEquals(
      newJSONKeyStringValue( '$ref', '#'),
      Cat -> createObjectProperty(Cat) );
      
  assertJSONEquals(
      newJSONKeyValue( 'oneOf',
         ^JSONArray( values = [
            newJSONKeyStringValueAsObject( '$ref', '#'),
            newJSONKeyStringValueAsObject( '$ref', '#/definitions/meta::json::schema::tests::Cat')
         ] ) ),
      Animal -> createObjectProperty(Animal) ); 
 
 
 
}

function <<test.Test>> meta::json::schema::tests::enumTest() : Boolean[1]
{
   let expectedJSON = newJSONKeyValue(
      'enum',
      ^JSONArray( values = [ 
         ^JSONString( value='CAT'),
         ^JSONString( value='DOG'),
         ^JSONString( value='BIRD'),
         ^JSONString( value='FISH'),
         ^JSONString( value='HUMAN') ] ) );
         
   assertJSONEquals( $expectedJSON, AnimalType->enum() );
}

function <<test.Test>> meta::json::schema::tests::requiredTest() : Boolean[1]
{
   let expectedJSON = newJSONKeyValue( 'required', ^JSONArray( values = [
      ^JSONString( value = 'name' ),
      ^JSONString( value = 'age' ),
      ^JSONString( value = 'extra' )
   ]));
   
   assertJSONEquals( $expectedJSON, Animal->required() );
}

function <<test.Test>> meta::json::schema::tests::requiredEmptyTest() : Boolean[1]
{
   assertJSONEquals( [], NoRequiredFieldsClass->required() );
}

function <<test.Test>> meta::json::schema::tests::recursiveTest() : Boolean[1]
{
   let expectedJSON = 
   ^JSONObject(keyValuePairs = [
	^JSONKeyValue( key=^JSONString( value='$schema'), value=^JSONString( value = 'http://json-schema.org/draft-07/schema#')),
	^JSONKeyValue( key=^JSONString( value='title'), value=^JSONString( value = 'meta::json::schema::tests::RecursiveTestClass')),
	^JSONKeyValue( key=^JSONString( value='description'), value=^JSONString( value = 'A Recursive Test Class')),
	^JSONKeyValue( key=^JSONString( value='type'), value=^JSONString( value = 'object')),
	^JSONKeyValue( key=^JSONString( value='properties'), value=^JSONObject(keyValuePairs = [
	^JSONKeyValue( key=^JSONString( value='name'), value=^JSONObject(keyValuePairs = [
	^JSONKeyValue( key=^JSONString( value='type'), value=^JSONString( value = 'string'))])),
	^JSONKeyValue( key=^JSONString( value='children'), value=^JSONObject(keyValuePairs = [
	^JSONKeyValue( key=^JSONString( value='type'), value=^JSONString( value = 'array')),
	^JSONKeyValue( key=^JSONString( value='items'), value=^JSONObject(keyValuePairs = [
	^JSONKeyValue( key=^JSONString( value='$ref'), value=^JSONString( value = '#'))]))])),
	^JSONKeyValue( key=^JSONString( value='others'), value=^JSONObject(keyValuePairs = [
	^JSONKeyValue( key=^JSONString( value='type'), value=^JSONString( value = 'array')),
	^JSONKeyValue( key=^JSONString( value='items'), value=^JSONObject(keyValuePairs = [
	^JSONKeyValue( key=^JSONString( value='$ref'), value=^JSONString( value = '#/definitions/meta::json::schema::tests::SomeOtherClass'))]))]))])),
	^JSONKeyValue( key=^JSONString( value='required'), value=^JSONArray( values=[	^JSONString( value = 'name')])),
	^JSONKeyValue( key=^JSONString( value='definitions'), value=^JSONObject(keyValuePairs = [
	^JSONKeyValue( key=^JSONString( value='meta::json::schema::tests::SomeOtherClass'), value=^JSONObject(keyValuePairs = [
	^JSONKeyValue( key=^JSONString( value='$schema'), value=^JSONString( value = 'http://json-schema.org/draft-07/schema#')),
	^JSONKeyValue( key=^JSONString( value='title'), value=^JSONString( value = 'meta::json::schema::tests::SomeOtherClass')),
	^JSONKeyValue( key=^JSONString( value='description'), value=^JSONString( value = 'Some Other Class')),
	^JSONKeyValue( key=^JSONString( value='type'), value=^JSONString( value = 'object')),
	^JSONKeyValue( key=^JSONString( value='properties'), value=^JSONObject(keyValuePairs = [
	^JSONKeyValue( key=^JSONString( value='items'), value=^JSONObject(keyValuePairs = [
	^JSONKeyValue( key=^JSONString( value='type'), value=^JSONString( value = 'array')),
	^JSONKeyValue( key=^JSONString( value='items'), value=^JSONObject(keyValuePairs = [
	^JSONKeyValue( key=^JSONString( value='$ref'), value=^JSONString( value = '#'))]))]))]))
    ]))]))]);
    
   assertJSONEquals($expectedJSON, RecursiveTestClass->toJSONSchema() );
}


function <<test.Test, test.ExcludeAlloy>>meta::json::schema::tests::definitionsTest() : Boolean[1]
{
   let expectedJSON = 
	^JSONKeyValue( key=^JSONString( value='definitions'), value=^JSONObject(keyValuePairs = [

    ^JSONKeyValue( key=^JSONString( value='meta::json::schema::tests::AnimalType'), value=^JSONObject(keyValuePairs = [
	^JSONKeyValue( key=^JSONString( value='$schema'), value=^JSONString( value = 'http://json-schema.org/draft-07/schema#')),
	^JSONKeyValue( key=^JSONString( value='title'), value=^JSONString( value = 'meta::json::schema::tests::AnimalType')),
	^JSONKeyValue( key=^JSONString( value='description'), value=^JSONString( value = 'The AnimalType Enum')),

	^JSONKeyValue( key=^JSONString( value='enum'), value=^JSONArray( values=[	^JSONString( value = 'CAT'),
	^JSONString( value = 'DOG'),
	^JSONString( value = 'BIRD'),
	^JSONString( value = 'FISH'),
	^JSONString( value = 'HUMAN')])),
   ^JSONKeyValue( key=^JSONString( value='type'), value=^JSONString( value = 'string'))
    ]
     
              )),

    ^JSONKeyValue( key=^JSONString( value='meta::json::schema::tests::Being'), value=^JSONObject(keyValuePairs = [
	^JSONKeyValue( key=^JSONString( value='$schema'), value=^JSONString( value = 'http://json-schema.org/draft-07/schema#')),
	^JSONKeyValue( key=^JSONString( value='title'), value=^JSONString( value = 'meta::json::schema::tests::Being')),
	^JSONKeyValue( key=^JSONString( value='description'), value=^JSONString( value = 'The Being Class')),
	^JSONKeyValue( key=^JSONString( value='type'), value=^JSONString( value = 'object')),
       
    ^JSONKeyValue( key=^JSONString( value='anyOf'), value=^JSONArray( values = ^JSONObject(keyValuePairs=^JSONKeyValue( key=^JSONString( value='$ref'), value=^JSONString( value = '#/definitions/meta::json::schema::tests::Animal'))))),

       
	^JSONKeyValue( key=^JSONString( value='properties'), value=^JSONObject(keyValuePairs = [
	^JSONKeyValue( key=^JSONString( value='omg'), value=^JSONObject(keyValuePairs = [
	^JSONKeyValue( key=^JSONString( value='type'), value=^JSONString( value = 'string'))]))])),
	^JSONKeyValue( key=^JSONString( value='required'), value=^JSONArray( values=[	^JSONString( value = 'omg')]))])),

    ^JSONKeyValue( key=^JSONString( value='meta::json::schema::tests::Cat'), value=^JSONObject(keyValuePairs = [
	^JSONKeyValue( key=^JSONString( value='$schema'), value=^JSONString( value = 'http://json-schema.org/draft-07/schema#')),
	^JSONKeyValue( key=^JSONString( value='title'), value=^JSONString( value = 'meta::json::schema::tests::Cat')),
	^JSONKeyValue( key=^JSONString( value='description'), value=^JSONString( value = 'The Cat Class')),
	^JSONKeyValue( key=^JSONString( value='allOf'), value=^JSONArray( values=[	^JSONObject(keyValuePairs = [
	^JSONKeyValue( key=^JSONString( value='$ref'), value=^JSONString( value = '#/definitions/meta::json::schema::tests::Animal'))])])),
	^JSONKeyValue( key=^JSONString( value='type'), value=^JSONString( value = 'object')),
	^JSONKeyValue( key=^JSONString( value='properties'), value=^JSONObject(keyValuePairs = [
	^JSONKeyValue( key=^JSONString( value='vegetarian'), value=^JSONObject(keyValuePairs = [
	^JSONKeyValue( key=^JSONString( value='type'), value=^JSONString( value = 'boolean')),
	^JSONKeyValue( key=^JSONString( value='description'), value=^JSONString( value = 'Is the animal a vegetarian?'))]))])),
	^JSONKeyValue( key=^JSONString( value='required'), value=^JSONArray( values=[	^JSONString( value = 'vegetarian')]))])),

    
    ^JSONKeyValue( key=^JSONString( value='meta::json::schema::tests::OtherInfo'), value=^JSONObject(keyValuePairs = [
	^JSONKeyValue( key=^JSONString( value='$schema'), value=^JSONString( value = 'http://json-schema.org/draft-07/schema#')),
	^JSONKeyValue( key=^JSONString( value='title'), value=^JSONString( value = 'meta::json::schema::tests::OtherInfo')),
	^JSONKeyValue( key=^JSONString( value='description'), value=^JSONString( value = 'The OtherInfo Class')),
	^JSONKeyValue( key=^JSONString( value='type'), value=^JSONString( value = 'object')),
	^JSONKeyValue( key=^JSONString( value='properties'), value=^JSONObject(keyValuePairs = [
	^JSONKeyValue( key=^JSONString( value='info'), value=^JSONObject(keyValuePairs = [
	^JSONKeyValue( key=^JSONString( value='type'), value=^JSONString( value = 'string'))]))])),
	^JSONKeyValue( key=^JSONString( value='required'), value=^JSONArray( values=[	^JSONString( value = 'info')]))]))]));
    
    assertJSONEquals( $expectedJSON, Animal->definitions());
}


function <<test.Test, test.ExcludeAlloy>> meta::json::schema::tests::toJSONSchemaTest():Boolean[1]
{
   let expectedJSON =
   ^JSONObject(keyValuePairs = [
	^JSONKeyValue( key=^JSONString( value='$schema'), value=^JSONString( value = 'http://json-schema.org/draft-07/schema#')),
	^JSONKeyValue( key=^JSONString( value='title'), value=^JSONString( value = 'meta::json::schema::tests::Cat')),
	^JSONKeyValue( key=^JSONString( value='description'), value=^JSONString( value = 'The Cat Class')),
	^JSONKeyValue( key=^JSONString( value='allOf'), value=^JSONArray( values=[	^JSONObject(keyValuePairs = [
	^JSONKeyValue( key=^JSONString( value='$ref'), value=^JSONString( value = '#/definitions/meta::json::schema::tests::Animal'))])])),
	^JSONKeyValue( key=^JSONString( value='type'), value=^JSONString( value = 'object')),
	^JSONKeyValue( key=^JSONString( value='properties'), value=^JSONObject(keyValuePairs = [
	^JSONKeyValue( key=^JSONString( value='vegetarian'), value=^JSONObject(keyValuePairs = [
	^JSONKeyValue( key=^JSONString( value='type'), value=^JSONString( value = 'boolean')),
	^JSONKeyValue( key=^JSONString( value='description'), value=^JSONString( value = 'Is the animal a vegetarian?'))]))])),
	^JSONKeyValue( key=^JSONString( value='required'), value=^JSONArray( values=[	^JSONString( value = 'vegetarian')])),
	^JSONKeyValue( key=^JSONString( value='definitions'), value=^JSONObject(keyValuePairs = [

    ^JSONKeyValue( key=^JSONString( value='meta::json::schema::tests::AnimalType'), value=^JSONObject(keyValuePairs = [
	^JSONKeyValue( key=^JSONString( value='$schema'), value=^JSONString( value = 'http://json-schema.org/draft-07/schema#')),
	^JSONKeyValue( key=^JSONString( value='title'), value=^JSONString( value = 'meta::json::schema::tests::AnimalType')),
	^JSONKeyValue( key=^JSONString( value='description'), value=^JSONString( value = 'The AnimalType Enum')),

	^JSONKeyValue( key=^JSONString( value='enum'), value=^JSONArray( values=[	^JSONString( value = 'CAT'),
	^JSONString( value = 'DOG'),
	^JSONString( value = 'BIRD'),
	^JSONString( value = 'FISH'),
	^JSONString( value = 'HUMAN')])),
    ^JSONKeyValue( key=^JSONString( value='type'), value=^JSONString( value = 'string'))])),

    ^JSONKeyValue( key=^JSONString( value='meta::json::schema::tests::Animal'), value=^JSONObject(keyValuePairs = [
	^JSONKeyValue( key=^JSONString( value='$schema'), value=^JSONString( value = 'http://json-schema.org/draft-07/schema#')),
	^JSONKeyValue( key=^JSONString( value='title'), value=^JSONString( value = 'meta::json::schema::tests::Animal')),
	^JSONKeyValue( key=^JSONString( value='description'), value=^JSONString( value = 'The Animal Class')),
	^JSONKeyValue( key=^JSONString( value='allOf'), value=^JSONArray( values=[	^JSONObject(keyValuePairs = [
	^JSONKeyValue( key=^JSONString( value='$ref'), value=^JSONString( value = '#/definitions/meta::json::schema::tests::Being'))])])),
	^JSONKeyValue( key=^JSONString( value='type'), value=^JSONString( value = 'object')),
     ^JSONKeyValue( key=^JSONString( value='anyOf'), value=^JSONArray( values = ^JSONObject(keyValuePairs=^JSONKeyValue( key=^JSONString( value='$ref'), value=^JSONString( value = '#/definitions/meta::json::schema::tests::Cat'))))),

	^JSONKeyValue( key=^JSONString( value='properties'), value=^JSONObject(keyValuePairs = [
	^JSONKeyValue( key=^JSONString( value='name'), value=^JSONObject(keyValuePairs = [
	^JSONKeyValue( key=^JSONString( value='type'), value=^JSONString( value = 'string'))])),
	^JSONKeyValue( key=^JSONString( value='age'), value=^JSONObject(keyValuePairs = [
	^JSONKeyValue( key=^JSONString( value='type'), value=^JSONString( value = 'integer'))])),
	^JSONKeyValue( key=^JSONString( value='type'), value=^JSONObject(keyValuePairs = [
	^JSONKeyValue( key=^JSONString( value='$ref'), value=^JSONString( value = '#/definitions/meta::json::schema::tests::AnimalType'))])),
	^JSONKeyValue( key=^JSONString( value='aliases'), value=^JSONObject(keyValuePairs = [
	^JSONKeyValue( key=^JSONString( value='type'), value=^JSONString( value = 'array')),
	^JSONKeyValue( key=^JSONString( value='items'), value=^JSONObject(keyValuePairs = [
	^JSONKeyValue( key=^JSONString( value='type'), value=^JSONString( value = 'string'))]))])),
	^JSONKeyValue( key=^JSONString( value='extra'), value=^JSONObject(keyValuePairs = [
	^JSONKeyValue( key=^JSONString( value='type'), value=^JSONString( value = 'array')),
	^JSONKeyValue( key=^JSONString( value='items'), value=^JSONObject(keyValuePairs = [
	^JSONKeyValue( key=^JSONString( value='$ref'), value=^JSONString( value = '#/definitions/meta::json::schema::tests::OtherInfo'))])),
	^JSONKeyValue( key=^JSONString( value='minItems'), value=^JSONNumber( value = 4)),
	^JSONKeyValue( key=^JSONString( value='maxItems'), value=^JSONNumber( value = 4))]))])),
	^JSONKeyValue( key=^JSONString( value='required'), value=^JSONArray( values=[	^JSONString( value = 'name'),
	^JSONString( value = 'age'),
	^JSONString( value = 'extra')]))])),

    
    ^JSONKeyValue( key=^JSONString( value='meta::json::schema::tests::Being'), value=^JSONObject(keyValuePairs = [
	^JSONKeyValue( key=^JSONString( value='$schema'), value=^JSONString( value = 'http://json-schema.org/draft-07/schema#')),
	^JSONKeyValue( key=^JSONString( value='title'), value=^JSONString( value = 'meta::json::schema::tests::Being')),
	^JSONKeyValue( key=^JSONString( value='description'), value=^JSONString( value = 'The Being Class')),
	^JSONKeyValue( key=^JSONString( value='type'), value=^JSONString( value = 'object')),
    ^JSONKeyValue( key=^JSONString( value='anyOf'), value=^JSONArray( values = ^JSONObject(keyValuePairs=^JSONKeyValue( key=^JSONString( value='$ref'), value=^JSONString( value = '#/definitions/meta::json::schema::tests::Animal'))))),
	^JSONKeyValue( key=^JSONString( value='properties'), value=^JSONObject(keyValuePairs = [
	^JSONKeyValue( key=^JSONString( value='omg'), value=^JSONObject(keyValuePairs = [
	^JSONKeyValue( key=^JSONString( value='type'), value=^JSONString( value = 'string'))]))])),
	^JSONKeyValue( key=^JSONString( value='required'), value=^JSONArray( values=[	^JSONString( value = 'omg')]))])),

   

    ^JSONKeyValue( key=^JSONString( value='meta::json::schema::tests::OtherInfo'), value=^JSONObject(keyValuePairs = [
	^JSONKeyValue( key=^JSONString( value='$schema'), value=^JSONString( value = 'http://json-schema.org/draft-07/schema#')),
	^JSONKeyValue( key=^JSONString( value='title'), value=^JSONString( value = 'meta::json::schema::tests::OtherInfo')),
	^JSONKeyValue( key=^JSONString( value='description'), value=^JSONString( value = 'The OtherInfo Class')),
	^JSONKeyValue( key=^JSONString( value='type'), value=^JSONString( value = 'object')),
	^JSONKeyValue( key=^JSONString( value='properties'), value=^JSONObject(keyValuePairs = [
	^JSONKeyValue( key=^JSONString( value='info'), value=^JSONObject(keyValuePairs = [
	^JSONKeyValue( key=^JSONString( value='type'), value=^JSONString( value = 'string'))]))])),
	^JSONKeyValue( key=^JSONString( value='required'), value=^JSONArray( values=[	^JSONString( value = 'info')]))]))]))]);
     
  assertJSONEquals( $expectedJSON, Cat->toJSONSchema() );
}

function <<access.private>> meta::json::schema::tests::assertJSONEquals( expected:JSONObject[0..1], actual:JSONObject[0..1] ):Boolean[1]
{
   let actualJsonString    = if( $actual->isEmpty(),   | '', | $actual->toOne()->toPrettyJSONString()   );
   let expectedJsonString  = if( $expected->isEmpty(), | '', | $expected->toOne()->toPrettyJSONString() );
          
   assertEquals( $expectedJsonString, $actualJsonString );       
}

function <<access.private>> meta::json::schema::tests::assertJSONEquals( expected:JSONKeyValue[0..1], actual:JSONKeyValue[0..1] ):Boolean[1]
{
   let actualJson    = if( $actual->isEmpty(),   | [], | $actual->toOne()->newJSONObject()   );
   let expectedJson  = if( $expected->isEmpty(), | [], | $expected->toOne()->newJSONObject() );

   assertJSONEquals(  $expectedJson, $actualJson );
}


function <<test.Test, test.ExcludeAlloy>> {serverVersion.start='vX_X_X'} meta::json::schema::generation::tests::toJSONSchemaTest():Boolean[1]
{    
    let jsonSchema = toJSONSchema(^JSONSchemaConfig(class='meta::json::schema::tests::Cat'));
    assertFalse( $jsonSchema->isEmpty() );
    assertSize($jsonSchema,1);
   
    let expectedjson=  '{"allOf":[{"$ref":"#\/definitions\/meta::json::schema::tests::Animal"}],"$schema":"http:\/\/json-schema.org\/draft-07\/schema#","description":"The Cat Class","title":"meta::json::schema::tests::Cat","type":"object","definitions":{"meta::json::schema::tests::AnimalType":{"$schema":"http:\/\/json-schema.org\/draft-07\/schema#","description":"The AnimalType Enum","title":"meta::json::schema::tests::AnimalType","type":"string","enum":["CAT","DOG","BIRD","FISH","HUMAN"]},"meta::json::schema::tests::Animal":{"allOf":[{"$ref":"#\/definitions\/meta::json::schema::tests::Being"}],"$schema":"http:\/\/json-schema.org\/draft-07\/schema#","description":"The Animal Class","anyOf":[{"$ref":"#\/definitions\/meta::json::schema::tests::Cat"}],"title":"meta::json::schema::tests::Animal","type":"object","properties":{"aliases":{"type":"array","items":{"type":"string"}},"extra":{"minItems":4,"maxItems":4,"type":"array","items":{"$ref":"#\/definitions\/meta::json::schema::tests::OtherInfo"}},"name":{"type":"string"},"type":{"$ref":"#\/definitions\/meta::json::schema::tests::AnimalType"},"age":{"type":"integer"}},"required":["name","age","extra"]},"meta::json::schema::tests::OtherInfo":{"$schema":"http:\/\/json-schema.org\/draft-07\/schema#","description":"The OtherInfo Class","title":"meta::json::schema::tests::OtherInfo","type":"object","properties":{"info":{"type":"string"}},"required":["info"]},"meta::json::schema::tests::Being":{"$schema":"http:\/\/json-schema.org\/draft-07\/schema#","description":"The Being Class","anyOf":[{"$ref":"#\/definitions\/meta::json::schema::tests::Animal"}],"title":"meta::json::schema::tests::Being","type":"object","properties":{"omg":{"type":"string"}},"required":["omg"]}},"properties":{"vegetarian":{"description":"Is the animal a vegetarian?","type":"boolean"}},"required":["vegetarian"]}';
    assertEquals($expectedjson->meta::json::parseJSON()->toPrettyJSONString(),$jsonSchema->at(0).content->meta::json::parseJSON()->toPrettyJSONString());
}

function <<test.Test, test.ExcludeAlloy>> {serverVersion.start='vX_X_X'} meta::json::schema::generation::tests::toJSONSchemaTestNoOneOf():Boolean[1]
{    
    let jsonSchema = toJSONSchema(^JSONSchemaConfig(class='meta::json::schema::tests::Cat',generateAnyOfSubType=false));
    assertFalse( $jsonSchema->isEmpty() );
    assertSize($jsonSchema,1);
   
    let expectedjson=  '{"allOf":[{"$ref":"#\/definitions\/meta::json::schema::tests::Animal"}],"$schema":"http:\/\/json-schema.org\/draft-07\/schema#","description":"The Cat Class","title":"meta::json::schema::tests::Cat","type":"object","definitions":{"meta::json::schema::tests::AnimalType":{"$schema":"http:\/\/json-schema.org\/draft-07\/schema#","description":"The AnimalType Enum","title":"meta::json::schema::tests::AnimalType","type":"string","enum":["CAT","DOG","BIRD","FISH","HUMAN"]},"meta::json::schema::tests::Animal":{"allOf":[{"$ref":"#\/definitions\/meta::json::schema::tests::Being"}],"$schema":"http:\/\/json-schema.org\/draft-07\/schema#","description":"The Animal Class","title":"meta::json::schema::tests::Animal","type":"object","properties":{"aliases":{"type":"array","items":{"type":"string"}},"extra":{"minItems":4,"maxItems":4,"type":"array","items":{"$ref":"#\/definitions\/meta::json::schema::tests::OtherInfo"}},"name":{"type":"string"},"type":{"$ref":"#\/definitions\/meta::json::schema::tests::AnimalType"},"age":{"type":"integer"}},"required":["name","age","extra"]},"meta::json::schema::tests::OtherInfo":{"$schema":"http:\/\/json-schema.org\/draft-07\/schema#","description":"The OtherInfo Class","title":"meta::json::schema::tests::OtherInfo","type":"object","properties":{"info":{"type":"string"}},"required":["info"]},"meta::json::schema::tests::Being":{"$schema":"http:\/\/json-schema.org\/draft-07\/schema#","description":"The Being Class","title":"meta::json::schema::tests::Being","type":"object","properties":{"omg":{"type":"string"}},"required":["omg"]}},"properties":{"vegetarian":{"description":"Is the animal a vegetarian?","type":"boolean"}},"required":["vegetarian"]}';
    assertEquals($expectedjson->meta::json::parseJSON()->toPrettyJSONString(),$jsonSchema->at(0).content->meta::json::parseJSON()->toPrettyJSONString());
}

function <<test.Test, test.ExcludeAlloy>>  meta::json::schema::generation::tests::testProfile():Boolean[1]
{    
    let jsonSchema = toJSONSchema(^JSONSchemaConfig(class='meta::json::schema::tests::ClassWithProfile',
                                                    includeAllRelatedTypes=false  ));
    assertFalse( $jsonSchema->isEmpty() );
    assertSize($jsonSchema,1);
   
    let expectedjson= '{"allOf":[{"$ref":"ClassWithProfileInterface.json"}],"javaInterfaces":["org.finos.Instrument"],"$schema":"http:\/\/json-schema.org\/draft-07\/schema#","description":"Class With Profile","additionalProperties":false,"title":"meta::json::schema::tests::ClassWithProfile","type":"object","properties":{"pets":{"$ref":"jsonSchemaEnum.json"},"size":{"default":0.0,"description":"number defaulted to zero","type":"number"},"bool":{"default":true,"type":"boolean"},"name":{"default":"test","type":"string"}},"required":["bool","pets"]}';

    assertEquals($expectedjson->meta::json::parseJSON()->toCompactJSONString(),$jsonSchema->at(0).content->meta::json::parseJSON()->toCompactJSONString());

      let jsonSchemaEnum = toJSONSchema(^JSONSchemaConfig(class='meta::json::schema::tests::jsonSchemaEnum',
                                                      includeAllRelatedTypes=false  ));
   

     let expectedjsonEnum= '{"default":"Guinea Pig","$schema":"http:\/\/json-schema.org\/draft-07\/schema#","description":"Enum with Profile","title":"meta::json::schema::tests::jsonSchemaEnum","type":"string","enum":["Dog","Cat","Guinea Pig"]}';
     assertEquals($expectedjsonEnum->meta::json::parseJSON()->toCompactJSONString(),$jsonSchemaEnum->at(0).content->meta::json::parseJSON()->toCompactJSONString());

   
}


function <<test.Test, test.ExcludeAlloy>>  meta::json::schema::generation::tests::testInterface():Boolean[1]
{    
    let jsonSchema = toJSONSchema(^JSONSchemaConfig(class='meta::json::schema::tests::ClassWithProfileInterface',
                                                    includeAllRelatedTypes = false  ));
    assertFalse( $jsonSchema->isEmpty() );
    assertSize($jsonSchema,1);
    let expectedjson=  '{"$schema":"http:\/\/json-schema.org\/draft-07\/schema#","anyOf":[{"$ref":"ClassWithProfile.json"}],"additionalProperties":false,"title":"meta::json::schema::tests::ClassWithProfileInterface","type":"object","javaType":"org.finos.Instrument"}';
    assertEquals($expectedjson->meta::json::parseJSON()->toCompactJSONString(),$jsonSchema->at(0).content->meta::json::parseJSON()->toCompactJSONString());
   
}

function <<test.Test, test.ExcludeAlloy>>  meta::json::schema::generation::tests::toJSONSchemaWithConstraint():Boolean[1]
{    
    let jsonSchema = toJSONSchema(^JSONSchemaConfig(class='meta::json::schema::tests::ClassWithConstraints',
                                                    useConstraints = true  ));
    assertFalse( $jsonSchema->isEmpty() );
    assertSize($jsonSchema,1);
   
    let expectedjson=  '{"$schema":"http:\/\/json-schema.org\/draft-07\/schema#","description":"Class With Constraints","title":"meta::json::schema::tests::ClassWithConstraints","type":"object","properties":{"number":{"anyOf":[{"exclusiveMaximum":15,"exclusiveMinimum":10},{"maximum":2,"minimum":0}],"type":"number"},"dateOrString":{"anyOf":[{"type":"string"},{"format":"date","type":"string"}]},"constant":{"type":"string","enum":["constantValue"]},"inLine":{"anyOf":[{"type":"string"},{"type":"number"}]},"complex":{"oneOf":[{"anyOf":[{"minLength":4,"pattern":"abcd","maxLength":32},{"minLength":7},{"minLength":2}],"type":"string"},{"type":"number"}],"minLength":4},"invalid":{"type":"string"},"duplicateConstraint":{"type":"string"},"simple":{"type":"number"},"invalidMixedProperties":{"type":"string"}},"required":["number"]}';
    assertEquals($expectedjson->meta::json::parseJSON()->toCompactJSONString(),$jsonSchema->at(0).content->meta::json::parseJSON()->toCompactJSONString());
}


function <<test.Test, test.ExcludeAlloy>>  meta::json::schema::generation::tests::toJSONSchemaWithNoDefinitions():Boolean[1]
{    
    let jsonSchema = toJSONSchema(^JSONSchemaConfig(class='meta::json::schema::tests::parent::parentClass',
                                                    includeAllRelatedTypes = false  ));
    assertFalse( $jsonSchema->isEmpty() );
    assertSize($jsonSchema,1);
    
    let expectedjson=  '{"$schema":"http:\/\/json-schema.org\/draft-07\/schema#","title":"meta::json::schema::tests::parent::parentClass","type":"object","properties":{"childClass":{"$ref":"level1\/childClass.json"},"childClass2":{"$ref":"..\/parent2\/level1\/level2\/childClass2.json"}},"required":["childClass","childClass2"]}';

    assertEquals($expectedjson->meta::json::parseJSON()->toCompactJSONString(),$jsonSchema->at(0).content->meta::json::parseJSON()->toCompactJSONString());
}
