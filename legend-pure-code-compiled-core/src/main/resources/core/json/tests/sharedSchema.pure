// Copyright 2020 Goldman Sachs
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import meta::json::schema::tests::profile::*;
import meta::json::schema::fromSchema::*;
import meta::json::schema::fromSchema::tests::*;
import meta::json::*;
import meta::json::schema::generation::*;
import meta::json::schema::tests::*;
Profile meta::json::schema::tests::profile::GeneratedProfile
{
   stereotypes:[customStereoType1,customStereoType2];
   tags:[customTag1,customTag2,customTag3];

}

Class <<GeneratedProfile.customStereoType1>>  {meta::pure::profiles::doc.doc='A simple description',GeneratedProfile.customTag1='10',GeneratedProfile.customTag2='first',GeneratedProfile.customTag2='second'}meta::json::schema::tests::ClassWithCustomProfiles
{
   <<GeneratedProfile.customStereoType1>> simpleString : String[0..1];
   <<GeneratedProfile.customStereoType2>> {GeneratedProfile.customTag3='false'} arrayMaxItemOne : String[0..10];
}


function <<meta::json::schema::JSONSchemaTypeExtension.object>> {meta::pure::profiles::doc.doc='Generate an object tag where there typically would not be any'} meta::json::schema::tests::functionForcedToObject(value: meta::pure::metamodel::type::Any[0..1]): Boolean[1]
{
  $value->meta::pure::functions::collection::isNotEmpty()->meta::pure::functions::lang::if({|[$value->meta::pure::functions::multiplicity::toOne()->meta::pure::functions::meta::instanceOf(meta::json::schema::tests::Cat), $value->meta::pure::functions::multiplicity::toOne()->meta::pure::functions::meta::instanceOf(meta::json::schema::tests::Dog)]->meta::pure::functions::collection::or()}, {|true});
}

Class  meta::json::schema::tests::SimpleClass
{
   p:String[1]; 

}

function  meta::json::schema::tests::functionWithStringType(value: String[0..1]): Boolean[1]
{
  $value->meta::pure::functions::collection::isNotEmpty()->meta::pure::functions::lang::if(|$value->makeString()->matches('test') ,{|true});
}

Class {meta::json::schema::JSONSchemaGeneration.title='a custom title'} meta::json::schema::tests::ClassWithFunctionReferences
[
  one : $this.one->meta::json::schema::tests::functionWithStringType(),
  optional : $this.optional->meta::json::schema::tests::functionWithStringType(),
  many : $this.many->meta::pure::functions::collection::forAll({value|$value->meta::json::schema::tests::functionWithStringType()})
]

{
  one : String[1];
  optional : String[0..1];
  many : String[*];
}

Class meta::json::schema::tests::ClassWithInLineFunctions
[
   multipleOf_inLine : $this.multipleOf->meta::pure::functions::collection::isNotEmpty()->meta::pure::functions::lang::if({|($this.multipleOf->meta::pure::functions::multiplicity::toOne()->meta::pure::functions::math::rem(0.1)) == (0)}, {|true}),
  number_inLine : $this.number->meta::pure::functions::collection::in([1, 2]),
  string_inLine : $this.string->meta::pure::functions::collection::in(['a', 'b']),
  stringOptional_inLine : $this.stringOptional->meta::pure::functions::collection::isNotEmpty()->meta::pure::functions::lang::if({|$this.stringOptional->meta::pure::functions::multiplicity::toOne()->meta::pure::functions::collection::in(['a', 'b'])}, {|true}),
  integer_inLine : $this.integer->meta::pure::functions::collection::in([1, 2]),
  numberOptional_inLine : $this.numberOptional->meta::pure::functions::collection::isNotEmpty()->meta::pure::functions::lang::if({|$this.numberOptional->meta::pure::functions::multiplicity::toOne()->meta::pure::functions::collection::in([1, 2])}, {|true})
]
{
  multipleOf : Float[0..1];
  number : Float[1];
  string : String[1];
  stringOptional : String[0..1];
  integer : Integer[1];
  numberOptional : Float[0..1];
}

Enum <<meta::json::schema::JSONSchemaTypeExtension.null>> meta::json::schema::tests::NullableEnum
{
   one,
   two

}


function <<test.Test>>  { meta::pure::executionPlan::profiles::serverVersion.start='vX_X_X'}  meta::json::schema::tests::roundTrip::typeInclusionForConstraintFunctions():Boolean[1]
{
     let generatedJSON = generateJsonSchemaFromPureWithScope(^JSONSchemaConfig(scopeElements=[meta::json::schema::tests::ClassWithFunctionReferences,meta::json::schema::tests::functionWithStringType_String_$0_1$__Boolean_1_],
                                                         useConstraints = true ,includeAllRelatedTypes=false,generateConstraintFunctionSchemas=true ));

  let jsonschemaclass =       '{' +
'  "$schema": "http:\/\/json-schema.org\/draft-07\/schema#",' +
'  "title": "a custom title",' +
'  "type": "object",' +
'  "properties":   {' +
'    "one":     {' +
'      "$ref": "functionWithStringType.json"' +
'    },' +
'    "many":     {' +
'      "type": "array",' +
'      "items":       {' +
'        "$ref": "functionWithStringType.json"' +
'      }' +
'    },' +
'    "optional":     {' +
'      "$ref": "functionWithStringType.json"' +
'    }' +
'  },' +
'  "required": [' +
'"one"' +
'  ]' +
'}'; 
      
     
   let jsonschemafunc=   '{' +
                     '  "$schema": "http:\/\/json-schema.org\/draft-07\/schema#",' +
                     '  "pattern": "test",' +
                     '  "type": "string",' +
                     '  "title": "meta::json::schema::tests::functionWithStringType"' +
                     '}' ;

  assert(jsonEquivalent($jsonschemaclass->parseJSON(),$generatedJSON->filter(c|$c.fileName == 'meta/json/schema/tests/ClassWithFunctionReferences.json').content->toOne()->parseJSON()));
  
  let prefix = 'meta::json::schema::tests';
  let fileMap = [schemaInput('/ClassWithFunctionReferences.json', $jsonschemaclass,$prefix),
                   schemaInput('/functionWithStringType.json', $jsonschemafunc,$prefix)]; 
  let generatedClassFromJSON =  $fileMap->JSONSchemaToPure()->filter(p|$p.name=='ClassWithFunctionReferences')->toOne();

  assert(jsonEquivalent(meta::json::schema::tests::ClassWithFunctionReferences->toSerializer()->parseJSON(),$generatedClassFromJSON->toOne()->toSerializer()->parseJSON()));
      testfromJSONSchema(meta::json::schema::tests::ClassWithFunctionReferences,$generatedClassFromJSON);

}



function <<test.Test>>  { meta::pure::executionPlan::profiles::serverVersion.start='vX_X_X'}  meta::json::schema::tests::roundTrip::testCustomProfile():Boolean[1]
{
   
  let generatedJSONFromClassOpenAPI = generateJsonSchemaFromPureWithScope(^JSONSchemaConfig(scopeElements=[meta::json::schema::tests::ClassWithCustomProfiles,meta::json::schema::tests::profile],
                                                         useConstraints = true ,includeAllRelatedTypes=false,generateConstraintFunctionSchemas=true,schemaSpecification=JSONSchemaSpecification.OPEN_API_V3_0_3 ));
   let jsonSchemaOpenAPI  = ' {\n' +
        '  "x-customStereoType1": true,\n' +
        '  "description": "A simple description",\n' +
        '  "title": "meta::json::schema::tests::ClassWithCustomProfiles",\n' +
        '  "x-customTag2": [\n' +
        '"first",\n' +
        '"second"\n' +
        '  ],\n' +
        '  "type": "object",\n' +
        '  "properties":   {\n' +
        '    "simpleString":     {\n' +
        '      "x-customStereoType1": true,\n' +
        '      "type": "string"\n' +
        '    },\n' +
        '    "arrayMaxItemOne":     {\n' +
        '      "x-customStereoType2": true,\n' +
        '      "maxItems": 10,\n' +
        '      "type": "array",\n' +
        '      "x-customTag3": "false",\n' +
        '      "items":       {\n' +
        '        "type": "string"\n' +
        '      }\n' +
        '    }\n' +
        '  },\n' +
        '  "x-customTag1": 10\n' +
        '}';
          assert(jsonEquivalent($jsonSchemaOpenAPI->parseJSON(),$generatedJSONFromClassOpenAPI.content->toOne()->parseJSON()));

   
   
      
    let prefix = 'meta::json::schema::tests';
    let fileMap = [schemaInput('/ClassWithCustomProfiles.json', $jsonSchemaOpenAPI,$prefix)]; 
    let generatedClassFromJSON =  $fileMap->JSONSchemaToPure(); 
     //should return  a Profile the schemas
   
   let generatedClassOpenAPI  = $generatedClassFromJSON->filter(p|$p.name=='ClassWithCustomProfiles')->toOne();
   let generatedProfileOpenAPI  = $generatedClassFromJSON->filter(p|$p.name=='GeneratedProfile')->toOne();
//   assert(jsonEquivalent(meta::json::schema::tests::ClassWithCustomProfiles->toSerializer()->parseJSON(),$generatedClassOpenAPI->toOne()->toSerializer()->parseJSON()));
//   assert(jsonEquivalent(meta::json::schema::tests::profile::GeneratedProfile->toSerializer()->parseJSON(),$generatedProfileOpenAPI->toOne()->toSerializer()->parseJSON()));
      testfromJSONSchema(meta::json::schema::tests::ClassWithCustomProfiles,$generatedClassFromJSON);

      testfromJSONSchema(meta::json::schema::tests::profile::GeneratedProfile,$generatedClassFromJSON);

   
      
    let generatedJSONFromClassDraft07 = generateJsonSchemaFromPureWithScope(^JSONSchemaConfig(scopeElements=[meta::json::schema::tests::ClassWithCustomProfiles,meta::json::schema::tests::profile],
                                                         useConstraints = true ,includeAllRelatedTypes=false,generateConstraintFunctionSchemas=true ));
   
   let jsonSchemaDraft07  = ' {\n' +
        '  "customStereoType1": true,\n' +
        '  "description": "A simple description",\n' +
        '  "$schema": "http:\/\/json-schema.org\/draft-07\/schema#",' +
        '  "title": "meta::json::schema::tests::ClassWithCustomProfiles",\n' +
        '  "customTag2": [\n' +
        '"first",\n' +
        '"second"\n' +
        '  ],\n' +
        '  "type": "object",\n' +
        '  "properties":   {\n' +
        '    "simpleString":     {\n' +
        '      "customStereoType1": true,\n' +
        '      "type": "string"\n' +
        '    },\n' +
        '    "arrayMaxItemOne":     {\n' +
        '      "customStereoType2": true,\n' +
        '      "maxItems": 10,\n' +
        '      "type": "array",\n' +
        '      "customTag3": "false",\n' +
        '      "items":       {\n' +
        '        "type": "string"\n' +
        '      }\n' +
        '    }\n' +
        '  },\n' +
        '  "customTag1": 10\n' +
        '}';
   
   assert(jsonEquivalent($jsonSchemaDraft07->parseJSON(),$generatedJSONFromClassDraft07.content->toOne()->parseJSON()));
  let fileMapDraft07 = [schemaInput('/ClassWithCustomProfiles.json', $jsonSchemaDraft07,$prefix)]; 
  let generatedClassFromJSONDraft07 =  $fileMapDraft07->JSONSchemaToPure(); 
  let generatedClassDraft07  = $generatedClassFromJSON->filter(p|$p.name=='ClassWithCustomProfiles')->toOne();
  let generatedProfileDraft07  = $generatedClassFromJSON->filter(p|$p.name=='GeneratedProfile')->toOne();
//   assert(jsonEquivalent(meta::json::schema::tests::ClassWithCustomProfiles->toSerializer()->parseJSON(),$generatedClassDraft07->toOne()->toSerializer()->parseJSON()));
//   assert(jsonEquivalent(meta::json::schema::tests::profile::GeneratedProfile->toSerializer()->parseJSON(),$generatedProfileDraft07->toOne()->toSerializer()->parseJSON()));

   testfromJSONSchema(meta::json::schema::tests::ClassWithCustomProfiles,$generatedClassFromJSON);
   testfromJSONSchema(meta::json::schema::tests::profile::GeneratedProfile,$generatedClassFromJSON);

   
}

function <<test.Test>>   { meta::pure::executionPlan::profiles::serverVersion.start='vX_X_X'}  meta::json::schema::tests::roundTrip::testforceFunctionToObject():Boolean[1]
{
   
     let generatedJSONFromElement = generateJsonSchemaFromPureWithScope(^JSONSchemaConfig(scopeElements=[meta::json::schema::tests::functionForcedToObject_Any_$0_1$__Boolean_1_],
                                                          useConstraints = true ,includeAllRelatedTypes=false,generateConstraintFunctionSchemas=true ));  
   let jsonSchema  = '{' +
'  "anyOf": [' +
'    {' +
'      "$ref": "Cat.json"' +
'    },' +
'    {' +
'      "$ref": "Dog.json"' +
'    }' +
'  ],' +
'  "title": "meta::json::schema::tests::functionForcedToObject",' +
'  "type": "object",' +
'  "$schema": "http:\/\/json-schema.org\/draft-07\/schema#",' +
'  "description": "Generate an object tag where there typically would not be any"' +
'}';
  
   assert(jsonEquivalent($jsonSchema->parseJSON(),$generatedJSONFromElement.content->toOne()->parseJSON()));
    let prefix = 'meta::json::schema::tests';
    let fileMap = [schemaInput('/functionForcedToObject.json', $jsonSchema,$prefix)]; 
    let generatedElementFromJSON =  $fileMap->JSONSchemaToPure(); 
   testfromJSONSchema(meta::json::schema::tests::functionForcedToObject_Any_$0_1$__Boolean_1_,$generatedElementFromJSON);
}

function <<test.Test>>   { meta::pure::executionPlan::profiles::serverVersion.start='vX_X_X'}  meta::json::schema::tests::roundTrip::testinLineFunctions():Boolean[1]
{
     let generatedJSONFromElement = generateJsonSchemaFromPureWithScope(^JSONSchemaConfig(scopeElements=[ meta::json::schema::tests::ClassWithInLineFunctions],
                                                          useConstraints = true ,includeAllRelatedTypes=false,generateConstraintFunctionSchemas=true ));  
   let jsonSchema  = '{' +
                     '  "$schema": "http:\/\/json-schema.org\/draft-07\/schema#",' +
                     '  "title": "meta::json::schema::tests::ClassWithInLineFunctions",' +
                     '  "type": "object",' +
                     '  "properties":   {' +
                     '    "number":     {' +
                     '      "type": "number",' +
                     '      "enum": [' +
                     '1,' +
                     '2' +
                     '      ]' +
                     '    },' +
                     '    "string":     {' +
                     '      "type": "string",' +
                     '      "enum": [' +
                     '"a",' +
                     '"b"' +
                     '      ]' +
                     '    },' +
                     '    "stringOptional":     {' +
                     '      "type": "string",' +
                     '      "enum": [' +
                     '"a",' +
                     '"b"' +
                     '      ]' +
                     '    },' +
                     '    "integer":     {' +
                     '      "type": "integer",' +
                     '      "enum": [' +
                     '1,' +
                     '2' +
                     '      ]' +
                     '    },' +

                     '    "numberOptional":     {' +
                     '      "type": "number",' +
                     '      "enum": [' +
                     '1,' +
                     '2' +
                     '      ]' +
                     '    },' +
                     '    "multipleOf":     {' +
                     '      "type": "number",' +
                     '      "multipleOf": 0.1' +
                     '    }' +   

                     '  },' +
                     '  "required": [' +
                     '"number",' +
                     '"string",' +
                     '"integer"' +   
                     '  ]' +
                     '}' ;
    
   
  
   assert(jsonEquivalent($jsonSchema->parseJSON(),$generatedJSONFromElement.content->toOne()->parseJSON()));
   let prefix = 'meta::json::schema::tests';
   let fileMap = [schemaInput('/ClassWithInLineFunctions.json', $jsonSchema,$prefix)]; 
   let generatedElementFromJSON =  $fileMap->JSONSchemaToPure(); 
   meta::json::schema::fromSchema::tests::testfromJSONSchema(meta::json::schema::tests::ClassWithInLineFunctions,$generatedElementFromJSON);

}



function <<test.Test>>   { meta::pure::executionPlan::profiles::serverVersion.start='vX_X_X'}  meta::json::schema::tests::roundTrip::testComplexPaths():Boolean[1]
{
    let jsonSchema = generateJsonSchemaFromPureWithScope(^JSONSchemaConfig(scopeElements=[meta::json::schema::tests::parent::parentClass,
                                                                                          meta::json::schema::tests::parent2::level1::level2::childClass2,
                                                                                          meta::json::schema::tests::parent::parent::levela::parentClass2,
                                                                                          meta::json::schema::tests::parent::level1::childClass,
                                                                                          meta::json::schema::tests::parent::level1::level2::childClass3,
                                                                                          meta::json::schema::tests::parent::level1::levela::childClass4 ],
                                                                           includeAllRelatedTypes = false  ));

    assertFalse( $jsonSchema->isEmpty() );
    assertSize($jsonSchema,6);
   
    let expectedParentjson=  '{"$schema":"http:\/\/json-schema.org\/draft-07\/schema#","title":"meta::json::schema::tests::parent::parentClass","type":"object","properties":{"childClass":{"$ref":"level1\/childClass.json"},"childClass2":{"$ref":"..\/parent2\/level1\/level2\/childClass2.json"}},"required":["childClass","childClass2"]}';

    let actualParentJSON =  $jsonSchema->filter(f|$f.fileName=='meta/json/schema/tests/parent/parentClass.json').content->toOne()->meta::json::parseJSON()->toCompactJSONString();

    assertEquals($expectedParentjson->meta::json::parseJSON()->toCompactJSONString(),$actualParentJSON);

    let expectedChildJSON = '{"$schema":"http:\/\/json-schema.org\/draft-07\/schema#","title":"meta::json::schema::tests::parent::level1::childClass","type":"object"}';
   let actualChildJSON =  $jsonSchema->filter(f|$f.fileName=='meta/json/schema/tests/parent/level1/childClass.json').content->toOne()->meta::json::parseJSON()->toCompactJSONString();
   assertEquals($expectedChildJSON->meta::json::parseJSON()->toCompactJSONString(),$actualChildJSON);
   
   let expectedParent2 = '{"$schema":"http:\/\/json-schema.org\/draft-07\/schema#","title":"meta::json::schema::tests::parent::parent::levela::parentClass2","type":"object","properties":{"childClass3":{"$ref":"..\/..\/level1\/level2\/childClass3.json"},"childClass4":{"$ref":"..\/..\/level1\/levela\/childClass4.json"}},"required":["childClass3"]}';
   let actualParent2JSON =  $jsonSchema->filter(f|$f.fileName=='meta/json/schema/tests/parent/parent/levela/parentClass2.json').content->toOne()->meta::json::parseJSON()->toCompactJSONString();
   
   assertEquals($expectedParent2->meta::json::parseJSON()->toCompactJSONString(),$actualParent2JSON);

   let expectedchild2 = '{"$schema":"http:\/\/json-schema.org\/draft-07\/schema#","title":"meta::json::schema::tests::parent2::level1::level2::childClass2","type":"object","properties":{"parentClass":{"$ref":"..\/..\/..\/parent\/parentClass.json"}},"required":["parentClass"]}';
   let actualChild2 =  $jsonSchema->filter(f|$f.fileName=='meta/json/schema/tests/parent2/level1/level2/childClass2.json').content->toOne()->meta::json::parseJSON()->toCompactJSONString();
   
   let expectedchild3 = '{"$schema":"http:\/\/json-schema.org\/draft-07\/schema#","title":"meta::json::schema::tests::parent::level1::level2::childClass3","type":"object"}';
   let actualchild3 =  $jsonSchema->filter(f|$f.fileName=='meta/json/schema/tests/parent/level1/level2/childClass3.json').content->toOne()->meta::json::parseJSON()->toCompactJSONString();

   let expectedchild4 = '{"$schema":"http:\/\/json-schema.org\/draft-07\/schema#","title":"meta::json::schema::tests::parent::level1::levela::childClass4","type":"object"}';
   let actualchild4 =  $jsonSchema->filter(f|$f.fileName=='meta/json/schema/tests/parent/level1/levela/childClass4.json').content->toOne()->meta::json::parseJSON()->toCompactJSONString();

   
    let prefix = 'meta::json::schema::tests';
   
   let fileMap = [schemaInput('/parent/parentClass.json', $expectedParentjson,$prefix),
                 schemaInput('/parent/level1/childClass.json', $expectedChildJSON,$prefix),
                 schemaInput('/parent/parent/levela/parentClass2.json', $expectedParent2,$prefix),
                 schemaInput('/parent2/level1/level2/childClass2.json', $expectedchild2,$prefix),         
                 schemaInput('/parent/level1/level2/childClass3.json', $expectedchild3,$prefix),
                 schemaInput('/parent/level1/levela/childClass4.json', $expectedchild4,$prefix)        

   
   ]; 
    let generatedElementFromJSON =  $fileMap->JSONSchemaToPure(); 
   
//    assert(jsonEquivalent(meta::json::schema::tests::parent::parentClass->toSerializer()->parseJSON(),$generatedElementFromJSON->filter(p|$p->elementToPath()=='meta::json::schema::tests::parent::parentClass')->toOne()->toSerializer()->parseJSON()));
  
//    assert(jsonEquivalent(meta::json::schema::tests::parent2::level1::level2::childClass2->toSerializer()->parseJSON(),$generatedElementFromJSON->filter(p|$p->elementToPath()=='meta::json::schema::tests::parent2::level1::level2::childClass2')->toOne()->toSerializer()->parseJSON()));

//    assert(jsonEquivalent(meta::json::schema::tests::parent::parent::levela::parentClass2->toSerializer()->parseJSON(),$generatedElementFromJSON->filter(p|$p->elementToPath()=='meta::json::schema::tests::parent::parent::levela::parentClass2')->toOne()->toSerializer()->parseJSON()));

       meta::json::schema::fromSchema::tests::testfromJSONSchema(meta::json::schema::tests::parent::parentClass,$generatedElementFromJSON);
       meta::json::schema::fromSchema::tests::testfromJSONSchema(meta::json::schema::tests::parent2::level1::level2::childClass2,$generatedElementFromJSON);
       meta::json::schema::fromSchema::tests::testfromJSONSchema(meta::json::schema::tests::parent::parent::levela::parentClass2,$generatedElementFromJSON);

   
   
}

function <<test.Test>>   { meta::pure::executionPlan::profiles::serverVersion.start='vX_X_X'}  meta::json::schema::tests::roundTrip::testNullableEnum():Boolean[1]

{
       let jsonSchema = generateJsonSchemaFromPureWithScope(^JSONSchemaConfig(scopeElements=[meta::json::schema::tests::NullableEnum]));
       let jsonSchemaOpenAPI = generateJsonSchemaFromPureWithScope(^JSONSchemaConfig(scopeElements=[meta::json::schema::tests::NullableEnum],schemaSpecification=JSONSchemaSpecification.OPEN_API_V3_0_3));

       let expectedJSON =  '{' +
                           '  "$schema": "http:\/\/json-schema.org\/draft-07\/schema#",' +
                           '  "title": "meta::json::schema::tests::NullableEnum",' +
                           '  "enum": [' +
                           '"one",' +
                           '"two",' +
                           'null' +
                           '  ],' +
                           '  "type": [' +
                           '"string",' +
                           '"null"' +
                           '  ]' +
                           '}' ;

       let expectedOpenAPIJSON = '{' +
                                 '  "title": "meta::json::schema::tests::NullableEnum",' +
                                 '  "nullable": true,' +
                                 '  "enum": [' +
                                 '"one",' +
                                 '"two",' +
                                 'null' +
                                 '  ],' +
                                 '  "type": "string"' +
                                 '}';
   
      assert(jsonEquivalent($expectedJSON->parseJSON(),$jsonSchema.content->toOne()->parseJSON()));
      assert(jsonEquivalent($expectedOpenAPIJSON->parseJSON(),$jsonSchemaOpenAPI.content->toOne()->parseJSON()));
      let prefix = 'meta::json::schema::tests';
      let fileMap = [schemaInput('/NullableEnum.json', $expectedJSON,$prefix)];
      let fileMapOpenAPI = [schemaInput('/NullableEnum.json', $expectedOpenAPIJSON,$prefix)];

      let generatedElementFromJSON =  $fileMap->JSONSchemaToPure(); 
      let generatedElementFromJSONOpenAPI =  $fileMapOpenAPI->JSONSchemaToPure(); 
       meta::json::schema::fromSchema::tests::testfromJSONSchema(meta::json::schema::tests::NullableEnum,$generatedElementFromJSON);
       meta::json::schema::fromSchema::tests::testfromJSONSchema(meta::json::schema::tests::NullableEnum,$generatedElementFromJSONOpenAPI);

}


function <<test.Test>>  { meta::pure::executionPlan::profiles::serverVersion.start='vX_X_X'}  meta::json::schema::tests::roundTrip::testDefinitions():Boolean[1]
{
   let generatedJSONSchema = generateJsonSchemaFromPureWithScope(^JSONSchemaConfig(scopeElements=[meta::json::schema::tests::parent::parent::levela::parentClass2]));
   
   let expectedJSON = '{' +
                  '  "$schema": "http:\/\/json-schema.org\/draft-07\/schema#",' +
                  '  "title": "meta::json::schema::tests::parent::parent::levela::parentClass2",' +
                  '  "type": "object",' +
                  '  "properties":   {' +
                  '    "childClass4":     {' +
                  '      "$ref": "#\/definitions\/meta::json::schema::tests::parent::level1::levela::childClass4"' +
                  '    },' +
                  '    "childClass3":     {' +
                  '      "$ref": "#\/definitions\/meta::json::schema::tests::parent::level1::level2::childClass3"' +
                  '    }' +
                  '  },' +
                  '  "required": [' +
                  '"childClass3"' +
                  '  ],' +
                  '  "definitions":   {' +
                  '    "meta::json::schema::tests::parent::level1::level2::childClass3":     {' +
                  '      "$schema": "http:\/\/json-schema.org\/draft-07\/schema#",' +
                  '      "title": "meta::json::schema::tests::parent::level1::level2::childClass3",' +
                  '      "type": "object"' +
                  '    },' +
                  '    "meta::json::schema::tests::parent::level1::levela::childClass4":     {' +
                  '      "$schema": "http:\/\/json-schema.org\/draft-07\/schema#",' +
                  '      "title": "meta::json::schema::tests::parent::level1::levela::childClass4",' +
                  '      "type": "object"' +
                  '    }' +
                  '  }' +
                  '}';
      assert(jsonEquivalent($expectedJSON->parseJSON(),$generatedJSONSchema.content->toOne()->parseJSON()));

      let prefix = 'meta::json::schema::tests';
      let fileMap = [schemaInput('/parent/parent/levela/parentClass2.json', $expectedJSON,$prefix)];
     let generatedElementFromJSON =  $fileMap->JSONSchemaToPure();
      meta::json::schema::fromSchema::tests::testfromJSONSchema(meta::json::schema::tests::parent::parent::levela::parentClass2,$generatedElementFromJSON);
      meta::json::schema::fromSchema::tests::testfromJSONSchema(meta::json::schema::tests::parent::level1::levela::childClass4,$generatedElementFromJSON);
      meta::json::schema::fromSchema::tests::testfromJSONSchema(meta::json::schema::tests::parent::level1::level2::childClass3,$generatedElementFromJSON);

}
