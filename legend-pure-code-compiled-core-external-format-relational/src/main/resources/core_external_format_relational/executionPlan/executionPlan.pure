// Copyright 2022 Goldman Sachs
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import meta::external::shared::format::binding::*;
import meta::pure::metamodel::path::*;
import meta::external::shared::format::executionPlan::*;
import meta::external::shared::format::binding::validation::*;

import meta::external::format::relational::executionPlan::*;
import meta::external::format::relational::executionPlan::helperFunction::*;

import meta::pure::executionPlan::*;
import meta::pure::executionPlan::engine::java::*;
import meta::pure::executionPlan::toString::*;
import meta::pure::graphFetch::*;
import meta::pure::graphFetch::executionPlan::*;
import meta::pure::router::extension::*;
import meta::pure::runtime::*;
import meta::external::language::java::factory::project::*;
import meta::external::format::relational::metamodel::*;
import meta::pure::model::unit::*;

import meta::external::format::json::binding::validation::*;
import meta::external::format::json::executionPlan::*;
import meta::external::format::json::executionPlan::engine::java::jsonSerialize::helperFunctions::*;

Class meta::external::format::relational::executionPlan::RelationalTdsSerializeExecutionNode extends ExternalFormatSerializeExecutionNode
{

}


Class meta::external::format::relational::executionPlan::RelationalGraphSerializeExecutionNode extends ExternalFormatSerializeExecutionNode
{

}

function meta::external::format::relational::executionPlan::generateSerializeNode(checked:Boolean[1], binding:Binding[1], children:ExecutionNode[*]): ExternalFormatSerializeExecutionNode[1]
{
   assert($binding.schemaSet->isNotEmpty() && $binding.schemaSet.format == 'RELATIONAL', |'A relational schema set must be provided');

   let schema = if($binding.schemaId->isEmpty(),
                           |$binding.schemaSet.schemas->at(0),
                           |$binding.schemaSet.schemas->filter(s | $s.id == $binding.schemaId)->toOne());


// todo validate children 
  $schema.detail->match([
    tds: RelationalTdsSchema[1] | ^meta::external::format::relational::executionPlan::RelationalTdsSerializeExecutionNode(resultType = ^ResultType(type=String), resultSizeRange = PureOne, checked = $checked, binding = $binding, executionNodes = $children),
    graph: RelationalGraphSchema[1] | ^meta::external::format::relational::executionPlan::RelationalGraphSerializeExecutionNode(resultType = ^ResultType(type=String), resultSizeRange = PureOne, checked = $checked, binding = $binding, executionNodes = $children)
  ]);
}

function meta::external::format::relational::executionPlan::generateDeserializeNode(connection:Connection[1], children:ExecutionNode[1], tree:RootGraphFetchTree<Any>[0..1]): ExecutionNode[1]
{
   fail('Relational deserialization not supported');
   []->cast(@ExecutionNode)->toOne();
}

function meta::external::format::relational::executionPlan::printPlanNodeToString(space:String[1], extensions:RouterExtension[*]): Function<{Nil[1]->String[1]}>[*]
{
   [
      {node:RelationalTdsSerializeExecutionNode[1] |
         'Relational_TDS_Serialize\n' + 
         $space + '(' + header($node, $space, $extensions) + '\n' +
         $space + '  checked = ' + $node.checked->toString() + '\n' +
         $space + '  binding = ' + $node.binding->elementToPath() + '\n' +
         $node->childrenToString($space+'  ', $extensions) + '\n' +
         $node.implementation->printImplementation('implementation', $space+'  ', $extensions) +
         $space + ')\n'
      },
      {node:RelationalGraphSerializeExecutionNode[1] |
         'Relational_Graph_Serialize\n' + 
         $space + '(' + header($node, $space, $extensions) + '\n' +
         $space + '  checked = ' + $node.checked->toString() + '\n' +
         $space + '  binding = ' + $node.binding->elementToPath() + '\n' +
         $node->childrenToString($space+'  ', $extensions) + '\n' +
         $node.implementation->printImplementation('implementation', $space+'  ', $extensions) +
         $space + ')\n'
      }      
   ]
}

function meta::external::format::relational::executionPlan::planJavaPrepare(path:String[1], context:GenerationContext[1], extensions:RouterExtension[*], debug:DebugContext[1]): Function<{Nil[1]->GenerationContext[1]}>[*]
{
   [
      node:RelationalTdsSerializeExecutionNode[1]   | prepareRelationalTdsSchema($node, $path, $context, $extensions, $debug),
      node:RelationalGraphSerializeExecutionNode[1]   | prepareRelationalGraphSchema($node, $path, $context, $extensions, $debug)
   ]
}

function meta::external::format::relational::executionPlan::planJavaGenerate(path:String[1], context:GenerationContext[1], extensions:RouterExtension[*], debug:DebugContext[1]): Function<{Nil[1]->GeneratedCode[1]}>[*]
{
   [
       node:RelationalTdsSerializeExecutionNode[1]   | generateForRelationalTdsSerialize($node, $path, $context, $extensions, $debug),
       node:RelationalGraphSerializeExecutionNode[1]   | generateForRelationalGraphSerialize($node, $path, $context, $extensions, $debug)

   ]
}

// ========================================================================================================================================================
// prepare
// ========================================================================================================================================================

function meta::external::format::relational::executionPlan::prepareRelationalTdsSchema(node:RelationalTdsSerializeExecutionNode[1], path:String[1], context:GenerationContext[1], extensions:RouterExtension[*], debug:DebugContext[1]): GenerationContext[1]
{
  print(if($debug.debug,|$debug.space+'('+$path+') prepare RelationalTdsSerializeExecutionNode\n', |''));
  let binding = $node.binding;
  let schema = if($binding.schemaId->isEmpty(), |$binding.schemaSet.schemas->at(0), |$binding.schemaSet.schemas->filter(s | $s.id == $binding.schemaId)->toOne()).detail->cast(@RelationalTdsSchema);
  let outputColumns = $node.executionNodes.resultType->match([
                    t:TDSResultType[1] | $t.tdsColumns
                  ]);
  $outputColumns->map({x|
    let tCol = $schema.table.column($x.name);
    assert($tCol->isNotEmpty(), |'Output column: ' + $x.name + ' not found in binding table: ' + $schema.table.name);
    let tColType = $tCol->toOne().type->meta::relational::metamodel::datatype::dataTypeToCompatiblePureType();
    assert($tColType == $x.type, |'Column ' + $schema.table.name->toOne() + ' type incomatible.  Table expect: ' + $tColType->toString() + ' TDS has: ' + $x.type->makeString());
  });
  $context;
}

function meta::external::format::relational::executionPlan::prepareRelationalGraphSchema(node:RelationalGraphSerializeExecutionNode[1], path:String[1], context:GenerationContext[1], extensions:RouterExtension[*], debug:DebugContext[1]): GenerationContext[1]
{
  print(if($debug.debug,|$debug.space+'('+$path+') prepare RelationalGraphSerializeExecutionNode\n', |''));
  let binding = $node.binding;
  let classIn = $node.executionNodes.resultType->match([
                         c:ClassResultType[1] | $c.type->cast(@Class<Any>)
                      ]);
  assert($classIn->in($binding.modelUnit->resolve().classes), |'Class ' + $classIn->elementToPath() + ' not found on binding model unit.');

  let tree = $node.executionNodes->at(0)->cast(@GlobalGraphFetchExecutionNode).localGraphFetchExecutionNode.graphFetchTree->cast(@RootGraphFetchTree<Any>);
  $tree->validateTree($binding);
  $tree->treeToContext($path, $context);
}

function meta::external::format::relational::executionPlan::helperFunction::validateTree(tree:RootGraphFetchTree<Any>[1], binding:Binding[1]): Boolean[1]
{
  let dbSchema = if($binding.schemaId->isEmpty(),
                          |$binding.schemaSet.schemas->at(0),
                          |$binding.schemaSet.schemas->filter(s | $s.id == $binding.schemaId)->toOne()).detail->cast(@RelationalGraphSchema).schema;
  $tree.subTrees->filter(x | $x->instanceOf(PropertyGraphFetchTree))->cast(@PropertyGraphFetchTree)->forAll(x | $x->validateSubTree($dbSchema));
}

function meta::external::format::relational::executionPlan::helperFunction::validateSubTree(tree:PropertyGraphFetchTree[1], dbSchema:meta::relational::metamodel::Schema[1]): Boolean[1]
{
  //use FailedBindingDetail to collect errors
  let tableName = $tree.alias->isEmpty()->if(|$tree.property.name->toOne(), |$tree.alias->toOne());
  let dbTable = $dbSchema.table($tableName);
  assert($dbTable->isNotEmpty(), |'Table: ' + $tableName + '(property: ' + $tree.property.name->toOne() + ') not found on binding schema: ' + $dbSchema.name);

  $tree.subTrees->cast(@PropertyGraphFetchTree)->forAll({cp|
    let columnName = $cp.alias->isEmpty()->if(|$cp.property.name->toOne(), |$cp.alias->toOne());
    let tCol = $dbTable.column($columnName);
    assert($tCol->isNotEmpty(), |'Column: ' + $columnName + '(property: ' + $cp.property.name->toOne() + ') not found in binding table: ' + $tableName);
    let tColType = $tCol->toOne().type->meta::relational::metamodel::datatype::dataTypeToCompatiblePureType();
    let pType = $cp.property->functionReturnType().rawType->toOne();
    assert($tColType == $pType, |'Column: ' + $columnName + '(property: ' + $cp.property.name->toOne() + ') type incomatible.  Table expect: ' + $tColType->toString() + ' Property is: ' + $pType->makeString());
  });
}


// ========================================================================================================================================================
// generate
// ========================================================================================================================================================

function meta::external::format::relational::executionPlan::generateForRelationalTdsSerialize(node:RelationalTdsSerializeExecutionNode[1], path:String[1], context:GenerationContext[1], extensions:RouterExtension[*], debug:DebugContext[1]): GeneratedCode[1]
{
   print(if($debug.debug,|$debug.space+'('+$path+') generate RelationalTdsSerializeExecutionNode\n', |''));  
   ^meta::pure::executionPlan::engine::java::GeneratedCode();
}


function meta::external::format::relational::executionPlan::generateForRelationalGraphSerialize(node:RelationalGraphSerializeExecutionNode[1], path:String[1], context:GenerationContext[1], extensions:RouterExtension[*], debug:DebugContext[1]): GeneratedCode[1]
{
   print(if($debug.debug,|$debug.space+'('+$path+') generate RelationalGraphSerializeExecutionNode\n', |''));
   generateJsonSerializer($path, $context, $debug);
}
