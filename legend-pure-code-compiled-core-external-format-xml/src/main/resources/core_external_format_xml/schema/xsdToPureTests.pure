// Copyright 2021 Goldman Sachs
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import meta::external::shared::*;
import meta::external::shared::metamodel::*;
import meta::xsd::tests::toPure::*;
import meta::xml::metamodel::*;
import meta::xsd::toPure::*;
import meta::xsd::metamodel::*;

Class meta::xsd::tests::toPure::fixture1::Rectangle
{
   {meta::pure::profiles::doc.doc = 'One of two dimensions of a rectangle'} height: Integer[1..*];
   width: Integer[*];
}

function <<test.Test>> meta::xsd::tests::toPure::testSimpleClass():Boolean[1]
{
   // <?xml version='1.0'?>
   // <xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema">
   //   <xs:complexType name="Rectangle">
   //     <xs:sequence>
   //       <xs:element name="height" type="xs:int" minOccurs="1" maxOccurs="unbounded">
   //         <xs:annotation>
   //           <xs:documentation xml:lang="en">One of two dimensions of a rectangle</xs:documentation>
   //         </xs:annotation>
   //       </xs:element>
   //       <xs:element name="width" type="xs:int" minOccurs="0" maxOccurs="unbounded"/>
   //     </xs:sequence>
   //   </xs:complexType>
   // </xs:schema>
   
   let schema = ^XsdSchema(
      items =^XsdComplexType(
         name=^QName(localPart='Rectangle', namespace=''),
         particle=^XsdSequence(
            minOccurs=1,
            maxOccurs=1,
            items = [
               ^XsdElement(
                  name=^QName(localPart='height', namespace=''),
                  typeName=xsType('int'),
                  minOccurs=1,
                  annotation=^XsdAnnotation(items=^XsdDocumentation(value='One of two dimensions of a rectangle', language='en'))
               ),
               ^XsdElement(
                  name=^QName(localPart='width', namespace=''),
                  typeName=xsType('int'),
                  minOccurs=0
               )
            ]
         )
      )
   );
   
   let result = xsdToPure(^Schema(format='XSD', detail=$schema), config('meta::xsd::tests::toPure::fixture1::', false, true));
   assertXsdToPureOutputs(meta::xsd::tests::toPure::fixture1.children, $result);   
}


Class <<typemodifiers.abstract>> meta::xsd::tests::toPure::fixture2::Abstract {}

function <<test.Test>> meta::xsd::tests::toPure::testAbstractClass():Boolean[1]
{
   // <?xml version='1.0'?>
   // <xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema">
   //   <xs:complexType name="Abstract" abstract="true">
   //   </xs:complexType>
   // </xs:schema>

   let schema = ^XsdSchema(
      items =^XsdComplexType(
         name=^QName(localPart='Abstract', namespace=''),
         abstract=true
      )
   );

   let result = xsdToPure(^Schema(format='XSD', detail=$schema), config('meta::xsd::tests::toPure::fixture2::', false, true));
   assertXsdToPureOutputs(meta::xsd::tests::toPure::fixture2.children, $result);   
}


Class {meta::pure::profiles::doc.doc='The data type used for link identifiers.'} meta::xsd::tests::toPure::fixture3::LinkId
[
  c1_length : $this.value->length() <= 255
]
{
  id : String[0..1];
  linkIdScheme : String[1];
  value : String[1];
}

function <<test.Test>> meta::xsd::tests::toPure::testAttribute():Boolean[1]
{
   // <?xml version='1.0' encoding='utf-8'?>
   // <xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema">
   //   <xs:complexType name="LinkId">
   //     <xs:annotation>
   //       <xs:documentation xml:lang="en">The data type used for link identifiers.</xs:documentation>
   //     </xs:annotation>
   //     <xs:simpleContent>
   //       <xs:extension base="Scheme">
   //         <xs:attribute name="id" type="xs:ID"/>
   //         <xs:attribute name="linkIdScheme" type="xs:anyURI" use="required"/>
   //       </xs:extension>
   //     </xs:simpleContent>
   //   </xs:complexType>
   //   <xs:simpleType name="Scheme">
   //     <xs:annotation>
   //       <xs:documentation xml:lang="en">The base class for all types which define coding schemes.</xs:documentation>
   //     </xs:annotation>
   //     <xs:restriction base="xs:normalizedString">
   //       <xs:maxLength value="255"/>
   //     </xs:restriction>
   //   </xs:simpleType>
   // </xs:schema>

   let schema = ^XsdSchema(
      items = [
         ^XsdComplexType(
            name=^QName(localPart='LinkId', namespace=''),
            annotation=^XsdAnnotation(items=^XsdDocumentation(value='The data type used for link identifiers.', language='en')),
            contentModel=^XsdSimpleContent(
               derivation=^XsdExtension(
                  baseTypeName=^QName(localPart='Scheme', namespace=''),
                  attributeItems=[
                     ^XsdAttribute(
                        name=^QName(localPart='id', namespace=''),
                        typeName=xsType('ID'),
                        use=XsdUse.OPTIONAL
                     ),
                     ^XsdAttribute(
                        name=^QName(localPart='linkIdScheme', namespace=''),
                        typeName=xsType('anyURI'),
                        use=XsdUse.REQUIRED
                     )
                  ]
               )
            )
         ),
         ^XsdSimpleType(
            name=^QName(localPart='Scheme', namespace=''),
            annotation=^XsdAnnotation(items=^XsdDocumentation(value='The base class for all types which define coding schemes.', language='en')),
            derivation=^XsdRestriction(
               baseTypeName=xsType('normalizedString'),
               facets=^XsdMaxLength(value='255')
            )
         )
      ]
   );

   let result = xsdToPure(^Schema(format='XSD', detail=$schema), config('meta::xsd::tests::toPure::fixture3::', false, true));
   assertXsdToPureOutputs(meta::xsd::tests::toPure::fixture3.children, $result);
}


Class {doc.doc='Class level doc'} meta::xsd::tests::toPure::fixture4::Rectangle
{
   height: Integer[1];
   width: Integer[1];
}

Class meta::xsd::tests::toPure::fixture4::Cuboid extends meta::xsd::tests::toPure::fixture4::Rectangle
{
   depth: Integer[1];
}

function <<test.Test>> meta::xsd::tests::toPure::testInheritance():Boolean[1]
{
   // <?xml version='1.0'?>
   // <xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema">
   //   <xs:complexType name="Rectangle">
   //     <xs:annotation>
   //       <xs:documentation xml:lang="en">Class level doc</xs:documentation>
   //     </xs:annotation>
   //     <xs:sequence>
   //       <xs:element name="height" type="xs:int"/>
   //       <xs:element name="width" type="xs:int"/>
   //     </xs:sequence>
   //   </xs:complexType>
   //   <xs:complexType name="Cuboid">
   //     <xs:complexContent>
   //       <xs:extension base="Rectangle">
   //         <xs:sequence>\n' +
   //           <xs:element name="depth" type="xs:int"/>
   //         </xs:sequence>
   //       </xs:extension>
   //     </xs:complexContent>
   //   </xs:complexType>
   // </xs:schema>

   let schema = ^XsdSchema(
      items = [
         ^XsdComplexType(
            name=^QName(localPart='Rectangle', namespace=''),
            annotation=^XsdAnnotation(items=^XsdDocumentation(value='Class level doc', language='en')),
            particle=^XsdSequence(
               minOccurs=1,
               maxOccurs=1,
               items=[
                  ^XsdElement(
                     name=^QName(localPart='height', namespace=''),
                     typeName=xsType('int'),
                     minOccurs=1,
                     maxOccurs=1
                  ),
                  ^XsdElement(
                     name=^QName(localPart='width', namespace=''),
                     typeName=xsType('int'),
                     minOccurs=1,
                     maxOccurs=1
                  )
               ]
            )
         ),
         ^XsdComplexType(
            name=^QName(localPart='Cuboid', namespace=''),
            contentModel=^XsdComplexContent(
               mixed=false,
               derivation=^XsdExtension(
                  baseTypeName=^QName(localPart='Rectangle', namespace=''),
                  particle=^XsdSequence(
                     minOccurs=1,
                     maxOccurs=1,
                     items=^XsdElement(
                        name=^QName(localPart='depth', namespace=''),
                        typeName=xsType('int'),
                        minOccurs=1,
                        maxOccurs=1
                     )
                  )
               )
            )
         )
      ]
   );

   let result = xsdToPure(^Schema(format='XSD', detail=$schema), config('meta::xsd::tests::toPure::fixture4::', false, true));
   assertXsdToPureOutputs(meta::xsd::tests::toPure::fixture4.children, $result);
}


Class meta::xsd::tests::toPure::fixture5::NestedSequences
{
   one: String[1];
   two: String[1];
   three: String[1];
}

function <<test.Test>> meta::xsd::tests::toPure::testNestedSequence():Boolean[1]
{
   // <?xml version='1.0'?>
   // <xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema">\n' +
   //   <xs:complexType name="NestedSequences">
   //     <xs:sequence>
   //       <xs:element name="one" type="xs:string"/>
   //       <xs:sequence>
   //         <xs:element name="two" type="xs:string"/>
   //         <xs:sequence>
   //           <xs:element name="three" type="xs:string"/>
   //         </xs:sequence>
   //       </xs:sequence>
   //     </xs:sequence>
   //   </xs:complexType>
   // </xs:schema>

   let schema = ^XsdSchema(
      items = [
         ^XsdComplexType(
            name=^QName(localPart='NestedSequences', namespace=''),
            particle=^XsdSequence(
               minOccurs=1,
               maxOccurs=1,
               items=[
                  ^XsdElement(
                     name=^QName(localPart='one', namespace=''),
                     typeName=xsType('string'),
                     minOccurs=1,
                     maxOccurs=1
                  ),
                  ^XsdSequence(
                     minOccurs=1,
                     maxOccurs=1,
                     items=[
                        ^XsdElement(
                           name=^QName(localPart='two', namespace=''),
                           typeName=xsType('string'),
                           minOccurs=1,
                           maxOccurs=1
                        ),
                        ^XsdSequence(
                           minOccurs=1,
                           maxOccurs=1,
                           items=^XsdElement(
                              name=^QName(localPart='three', namespace=''),
                              typeName=xsType('string'),
                              minOccurs=1,
                              maxOccurs=1
                           )
                        )
                     ]
                  )
               ]
            )
         )
      ]
   );

   let result = xsdToPure(^Schema(format='XSD', detail=$schema), config('meta::xsd::tests::toPure::fixture5::', false, true));
   assertXsdToPureOutputs(meta::xsd::tests::toPure::fixture5.children, $result);
}


Class meta::xsd::tests::toPure::fixture6::ShowValidations
[
  c1_length : $this.fixedLengthString->forAll(x|$x->length() == 12),
  c2_length : $this.minLengthString->length() >= 5,
  c3_length : $this.maxLengthString->forAll(x|$x->length() <= 20),
  c4_length : $this.rangeLengthString->forAll(x|$x->length() >= 5),
  c5_length : $this.rangeLengthString->forAll(x|$x->length() <= 20),
  c6_range : $this.minValInteger >= 1,
  c7_range : $this.minValFloat > 2.4,
  c8_range : $this.maxValInteger <= 100,
  c9_range : $this.maxValFloat < 10.12,
  c10_range : $this.rangeValInteger > 10,
  c11_range : $this.rangeValInteger <= 100,
  c12_range : $this.rangeValFloat > 2.7,
  c13_range : $this.rangeValFloat < 10.99,
  c14_values : $this.fixedValuesString->in(['AUD', 'USD'])
]
{
  fixedLengthString : String[*];
  minLengthString : String[1];
  maxLengthString : String[0..1];
  rangeLengthString : String[*];
  minValInteger : Integer[1];
  minValFloat : Float[1];
  maxValInteger : Integer[1];
  maxValFloat : Float[1];
  rangeValInteger : Integer[1];
  rangeValFloat : Float[1];
  fixedValuesString : String[1];
}


function <<test.Test>> meta::xsd::tests::toPure::testClassWithValidations():Boolean[1]
{
   // <?xml version='1.0'?>
   // <xs:schema xmlns:xs=\'http://www.w3.org/2001/XMLSchema\' attributeFormDefault=\'unqualified\' elementFormDefault=\'qualified\'>
   //   <xs:complexType name="ShowValidations">
   //     <xs:sequence>
   //       <xs:element name="fixedLengthString" minOccurs="0" maxOccurs="unbounded">
   //         <xs:simpleType>
   //           <xs:restriction base="xs:string">
   //             <xs:length value="12"/>
   //           </xs:restriction>
   //         </xs:simpleType>
   //       </xs:element>
   //       <xs:element name="minLengthString">
   //         <xs:simpleType>
   //           <xs:restriction base="xs:string">
   //             <xs:minLength value="5"/>
   //           </xs:restriction>
   //         </xs:simpleType>' +
   //       </xs:element>
   //       <xs:element name="maxLengthString" minOccurs="0">
   //         <xs:simpleType>
   //           <xs:restriction base="xs:string">
   //             <xs:maxLength value="20"/>
   //           </xs:restriction>
   //         </xs:simpleType>
   //       </xs:element>
   //       <xs:element name="rangeLengthString" minOccurs="0" maxOccurs="unbounded">
   //         <xs:simpleType>
   //           <xs:restriction base="xs:string">
   //             <xs:minLength value="5"/>
   //             <xs:maxLength value="20"/>
   //           </xs:restriction>
   //         </xs:simpleType>
   //       </xs:element>
   //       <xs:element name="minValInteger">
   //         <xs:simpleType>
   //           <xs:restriction base="xs:long">
   //             <xs:minInclusive value="1"/>
   //           </xs:restriction>
   //         </xs:simpleType>
   //       </xs:element>
   //       <xs:element name="minValFloat">
   //         <xs:simpleType>
   //           <xs:restriction base="xs:double">
   //             <xs:minExclusive value="2.4"/>
   //           </xs:restriction>
   //         </xs:simpleType>
   //       </xs:element>
   //       <xs:element name="maxValInteger">
   //         <xs:simpleType>
   //           <xs:restriction base="xs:long">
   //             <xs:maxInclusive value="100"/>
   //           </xs:restriction>
   //         </xs:simpleType>
   //       </xs:element>
   //       <xs:element name="maxValFloat">
   //         <xs:simpleType>
   //           <xs:restriction base="xs:double">
   //             <xs:maxExclusive value="10.12"/>
   //           </xs:restriction>
   //         </xs:simpleType>
   //       </xs:element>
   //       <xs:element name="rangeValInteger">
   //         <xs:simpleType>
   //           <xs:restriction base="xs:long">
   //             <xs:minExclusive value="10"/>
   //             <xs:maxInclusive value="100"/>
   //           </xs:restriction>
   //         </xs:simpleType>
   //       </xs:element>
   //       <xs:element name="rangeValFloat">
   //         <xs:simpleType>
   //           <xs:restriction base="xs:double">
   //             <xs:minExclusive value="2.7"/>
   //             <xs:maxExclusive value="10.99"/>
   //           </xs:restriction>
   //         </xs:simpleType>
   //       </xs:element>
   //     </xs:sequence>
   //     <xs:attribute name="fixedValuesString" use="required">
   //       <xs:simpleType>
   //         <xs:restriction base="xs:string">
   //           <xs:enumeration value="AUD"/>
   //           <xs:enumeration value="USD"/>
   //         </xs:restriction>
   //       </xs:simpleType>
   //     </xs:attribute>
   //   </xs:complexType>
   // </xs:schema>

   let schema = ^XsdSchema(
      attributeFormDefault=XsdForm.UNQUALIFIED,
      elementFormDefault=XsdForm.QUALIFIED,
      items = [
         ^XsdComplexType(
            name=^QName(localPart='ShowValidations', namespace=''),
            particle=^XsdSequence(
               minOccurs=1,
               maxOccurs=1,
               items=[
                  ^XsdElement(
                     name=^QName(localPart='fixedLengthString', namespace=''),
                     minOccurs=0,
                     type=^XsdSimpleType(
                        derivation=^XsdRestriction(
                           baseTypeName=xsType('string'),
                           facets=^XsdLength(value='12')                           
                        )
                     )
                  ),
                  ^XsdElement(
                     name=^QName(localPart='minLengthString', namespace=''),
                     minOccurs=1,
                     maxOccurs=1,
                     type=^XsdSimpleType(
                        derivation=^XsdRestriction(
                           baseTypeName=xsType('string'),
                           facets=^XsdMinLength(value='5')                           
                        )
                     )
                  ),
                  ^XsdElement(
                     name=^QName(localPart='maxLengthString', namespace=''),
                     minOccurs=0,
                     maxOccurs=1,
                     type=^XsdSimpleType(
                        derivation=^XsdRestriction(
                           baseTypeName=xsType('string'),
                           facets=^XsdMaxLength(value='20')                           
                        )
                     )
                  ),
                  ^XsdElement(
                     name=^QName(localPart='rangeLengthString', namespace=''),
                     minOccurs=0,
                     type=^XsdSimpleType(
                        derivation=^XsdRestriction(
                           baseTypeName=xsType('string'),
                           facets=[^XsdMinLength(value='5'), ^XsdMaxLength(value='20')]
                        )
                     )
                  ),
                  ^XsdElement(
                     name=^QName(localPart='minValInteger', namespace=''),
                     minOccurs=1,
                     maxOccurs=1,
                     type=^XsdSimpleType(
                        derivation=^XsdRestriction(
                           baseTypeName=xsType('long'),
                           facets=^XsdMinInclusive(value='1')
                        )
                     )
                  ),
                  ^XsdElement(
                     name=^QName(localPart='minValFloat', namespace=''),
                     minOccurs=1,
                     maxOccurs=1,
                     type=^XsdSimpleType(
                        derivation=^XsdRestriction(
                           baseTypeName=xsType('double'),
                           facets=^XsdMinExclusive(value='2.4')
                        )
                     )
                  ),
                  ^XsdElement(
                     name=^QName(localPart='maxValInteger', namespace=''),
                     minOccurs=1,
                     maxOccurs=1,
                     type=^XsdSimpleType(
                        derivation=^XsdRestriction(
                           baseTypeName=xsType('long'),
                           facets=^XsdMaxInclusive(value='100')
                        )
                     )
                  ),
                  ^XsdElement(
                     name=^QName(localPart='maxValFloat', namespace=''),
                     minOccurs=1,
                     maxOccurs=1,
                     type=^XsdSimpleType(
                        derivation=^XsdRestriction(
                           baseTypeName=xsType('double'),
                           facets=^XsdMaxExclusive(value='10.12')
                        )
                     )
                  ),
                  ^XsdElement(
                     name=^QName(localPart='rangeValInteger', namespace=''),
                     minOccurs=1,
                     maxOccurs=1,
                     type=^XsdSimpleType(
                        derivation=^XsdRestriction(
                           baseTypeName=xsType('long'),
                           facets=[^XsdMinExclusive(value='10'), ^XsdMaxInclusive(value='100')]
                        )
                     )
                  ),
                  ^XsdElement(
                     name=^QName(localPart='rangeValFloat', namespace=''),
                     minOccurs=1,
                     maxOccurs=1,
                     type=^XsdSimpleType(
                        derivation=^XsdRestriction(
                           baseTypeName=xsType('double'),
                           facets=[^XsdMinExclusive(value='2.7'), ^XsdMaxExclusive(value='10.99')]
                        )
                     )
                  )
               ]
            ),
            attributeItems=^XsdAttribute(
               name=^QName(localPart='fixedValuesString', namespace=''),
               use=XsdUse.REQUIRED,
               type=^XsdSimpleType(
                  derivation=^XsdRestriction(
                     baseTypeName=xsType('string'),
                     facets=[^XsdEnumeration(value='AUD'), ^XsdEnumeration(value='USD')                           ]
                  )
               )
            )            
         )
      ]
   );

   let result = xsdToPure(^Schema(format='XSD', detail=$schema), config('meta::xsd::tests::toPure::fixture6::', false, true));
   assertXsdToPureOutputs(meta::xsd::tests::toPure::fixture6.children, $result);
}


Class meta::xsd::tests::toPure::fixture7::Choice
[
   c1_choice : $this.optionOne->isNotEmpty() && $this.optionTwo->isEmpty() || $this.optionOne->isEmpty() && $this.optionTwo->isNotEmpty()
]
{   
   optionOne: Integer[0..1];
   optionTwo: Integer[0..1];
}

function <<test.Test>> meta::xsd::tests::toPure::testChoice():Boolean[1]
{
   // <?xml version='1.0'?>
   // <xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema">
   //   <xs:complexType name="Choice">
   //     <xs:choice>
   //       <xs:element name="optionOne" type="xs:int"/>
   //       <xs:element name="optionTwo" type="xs:int"/>
   //     </xs:choice>
   //   </xs:complexType>
   // </xs:schema>

   let schema = ^XsdSchema(
      items = [
         ^XsdComplexType(
            name=^QName(localPart='Choice', namespace=''),
            particle=^XsdChoice(
               minOccurs=1,
               maxOccurs=1,
               items=[
                  ^XsdElement(
                     name=^QName(localPart='optionOne', namespace=''),
                     typeName=xsType('int'),
                     minOccurs=1,
                     maxOccurs=1
                  ),
                  ^XsdElement(
                     name=^QName(localPart='optionTwo', namespace=''),
                     typeName=xsType('int'),
                     minOccurs=1,
                     maxOccurs=1
                  )
               ]
            )
         )
      ]
   );

   let result = xsdToPure(^Schema(format='XSD', detail=$schema), config('meta::xsd::tests::toPure::fixture7::', false, true));
   assertXsdToPureOutputs(meta::xsd::tests::toPure::fixture7.children, $result);
}

function <<test.Test>> meta::xsd::tests::toPure::testRefElement():Boolean[1]
{
   // <?xml version='1.0'?>
   // <xs:schema xmlns:xs=\'http://www.w3.org/2001/XMLSchema\'>\n' +
   //   <xs:complexType name="Rectangle\">\n' +
   //     <xs:sequence>\n' +
   //       <xs:element ref="height" minOccurs="1" maxOccurs="unbounded">\n' +
   //         <xs:annotation>
   //           <xs:documentation xml:lang="en">One of two dimensions of a rectangle</xs:documentation>
   //         </xs:annotation>
   //       </xs:element>
   //       <xs:element name="width" type="xs:int" minOccurs="0" maxOccurs="unbounded"/>
   //     </xs:sequence>
   //   </xs:complexType>
   //   <xs:element name="height" type="xs:int"/>
   // </xs:schema>
   
   let schema = ^XsdSchema(
      items = [
            ^XsdComplexType(
            name=^QName(localPart='Rectangle', namespace=''),
            particle=^XsdSequence(
               minOccurs=1,
               maxOccurs=1,
               items = [
                  ^XsdElement(
                     ref=^QName(localPart='height', namespace=''),
                     minOccurs=1,
                     annotation=^XsdAnnotation(items=^XsdDocumentation(value='One of two dimensions of a rectangle', language='en'))
                  ),
                  ^XsdElement(
                     name=^QName(localPart='width', namespace=''),
                     typeName=xsType('int'),
                     minOccurs=0
                  )
               ]
            )
         ),
         ^XsdElement(
            name=^QName(localPart='height', namespace=''),
            typeName=xsType('int'),
            minOccurs=1,
            maxOccurs=1,
            annotation=^XsdAnnotation(items=^XsdDocumentation(value='One of two dimensions of a rectangle', language='en'))
         )
      ]
   );

   let result = xsdToPure(^Schema(format='XSD', detail=$schema), config('meta::xsd::tests::toPure::fixture1::', false, true));
   assertXsdToPureOutputs(meta::xsd::tests::toPure::fixture1.children, $result);
}


Enum meta::xsd::tests::toPure::fixture8::CurrencyEnumeration
{
   AUD,
   BRL,
   CAD,
   CNY,
   EUR,
   GBP,
   INR,
   JPY,
   RUR,
   USD
}

function <<test.Test>> meta::xsd::tests::toPure::testEnumeration():Boolean[1]
{
   // <?xml version=\'1.0\'?>
   // <xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" version="1.0" elementFormDefault="qualified">
   //   <xs:simpleType name="CurrencyEnumeration">
   //     <xs:restriction base="xs:string">
   //        <xs:enumeration value="AUD"/><!-- Australian Dollar -->
   //        <xs:enumeration value="BRL"/><!-- Brazilian Real -->
   //        <xs:enumeration value="CAD"/><!-- Canadian Dollar -->
   //        <xs:enumeration value="CNY"/><!-- Chinese Yen -->
   //        <xs:enumeration value="EUR"/><!-- Euro -->
   //        <xs:enumeration value="GBP"/><!-- British Pound -->
   //        <xs:enumeration value="INR"/><!-- Indian Rupee -->
   //        <xs:enumeration value="JPY"/><!-- Japanese Yen -->
   //        <xs:enumeration value="RUR"/><!-- Russian Rouble -->
   //        <xs:enumeration value="USD"/><!-- US Dollar -->
   //        <xs:length value=\'3\'/>
   //      </xs:restriction>
   //   </xs:simpleType>
   // </xs:schema>

   let schema = ^XsdSchema(
      version = '1.0',
      elementFormDefault = XsdForm.QUALIFIED,
      items = ^XsdSimpleType(
         name=^QName(localPart='CurrencyEnumeration', namespace=''),
         derivation=^XsdRestriction(
            baseTypeName=xsType('string'),
            facets = [
               ^XsdEnumeration(value='AUD'),
               ^XsdEnumeration(value='BRL'),
               ^XsdEnumeration(value='CAD'),
               ^XsdEnumeration(value='CNY'),
               ^XsdEnumeration(value='EUR'),
               ^XsdEnumeration(value='GBP'),
               ^XsdEnumeration(value='INR'),
               ^XsdEnumeration(value='JPY'),
               ^XsdEnumeration(value='RUR'),
               ^XsdEnumeration(value='USD')
            ]
         )
      )
   );

   let result = xsdToPure(^Schema(format='XSD', detail=$schema), config('meta::xsd::tests::toPure::fixture8::', false, true));
   assertXsdToPureOutputs(meta::xsd::tests::toPure::fixture8.children, $result);
}


Class meta::xsd::tests::toPure::fixture9::OrderType
{
  customer : String[1];
  orderdetails : String[1];
  billto : String[1];
  shipto : String[1];
  status : String[0..1];
}

function <<test.Test>> meta::xsd::tests::toPure::testGroup():Boolean[1]
{
   // <?xml version='1.0'?>
   // <xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema">
   //   <xs:group name="custGroup">
   //     <xs:sequence>
   //       <xs:element name="customer" type="xs:string"/>
   //       <xs:element name="orderdetails" type="xs:string"/>
   //       <xs:element name="billto" type="xs:string"/>
   //       <xs:element name="shipto" type="xs:string"/>
   //     </xs:sequence>
   //   </xs:group>
   //   <xs:element name="order" type="OrderType">
   //   <xs:complexType name="OrderType">
   //     <xs:group ref="custGroup"/>
   //     <xs:attribute name="status" type="xs:string"/>
   //   </xs:complexType>
   // </xs:schema>

   let schema = ^XsdSchema(
      items = [
         ^XsdGroup(
            name=^QName(localPart='custGroup', namespace=''),
            minOccurs=1,
            maxOccurs=1,
            particle=^XsdSequence(
               minOccurs=1,
               maxOccurs=1,
               items = [
                  ^XsdElement(name=^QName(localPart='customer', namespace=''), typeName=xsType('string'), minOccurs=1, maxOccurs=1),
                  ^XsdElement(name=^QName(localPart='orderdetails', namespace=''), typeName=xsType('string'), minOccurs=1, maxOccurs=1),
                  ^XsdElement(name=^QName(localPart='billto', namespace=''), typeName=xsType('string'), minOccurs=1, maxOccurs=1),
                  ^XsdElement(name=^QName(localPart='shipto', namespace=''), typeName=xsType('string'), minOccurs=1, maxOccurs=1)
               ]
            )
         ),
         ^XsdElement(name=^QName(localPart='order', namespace=''), typeName=^QName(localPart='OrderType', namespace=''), minOccurs=1, maxOccurs=1),
         ^XsdComplexType(
            name=^QName(localPart='OrderType', namespace=''),
            particle=^XsdGroup(ref=^QName(localPart='custGroup', namespace=''), minOccurs=1, maxOccurs=1),
            attributeItems=^XsdAttribute(name=^QName(localPart='status', namespace=''), typeName=xsType('string'), use=XsdUse.OPTIONAL)
         )
      ]
   );

   let result = xsdToPure(^Schema(format='XSD', detail=$schema), config('meta::xsd::tests::toPure::fixture9::'));
   assertXsdToPureOutputs(meta::xsd::tests::toPure::fixture9.children, $result);
}


Class meta::xsd::tests::toPure::fixture10::AttributeWithInlineType
[
  c1_values : $this.fullOrDelta->forAll(x|$x->in(['FULL', 'DELTA'])),
  c2_length : $this.notTooLongString->forAll(x|$x->length() <= 500)
]
{
  fullOrDelta : String[0..1];
  notTooLongString : String[0..1];
}

function <<test.Test>> meta::xsd::tests::toPure::testAttributeWithInlineType():Boolean[1]
{
   // <?xml version='1.0'?>
   // <xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema">
   //   <xs:complexType name="AttributeWithInlineType">
   //     <xs:attribute name="fullOrDelta">
   //       <xs:simpleType>
   //         <xs:restriction base="xs:string">
   //           <xs:enumeration value="FULL"/>
   //           <xs:enumeration value="DELTA"/>
   //         </xs:restriction>
   //       </xs:simpleType>
   //     </xs:attribute>
   //     <xs:attribute name="notTooLongString">
   //       <xs:simpleType>' +
   //         <xs:restriction base="xs:string">
   //           <xs:maxLength value="500"/>
   //         </xs:restriction>
   //       </xs:simpleType>
   //     </xs:attribute>
   //   </xs:complexType>
   // </xs:schema>
   
   let schema = ^XsdSchema(
      items = ^XsdComplexType(
         name=^QName(localPart='AttributeWithInlineType', namespace=''),
         attributeItems=[
            ^XsdAttribute(
               name=^QName(localPart='fullOrDelta', namespace=''), 
               use=XsdUse.OPTIONAL,
               type=^XsdSimpleType(
                  derivation=^XsdRestriction(
                     baseTypeName=xsType('string'),
                     facets=[^XsdEnumeration(value='FULL'),^XsdEnumeration(value='DELTA')]
                  )
               )
            ),
            ^XsdAttribute(
               name=^QName(localPart='notTooLongString', namespace=''), 
               use=XsdUse.OPTIONAL,
               type=^XsdSimpleType(
                  derivation=^XsdRestriction(
                     baseTypeName=xsType('string'),
                     facets=^XsdMaxLength(value='500')
                  )
               )
            )
         ]
      )
   );

   let result = xsdToPure(^Schema(format='XSD', detail=$schema), config('meta::xsd::tests::toPure::fixture10::', false, true));
   assertXsdToPureOutputs(meta::xsd::tests::toPure::fixture10.children, $result);
}

Enum meta::xsd::tests::toPure::fixture11::WeeklyRollConventionEnum
{
  MON,
  TUE,
  WED,
  THU,
  FRI,
  SAT,
  SUN,
  TBILL
}

Enum meta::xsd::tests::toPure::fixture11::DayOfWeekEnum
{
  MON,
  TUE,
  WED,
  THU,
  FRI,
  SAT,
  SUN
}

function <<test.Test>> meta::xsd::tests::toPure::testEnumUnion():Boolean[1]
{
   // <?xml version=\'1.0\'?>
   // <xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema">' +
   //   <xs:simpleType name="DayOfWeekEnum">
   //     <xs:restriction base="xs:token">
   //       <xs:enumeration value="MON"/>
   //       <xs:enumeration value="TUE"/>
   //       <xs:enumeration value="WED"/>
   //       <xs:enumeration value="THU"/>
   //       <xs:enumeration value="FRI"/>
   //       <xs:enumeration value="SAT"/>
   //       <xs:enumeration value="SUN"/>
   //     </xs:restriction>
   //   </xs:simpleType>
   //   <xs:simpleType name="WeeklyRollConventionEnum">
   //     <xs:union memberTypes="DayOfWeekEnum">
   //       <xs:simpleType>
   //         <xs:restriction base="xs:token">
   //           <xs:enumeration value="TBILL"/
   //         </xs:restriction>
   //       </xs:simpleType>
   //     </xs:union>
   //   </xs:simpleType>
   // </xs:schema>
   
   let schema = ^XsdSchema(
      version = '1.0',
      elementFormDefault = XsdForm.QUALIFIED,
      items = [
         ^XsdSimpleType(
            name=^QName(localPart='DayOfWeekEnum', namespace=''),
            derivation=^XsdRestriction(
               baseTypeName=xsType('token'),
               facets = [
                  ^XsdEnumeration(value='MON'),
                  ^XsdEnumeration(value='TUE'),
                  ^XsdEnumeration(value='WED'),
                  ^XsdEnumeration(value='THU'),
                  ^XsdEnumeration(value='FRI'),
                  ^XsdEnumeration(value='SAT'),
                  ^XsdEnumeration(value='SUN')
               ]
            )
         ),
         ^XsdSimpleType(
            name=^QName(localPart='WeeklyRollConventionEnum', namespace=''),
            derivation=^XsdUnion(
               memberTypeNames=^QName(localPart='DayOfWeekEnum', namespace=''),
               memberTypes = ^XsdSimpleType(
                  derivation=^XsdRestriction(
                     baseTypeName=xsType('token'),
                     facets=^XsdEnumeration(value='TBILL')
                  )
               )
            )
         )
      ]
   );

   let result = xsdToPure(^Schema(format='XSD', detail=$schema), config('meta::xsd::tests::toPure::fixture11::', false, true));
   assertXsdToPureOutputs(meta::xsd::tests::toPure::fixture11.children, $result);
}


Class meta::xsd::tests::toPure::fixture12::Employee extends meta::xsd::tests::toPure::fixture12::Human
{
  firm : meta::xsd::tests::toPure::fixture12::Company[1];
}

Class meta::xsd::tests::toPure::fixture12::Human
{
  name : String[1];
}

Class meta::xsd::tests::toPure::fixture12::Company
{
  employees : meta::xsd::tests::toPure::fixture12::Employee[*];
}

function <<test.Test>> meta::xsd::tests::toPure::testCircularTypeDependency():Boolean[1]
{
   // <?xml version='1.0'?>
   // <xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema">
   //   <xs:complexType name="Human">
   //     <xs:sequence>
   //       <xs:element name="name" type="xs:string"/>
   //     </xs:sequence>
   //   </xs:complexType>
   //   <xs:complexType name="Employee">
   //     <xs:complexContent>
   //       <xs:extension base="Human">
   //          <xs:sequence>
   //            <xs:element name="firm" type="Company"/>
   //          </xs:sequence>
   //        </xs:extension>
   //     </xs:complexContent>
   //   </xs:complexType>
   //   <xs:complexType name="Company">
   //     <xs:sequence>
   //       <xs:element name="employees" type="Employee" minOccurs="0" maxOccurs="unbounded"/>
   //     </xs:sequence>
   //   </xs:complexType>
   // </xs:schema>
   
   let schema = ^XsdSchema(
      version = '1.0',
      elementFormDefault = XsdForm.QUALIFIED,
      items = [
         ^XsdComplexType(
            name=^QName(localPart='Human', namespace=''),
            particle=^XsdSequence(
               minOccurs=1,
               maxOccurs=1,
               items = ^XsdElement(
                  name=^QName(localPart='name', namespace=''),
                  minOccurs=1,
                  maxOccurs=1,
                  typeName=xsType('string')
               )
            )
         ),
         ^XsdComplexType(
            name=^QName(localPart='Employee', namespace=''),
            contentModel=^XsdComplexContent(
               mixed=false,
               derivation=^XsdExtension(
                  baseTypeName=^QName(localPart='Human', namespace=''),
                  particle=^XsdSequence(
                     minOccurs=1,
                     maxOccurs=1,
                     items = ^XsdElement(
                        name=^QName(localPart='firm', namespace=''),
                        minOccurs=1,
                        maxOccurs=1,
                        typeName=^QName(localPart='Company', namespace='')
                     )
                  )   
               )
            )
         ),
         ^XsdComplexType(
            name=^QName(localPart='Company', namespace=''),
            particle=^XsdSequence(
               minOccurs=1,
               maxOccurs=1,
               items = ^XsdElement(
                  name=^QName(localPart='employees', namespace=''),
                  minOccurs=0,
                  typeName=^QName(localPart='Employee', namespace='')
               )
            )
         )
      ]
   );

   let result = xsdToPure(^Schema(format='XSD', detail=$schema), config('meta::xsd::tests::toPure::fixture12::', false, true));

   let company = $result.generatedElements->filter(c | elementToPath($c)->equal('meta::xsd::tests::toPure::fixture12::Company'))->toOne()->cast(@Class<Any>);
   let employee = $result.generatedElements->filter(c | elementToPath($c)->equal('meta::xsd::tests::toPure::fixture12::Employee'))->toOne()->cast(@Class<Any>);
   
   let foundCompany = $employee.properties->filter(p | elementToPath($p)->equal('firm'))->toOne().genericType.rawType;
   let foundEmployee = $foundCompany->cast(@Class<Any>).properties->filter(p | elementToPath($p)->equal('employees'))->toOne().genericType.rawType;
   
   assert($foundCompany == $company);
   assert($foundEmployee == $employee);
   assertXsdToPureOutputs(meta::xsd::tests::toPure::fixture12.children, $result);
}


Class meta::xsd::tests::toPure::fixture13::Person
{
  firstName : String[1];
  lastName : String[1];
}

function <<test.Test>> meta::xsd::tests::toPure::testGenerateClassForInlineComplexTypes():Boolean[1]
{
   // <?xml version='1.0'?>
   // <xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema">
   //   <xs:element name="person">
   //     <xs:complexType>
   //       <xs:sequence>
   //         <xs:element name="firstName" type="xs:string"/>
   //         <xs:element name="lastName" type="xs:string"/>
   //       </xs:sequence>
   //     </xs:complexType>
   //   </xs:element>
   // </xs:schema>
   
   let schema = ^XsdSchema(
      version = '1.0',
      items = [
         ^XsdElement(
            name=^QName(localPart='person', namespace=''),
            minOccurs=1,
            maxOccurs=1,
            type=^XsdComplexType(
               particle=^XsdSequence(
                  minOccurs=1,
                  maxOccurs=1,
                  items = [
                     ^XsdElement(
                        name=^QName(localPart='firstName', namespace=''),
                        minOccurs=1,
                        maxOccurs=1,
                        typeName=xsType('string')
                     ),
                     ^XsdElement(
                        name=^QName(localPart='lastName', namespace=''),
                        minOccurs=1,
                        maxOccurs=1,
                        typeName=xsType('string')
                     )
                  ]
               )
            )
         )
      ]
   );

   let result = xsdToPure(^Schema(format='XSD', detail=$schema), config('meta::xsd::tests::toPure::fixture13::', false, true));
   assertXsdToPureOutputs(meta::xsd::tests::toPure::fixture13.children, $result);
}

Class meta::xsd::tests::toPure::fixture14::StringType
{
  source : String[0..1];
  origValue : String[0..1];
  comment : String[0..1];
  value : String[1];
}

Class meta::xsd::tests::toPure::fixture14::IdentifierType extends meta::xsd::tests::toPure::fixture14::StringType
{
  type : String[1];
  expiredDate : StrictDate[0..1];
}

function <<test.Test>> meta::xsd::tests::toPure::testExtendComplexTypeWithSimpleContent():Boolean[1]
{
   // <?xml version='1.0'?>
   // <xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema">
   //   <xs:complexType name="StringType">
   //     <xs:simpleContent>
   //       <xs:extension base="xs:string">
   //         <xs:attribute name="source" type="xs:string"/>
   //         <xs:attribute name="origValue" type="xs:string"/>
   //         <xs:attribute name="comment" type="xs:string"/>
   //       </xs:extension>
   //     </xs:simpleContent>
   //   </xs:complexType>
   //   <xs:complexType name="IdentifierType">
   //     <xs:simpleContent>
   //       <xs:extension base="StringType">
   //         <xs:attribute name="type" type="xs:string" use="required"/>
   //         <xs:attribute name="expiredDate" type="xs:date"/>
   //       </xs:extension>
   //     </xs:simpleContent>
   //   </xs:complexType>
   // </xs:schema>
   
   let schema = ^XsdSchema(
      version = '1.0',
      items = [
         ^XsdComplexType(
            name=^QName(localPart='StringType', namespace=''),
            contentModel=^XsdSimpleContent(
               derivation=^XsdExtension(
                  baseTypeName=xsType('string'),
                  attributeItems = [
                     ^XsdAttribute(name=^QName(localPart='source',    namespace=''), typeName=xsType('string'), use=XsdUse.OPTIONAL),
                     ^XsdAttribute(name=^QName(localPart='origValue', namespace=''), typeName=xsType('string'), use=XsdUse.OPTIONAL),
                     ^XsdAttribute(name=^QName(localPart='comment',   namespace=''), typeName=xsType('string'), use=XsdUse.OPTIONAL)
                  ]
               )
            )
         ),
         ^XsdComplexType(
            name=^QName(localPart='IdentifierType', namespace=''),
            contentModel=^XsdSimpleContent(
               derivation=^XsdExtension(
                  baseTypeName=^QName(localPart='StringType', namespace=''),
                  attributeItems = [
                     ^XsdAttribute(name=^QName(localPart='type',        namespace=''), typeName=xsType('string'), use=XsdUse.REQUIRED),
                     ^XsdAttribute(name=^QName(localPart='expiredDate', namespace=''), typeName=xsType('date'),   use=XsdUse.OPTIONAL)
                  ]
               )
            )
         )
      ]
   );

   let result = xsdToPure(^Schema(format='XSD', detail=$schema), config('meta::xsd::tests::toPure::fixture14::', false, true));
   assertXsdToPureOutputs(meta::xsd::tests::toPure::fixture14.children, $result);
}

Class meta::xsd::tests::toPure::fixture15::DerivativeTrailerType extends meta::xsd::tests::toPure::fixture15::TrailerType
{
  cntPrd : Integer[1];
  cntCtr : Integer[1];
}

Class meta::xsd::tests::toPure::fixture15::TrailerType
{
  exceptions : meta::xsd::tests::toPure::fixture15::ExceptionType[*];
  numberOfElements : Integer[0..1];
}

Class meta::xsd::tests::toPure::fixture15::ExceptionType
[
  c1_values : $this.type->in(['INFO', 'WARN', 'ERROR'])
]
{
  type : String[1];
  value : String[1];
}

function <<test.Test>> meta::xsd::tests::toPure::testExtendComplexTypeWithComplexTypePartiallyResolved():Boolean[1]
{
   // <?xml version='1.0'?>
   // <xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema">
   //   <xs:complexType name="TrailerType">
   //     <xs:sequence>
   //       <xs:element name="Exceptions" type="ExceptionType" minOccurs="0" maxOccurs="unbounded"/>
   //     </xs:sequence>
   //     <xs:attribute name="numberOfElements" type="xs:int"/>
   //   </xs:complexType>
   //   <xs:complexType name="ExceptionType">
   //     <xs:simpleContent>
   //       <xs:extension base="xs:string">
   //         <xs:attribute name="type" use="required">
   //           <xs:simpleType>
   //             <xs:restriction base="xs:string">
   //               <xs:enumeration value="INFO"/>
   //               <xs:enumeration value="WARN"/>
   //               <xs:enumeration value="ERROR"/>
   //             </xs:restriction>
   //           </xs:simpleType>
   //         </xs:attribute>
   //       </xs:extension>
   //     </xs:simpleContent>
   //   </xs:complexType>
   //   <xs:complexType name="DerivativeTrailerType">
   //     <xs:complexContent>
   //       <xs:extension base="TrailerType">
   //         <xs:attribute name="CntPrd" type="xs:int" use="required" />
   //         <xs:attribute name="CntCtr" type="xs:int" use="required" />
   //       </xs:extension>
   //     </xs:complexContent>
   //   </xs:complexType>
   // </xs:schema>
   
   let schema = ^XsdSchema(
      version = '1.0',
      items = [
         ^XsdComplexType(
            name=^QName(localPart='TrailerType', namespace=''),
            particle=^XsdSequence(
               minOccurs=1,
               maxOccurs=1,
               items = ^XsdElement(name=^QName(localPart='Exceptions', namespace=''), typeName=^QName(localPart='ExceptionType', namespace=''), minOccurs=0)
            ),
            attributeItems = ^XsdAttribute(name=^QName(localPart='numberOfElements', namespace=''), typeName=xsType('int'), use=XsdUse.OPTIONAL)
         ),
         ^XsdComplexType(
            name=^QName(localPart='ExceptionType', namespace=''),
            contentModel=^XsdSimpleContent(
               derivation=^XsdExtension(
                  baseTypeName=xsType('string'),
                  attributeItems = ^XsdAttribute(
                     name=^QName(localPart='type', namespace=''), 
                     use=XsdUse.REQUIRED,
                     type=^XsdSimpleType(
                        derivation=^XsdRestriction(
                           baseTypeName=xsType('string'),
                           facets=[^XsdEnumeration(value='INFO'), ^XsdEnumeration(value='WARN'), ^XsdEnumeration(value='ERROR')]
                        )
                     )
                  )
               )
            )
         ),
         ^XsdComplexType(
            name=^QName(localPart='DerivativeTrailerType', namespace=''),
            contentModel=^XsdComplexContent(
               mixed=false,
               derivation=^XsdExtension(
                  baseTypeName=^QName(localPart='TrailerType', namespace=''),
                  attributeItems = [
                     ^XsdAttribute(name=^QName(localPart='CntPrd', namespace=''), typeName=xsType('int'), use=XsdUse.REQUIRED),
                     ^XsdAttribute(name=^QName(localPart='CntCtr', namespace=''), typeName=xsType('int'), use=XsdUse.REQUIRED)
                  ]
               )
            )
         )
      ]
   );

   let result = xsdToPure(^Schema(format='XSD', detail=$schema), config('meta::xsd::tests::toPure::fixture15::', false, true));
   assertXsdToPureOutputs(meta::xsd::tests::toPure::fixture15.children, $result);
}


Class meta::xsd::tests::toPure::fixture16::Person
{
  firstName : String[1];
  lastName : String[1];
}

Class meta::xsd::tests::toPure::fixture16::Firm
{
  employees : meta::xsd::tests::toPure::fixture16::Person[*];
}

function <<test.Test>> meta::xsd::tests::toPure::testCollectionTypesInlined():Boolean[1]
{
   // <?xml version='1.0'?>
   // <xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema">
   //   <xs:complexType name="Person">
   //     <xs:sequence>
   //       <xs:element name="firstName" type="xs:string"/>
   //       <xs:element name="lastName" type="xs:string"/>
   //     </xs:sequence>
   //   </xs:complexType>
   //   <xs:complexType name="People">
   //     <xs:sequence>
   //       <xs:element name="person" type="Person" minOccurs="0" maxOccurs="unbounded"/>
   //     </xs:sequence>
   //   </xs:complexType>
   //   <xs:element name="firm">
   //     <xs:complexType>
   //       <xs:sequence>
   //         <xs:element name="employees" type="People" minOccurs="0" />
   //       </xs:sequence>
   //     </xs:complexType>
   //   </xs:element>
   // </xs:schema>
   
   let schema = ^XsdSchema(
      version = '1.0',
      elementFormDefault = XsdForm.QUALIFIED,
      items = [
         ^XsdComplexType(
            name=^QName(localPart='Person', namespace=''),
            particle=^XsdSequence(
               minOccurs=1,
               maxOccurs=1,
               items = [
                  ^XsdElement(name=^QName(localPart='firstName', namespace=''), typeName=xsType('string'), minOccurs=1, maxOccurs=1),
                  ^XsdElement(name=^QName(localPart='lastName', namespace=''), typeName=xsType('string'), minOccurs=1, maxOccurs=1)
               ]
            )
         ),
         ^XsdComplexType(
            name=^QName(localPart='People', namespace=''),
            particle=^XsdSequence(
               minOccurs=1,
               maxOccurs=1,
               items = ^XsdElement(name=^QName(localPart='person', namespace=''), typeName=^QName(localPart='Person', namespace=''), minOccurs=0)
            )
         ),
         ^XsdElement(
            name=^QName(localPart='firm', namespace=''),
            minOccurs=1,
            maxOccurs=1,
            type=^XsdComplexType(
               particle=^XsdSequence(
                  minOccurs=1,
                  maxOccurs=1,
                  items = ^XsdElement(name=^QName(localPart='employees', namespace=''), typeName=^QName(localPart='People', namespace=''), minOccurs=0, maxOccurs=1)
               )
            )
         )
      ]
   );

   let result = xsdToPure(^Schema(format='XSD', detail=$schema), config('meta::xsd::tests::toPure::fixture16::', true, false));
   assertXsdToPureOutputs(meta::xsd::tests::toPure::fixture16.children, $result);
}


Class meta::xsd::tests::toPure::fixture17::Person
{
  names : String[*];
}

function <<test.Test>> meta::xsd::tests::toPure::testCollectionTypesInlinedForPrimitive():Boolean[1]
{
   // <?xml version='1.0'?>
   // <xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema">
   //   <xs:complexType name="Names">
   //     <xs:sequence>
   //       <xs:element name="name" type="xs:string"  minOccurs="0"  maxOccurs="unbounded"/>
   //     </xs:sequence>
   //   </xs:complexType>
   //   <xs:element name="person">
   //     <xs:complexType>
   //       <xs:sequence>
   //         <xs:element name="names" type="Names" minOccurs="0" />
   //       </xs:sequence>
   //     </xs:complexType>
   //   </xs:element>
   // </xs:schema>
   
   let schema = ^XsdSchema(
      version = '1.0',
      items = [
         ^XsdComplexType(
            name=^QName(localPart='Names', namespace=''),
            particle=^XsdSequence(
               minOccurs=1,
               maxOccurs=1,
               items = ^XsdElement(name=^QName(localPart='name', namespace=''), typeName=xsType('string'), minOccurs=0)
            )
         ),
         ^XsdElement(
            name=^QName(localPart='person', namespace=''),
            minOccurs=1,
            maxOccurs=1,
            type=^XsdComplexType(
               particle=^XsdSequence(
                  minOccurs=1,
                  maxOccurs=1,
                  items = ^XsdElement(name=^QName(localPart='names', namespace=''), typeName=^QName(localPart='Names', namespace=''), minOccurs=0, maxOccurs=1)
               )
            )
         )
      ]
   );

   let result = xsdToPure(^Schema(format='XSD', detail=$schema), config('meta::xsd::tests::toPure::fixture17::', true, false));
   assertXsdToPureOutputs(meta::xsd::tests::toPure::fixture17.children, $result);
}


Class meta::xsd::tests::toPure::fixture18::Account
[
  c1_choice : $this.beneficiaryId->isNotEmpty() || $this.beneficiaryId->isEmpty() && $this.servicerId->isNotEmpty()
]
{
  accountId : String[1];
  beneficiaryId : Integer[0..1];
  servicerId : Integer[0..1];
}

function <<test.Test>> meta::xsd::tests::toPure::testChoiceWithCommonProperty():Boolean[1]
{
   // <?xml version='1.0'?>
   // <xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema">
   //   <xs:complexType name="Account">
   //     <xs:sequence>
   //       <xsd:element name="accountId" type="xs:token">
   //       <xsd:choice>
   //         <xs:sequence>
   //           <xsd:element name="beneficiaryId" type="xs:int">
   //           <xsd:element name="servicerId" type="xs:int" minOccurs="0">
   //         </xs:sequence>
   //         <xs:sequence>
   //           <xsd:element name="servicerId" type="xs:int">
   //         </xs:sequence>
   //       </xsd:choice>
   //     </xs:sequence>
   //   </xs:complexType>
   // </xs:schema>

   let schema = ^XsdSchema(
      items = [
         ^XsdComplexType(
            name=^QName(localPart='Account', namespace=''),
            particle=^XsdSequence(
               minOccurs=1,
               maxOccurs=1,
               items = [
                  ^XsdElement(name=^QName(localPart='accountId', namespace=''), typeName=xsType('token'), minOccurs=1, maxOccurs=1),
                  ^XsdChoice(
                     minOccurs=1,
                     maxOccurs=1,
                     items=[
                        ^XsdSequence(
                           minOccurs=1,
                           maxOccurs=1,
                           items = [
                              ^XsdElement(name=^QName(localPart='beneficiaryId', namespace=''), typeName=xsType('int'), minOccurs=1, maxOccurs=1),
                              ^XsdElement(name=^QName(localPart='servicerId', namespace=''), typeName=xsType('int'), minOccurs=0, maxOccurs=1)
                           ]
                        ),
                        ^XsdSequence(
                           minOccurs=1,
                           maxOccurs=1,
                           items = [
                              ^XsdElement(name=^QName(localPart='servicerId', namespace=''), typeName=xsType('int'), minOccurs=1, maxOccurs=1)
                           ]
                        )
                     ]
                  )
               ]
            )
         )
      ]
   );

   let result = xsdToPure(^Schema(format='XSD', detail=$schema), config('meta::xsd::tests::toPure::fixture18::', false, true));
   assertXsdToPureOutputs(meta::xsd::tests::toPure::fixture18.children, $result);
}


Class meta::xsd::tests::toPure::fixture19::AccountId
[
  c1_length : $this.value->length() >= 1,
  c2_length : $this.value->length() <= 255
]
{
  value : String[1];
}

function <<test.Test>> meta::xsd::tests::toPure::testInheritedLengthRestriction():Boolean[1]
{
   // <?xml version='1.0'?>
   // <xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema">
   //   <xs:simpleType name="NormalizedString">
   //     <xs:restriction base="xsd:normalizedString">
   //       <xs:minLength value="0" />
   //     </xs:restriction>
   //   </xs:simpleType>
   //   <xs:simpleType name="NonEmptyScheme">
   //     <xs:restriction base="NormalizedString">
   //       <xs:minLength value="1"></xsd:minLength>
   //       <xs:maxLength value="255" />
   //     </xs:restriction>
   //   </xs:simpleType>
   //   <xs:complexType name="AccountId">
   //     <xs:simpleContent>
   //       <xs:extension base="NonEmptyScheme" />
   //     </xs:simpleContent>
   //   </xs:complexType>
   // </xs:schema>

   let schema = ^XsdSchema(
      items = [
         ^XsdSimpleType(
            name=^QName(localPart='NormalizedString', namespace=''),
            derivation=^XsdRestriction(
               baseTypeName=xsType('normalizedString'),
               facets=^XsdMinLength(value='0')
            )
         ),
         ^XsdSimpleType(
            name=^QName(localPart='NonEmptyScheme', namespace=''),
            derivation=^XsdRestriction(
               baseTypeName=^QName(localPart='NormalizedString', namespace=''),
               facets=[^XsdMinLength(value='1'), ^XsdMaxLength(value='255')]
            )
         ),
         ^XsdComplexType(
            name=^QName(localPart='AccountId', namespace=''),
            contentModel=^XsdSimpleContent(
               derivation=^XsdExtension(
                  baseTypeName=^QName(localPart='NonEmptyScheme', namespace='')
               )
            )
         )
      ]
   );

   let result = xsdToPure(^Schema(format='XSD', detail=$schema), config('meta::xsd::tests::toPure::fixture19::', false, true));
   assertXsdToPureOutputs(meta::xsd::tests::toPure::fixture19.children, $result);
}

