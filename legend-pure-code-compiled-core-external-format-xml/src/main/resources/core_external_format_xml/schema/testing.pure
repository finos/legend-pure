// Copyright 2021 Goldman Sachs
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import meta::alloy::metadataServer::*;
import meta::external::shared::*;
import meta::external::shared::generation::*;
import meta::json::*;
import meta::pure::functions::io::http::*;
import meta::pure::metamodel::serialization::grammar::*;
import meta::xml::metamodel::*;
import meta::xsd::metamodel::*;
import meta::xsd::tests::toPure::*;
import meta::xsd::toPure::*;

function meta::xsd::tests::toPure::assertXsdToPureOutputs(expected:PackageableElement[*], actual:ModelGenerationResult[1]):Boolean[1]
{
   let expectedByName = $expected->groupBy(pe| $pe->elementToPath());
   let actualByName   = $actual.generatedElements->groupBy(pe| $pe->elementToPath());

   $expectedByName->keys()->map(path| 
      assert($actualByName->get($path)->isNotEmpty(), |'Missing ' + $path);

      let expected = $expectedByName->get($path).values->toOne();
      let actual   = $actualByName->get($path).values->toOne();
                                
      $expected->match([
         {expectedClass:Class<Any>[1] | 
            assert($actual->instanceOf(Class), |'Expected Class for ' + $path + ' but got ' + $actual->type().name->toOne());
            assertEquals(printClass($expectedClass), printClass($actual->cast(@Class<Any>)));
         },
         {expectedEnumeration:meta::pure::metamodel::type::Enumeration<Any>[1] | 
            assert($actual->instanceOf(meta::pure::metamodel::type::Enumeration), |'Expected Enumeration for ' + $path + ' but got ' + $actual->type().name->toOne());
            assertEquals(printEnumeration($expectedEnumeration), printEnumeration($actual->cast(@meta::pure::metamodel::type::Enumeration<Any>)));
         },
         {expectedOther:Any[1] | 
            $expectedOther->println();
            fail('Only Classes and Enumerations are  currently expected o be generated by xsdToPure');
         }
      ]);
   );
   
   assertEquals($expected->size(), $actual.generatedElements->size());
}

function meta::xsd::tests::toPure::xsType(type: String[1]): QName[1]
{
   ^QName(localPart=$type, namespace='http://www.w3.org/2001/XMLSchema');
}

function meta::xsd::tests::toPure::config(pkg: String[1]): XsdToModelConfiguration[1]
{
   config($pkg, false, false);
}

function meta::xsd::tests::toPure::config(pkg: String[1], inlineCollectionClasses:Boolean[1], includeUnreachableClasses:Boolean[1]): XsdToModelConfiguration[1]
{
   ^XsdToModelConfiguration(targetPackage=$pkg, inlineCollectionClasses=$inlineCollectionClasses, includeUnreachableClasses=$includeUnreachableClasses);
}

function meta::xsd::tests::toPure::toTestXsdGrammar(xsd:String[1]): String[1]
{
   '###ExternalFormat\n' +
   'Schema test::XsdSchema\n' + 
   '{\n' +
   '  format: XSD;\n' +
   '  schemaLocation: \'test.xsd\';\n' +
   '}\n' +
   '~~START~~\n' +
   $xsd + '\n' +
   '~~END~~';
}

function meta::xsd::tests::toPure::toNamedTestXsdGrammar(xsd: String[1], name: String[1], packageableName: String[1]): String[1]
{
   'Schema test::'+ $packageableName + '\n' + 
   '{\n' +
   '  format: XSD;\n' +
   '  schemaLocation: \'' + $name + '\';\n' +
   '}\n' +
   '~~START~~\n' +
   $xsd + '\n' +
   '~~END~~';
}

function meta::xsd::tests::toPure::combineGrammars(grammars: String[1..*]): String[1]
{
   '###ExternalFormat\n' + $grammars->fold({x, y | $x + '\n' + $y}, '');
}
